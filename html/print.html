<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Rust-LINFO2315</title>
        <meta name="robots" content="noindex" />
        <script async src="https://www.gstatic.com/brandstudio/kato/cookie_choice_component/cookie_consent_bar.v3.js"
                data-autoload-cookie-consent-bar="true"></script>

        <script async src="https://www.googletagmanager.com/gtag/js?id=G-ZN78TEJMRW"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-ZN78TEJMRW');
        </script>

        <!-- Custom HTML head -->
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="svgbob.css">
        <link rel="stylesheet" href="speaker-notes.css">
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item affix "><a href="welcome.html">Welcome to Comprehensive Rust ü¶Ä</a></li><li class="chapter-item "><a href="running-the-course/course-structure.html"><strong aria-hidden="true">1.</strong> Course Structure</a></li><li class="chapter-item "><a href="running-the-course/keyboard-shortcuts.html"><strong aria-hidden="true">2.</strong> Keyboard Shortcuts</a></li><li class="chapter-item "><a href="cargo.html"><strong aria-hidden="true">3.</strong> Using Cargo</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="cargo/rust-ecosystem.html"><strong aria-hidden="true">3.1.</strong> Rust Ecosystem</a></li><li class="chapter-item "><a href="cargo/code-samples.html"><strong aria-hidden="true">3.2.</strong> Code Samples</a></li><li class="chapter-item "><a href="cargo/running-locally.html"><strong aria-hidden="true">3.3.</strong> Running Cargo Locally</a></li></ol></li><li class="chapter-item "><li class="part-title">Course 1</li><li class="spacer"></li><li class="chapter-item "><a href="course-1.html"><strong aria-hidden="true">4.</strong> Welcome</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="course-1/what-is-rust.html"><strong aria-hidden="true">4.1.</strong> What is Rust?</a></li></ol></li><li class="chapter-item "><a href="hello-world.html"><strong aria-hidden="true">5.</strong> Hello World!</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="hello-world/small-example.html"><strong aria-hidden="true">5.1.</strong> Small Example</a></li></ol></li><li class="chapter-item "><a href="why-rust.html"><strong aria-hidden="true">6.</strong> Why Rust?</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="why-rust/compile-time.html"><strong aria-hidden="true">6.1.</strong> Compile Time Guarantees</a></li><li class="chapter-item "><a href="why-rust/runtime.html"><strong aria-hidden="true">6.2.</strong> Runtime Guarantees</a></li><li class="chapter-item "><a href="why-rust/modern.html"><strong aria-hidden="true">6.3.</strong> Modern Features</a></li></ol></li><li class="chapter-item "><a href="basic-syntax.html"><strong aria-hidden="true">7.</strong> Basic Syntax</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="basic-syntax/if-expressions.html"><strong aria-hidden="true">7.1.</strong> If expressions</a></li><li class="chapter-item "><a href="basic-syntax/scalar-types.html"><strong aria-hidden="true">7.2.</strong> Scalar Types</a></li><li class="chapter-item "><a href="basic-syntax/compound-types.html"><strong aria-hidden="true">7.3.</strong> Compound Types</a></li><li class="chapter-item "><a href="basic-syntax/references.html"><strong aria-hidden="true">7.4.</strong> References</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="basic-syntax/references-dangling.html"><strong aria-hidden="true">7.4.1.</strong> Dangling References</a></li></ol></li><li class="chapter-item "><a href="basic-syntax/slices.html"><strong aria-hidden="true">7.5.</strong> Slices</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="basic-syntax/string-slices.html"><strong aria-hidden="true">7.5.1.</strong> String vs str</a></li></ol></li><li class="chapter-item "><a href="basic-syntax/functions.html"><strong aria-hidden="true">7.6.</strong> Functions</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="basic-syntax/methods.html"><strong aria-hidden="true">7.6.1.</strong> Methods</a></li><li class="chapter-item "><a href="basic-syntax/functions-interlude.html"><strong aria-hidden="true">7.6.2.</strong> Overloading</a></li></ol></li></ol></li><li class="chapter-item "><a href="exercises/course-1/morning.html"><strong aria-hidden="true">8.</strong> Exercises</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="exercises/course-1/implicit-conversions.html"><strong aria-hidden="true">8.1.</strong> Implicit Conversions</a></li><li class="chapter-item "><a href="exercises/course-1/matrix-mult.html"><strong aria-hidden="true">8.2.</strong> Matrix multiplication</a></li><li class="chapter-item "><a href="exercises/course-1/for-loops.html"><strong aria-hidden="true">8.3.</strong> Arrays and for Loops</a></li><li class="chapter-item "><a href="exercises/course-1/palindrome.html"><strong aria-hidden="true">8.4.</strong> Palindrome</a></li><li class="chapter-item "><a href="exercises/course-1/fibonacci.html"><strong aria-hidden="true">8.5.</strong> Fibonacci</a></li><li class="chapter-item "><a href="exercises/course-1/collatz.html"><strong aria-hidden="true">8.6.</strong> Collatz Sequence</a></li></ol></li><li class="chapter-item "><li class="part-title">Course 2</li><li class="spacer"></li><li class="chapter-item "><a href="course-2.html"><strong aria-hidden="true">9.</strong> Welcome</a></li><li class="chapter-item "><a href="basic-syntax/variables.html"><strong aria-hidden="true">10.</strong> Variables</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="basic-syntax/type-inference.html"><strong aria-hidden="true">10.1.</strong> Type Inference</a></li><li class="chapter-item "><a href="basic-syntax/option.html"><strong aria-hidden="true">10.2.</strong> Option</a></li><li class="chapter-item "><a href="basic-syntax/static-and-const.html"><strong aria-hidden="true">10.3.</strong> static & const</a></li><li class="chapter-item "><a href="basic-syntax/scopes-shadowing.html"><strong aria-hidden="true">10.4.</strong> Scopes and Shadowing</a></li></ol></li><li class="chapter-item "><a href="memory-management.html"><strong aria-hidden="true">11.</strong> Memory Management</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="memory-management/stack-vs-heap.html"><strong aria-hidden="true">11.1.</strong> Stack vs Heap</a></li><li class="chapter-item "><a href="memory-management/stack.html"><strong aria-hidden="true">11.2.</strong> Stack Memory</a></li><li class="chapter-item "><a href="memory-management/manual.html"><strong aria-hidden="true">11.3.</strong> Manual Memory Management</a></li><li class="chapter-item "><a href="memory-management/scope-based.html"><strong aria-hidden="true">11.4.</strong> Scope-Based Memory Management</a></li><li class="chapter-item "><a href="memory-management/garbage-collection.html"><strong aria-hidden="true">11.5.</strong> Garbage Collection</a></li><li class="chapter-item "><a href="memory-management/rust.html"><strong aria-hidden="true">11.6.</strong> Rust Memory Management</a></li><li class="chapter-item "><a href="memory-management/comparison.html"><strong aria-hidden="true">11.7.</strong> Comparison</a></li></ol></li><li class="chapter-item "><a href="ownership.html"><strong aria-hidden="true">12.</strong> Ownership</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ownership/move-semantics.html"><strong aria-hidden="true">12.1.</strong> Move Semantics</a></li><li class="chapter-item "><a href="ownership/moved-strings-rust.html"><strong aria-hidden="true">12.2.</strong> Moved Strings in Rust</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ownership/double-free-modern-cpp.html"><strong aria-hidden="true">12.2.1.</strong> Double Frees in Modern C++</a></li></ol></li><li class="chapter-item "><a href="ownership/moves-function-calls.html"><strong aria-hidden="true">12.3.</strong> Moves in Function Calls</a></li><li class="chapter-item "><a href="ownership/copy-clone.html"><strong aria-hidden="true">12.4.</strong> Copying and Cloning</a></li><li class="chapter-item "><a href="ownership/borrowing.html"><strong aria-hidden="true">12.5.</strong> Borrowing</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ownership/shared-unique-borrows.html"><strong aria-hidden="true">12.5.1.</strong> Shared and Unique Borrows</a></li></ol></li><li class="chapter-item "><a href="ownership/lifetimes.html"><strong aria-hidden="true">12.6.</strong> Lifetimes</a></li><li class="chapter-item "><a href="ownership/lifetimes-function-calls.html"><strong aria-hidden="true">12.7.</strong> Lifetimes in Function Calls</a></li><li class="chapter-item "><a href="ownership/lifetimes-data-structures.html"><strong aria-hidden="true">12.8.</strong> Lifetimes in Data Structures</a></li></ol></li><li class="chapter-item "><a href="exercises/course-2/afternoon.html"><strong aria-hidden="true">13.</strong> Exercises</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="exercises/course-2/book-library.html"><strong aria-hidden="true">13.1.</strong> Designing a Library</a></li><li class="chapter-item "><a href="exercises/course-2/iterators-and-ownership.html"><strong aria-hidden="true">13.2.</strong> Iterators and Ownership</a></li><li class="chapter-item "><a href="exercises/course-2/builder-type.html"><strong aria-hidden="true">13.3.</strong> Builder Type</a></li></ol></li><li class="chapter-item "><li class="part-title">Course 3</li><li class="spacer"></li><li class="chapter-item "><a href="course-3.html"><strong aria-hidden="true">14.</strong> Welcome</a></li><li class="chapter-item "><a href="structs.html"><strong aria-hidden="true">15.</strong> Structs</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="structs/tuple-structs.html"><strong aria-hidden="true">15.1.</strong> Tuple Structs</a></li><li class="chapter-item "><a href="structs/field-shorthand.html"><strong aria-hidden="true">15.2.</strong> Field Shorthand Syntax</a></li></ol></li><li class="chapter-item "><a href="enums.html"><strong aria-hidden="true">16.</strong> Enums</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="enums/variant-payloads.html"><strong aria-hidden="true">16.1.</strong> Variant Payloads</a></li><li class="chapter-item "><a href="enums/sizes.html"><strong aria-hidden="true">16.2.</strong> Enum Sizes</a></li></ol></li><li class="chapter-item "><a href="methods.html"><strong aria-hidden="true">17.</strong> Methods</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="methods/receiver.html"><strong aria-hidden="true">17.1.</strong> Method Receiver</a></li><li class="chapter-item "><a href="methods/example.html"><strong aria-hidden="true">17.2.</strong> Example</a></li></ol></li><li class="chapter-item "><a href="pattern-matching.html"><strong aria-hidden="true">18.</strong> Pattern Matching</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="pattern-matching/destructuring-enums.html"><strong aria-hidden="true">18.1.</strong> Destructuring Enums</a></li><li class="chapter-item "><a href="pattern-matching/destructuring-structs.html"><strong aria-hidden="true">18.2.</strong> Destructuring Structs</a></li><li class="chapter-item "><a href="pattern-matching/destructuring-arrays.html"><strong aria-hidden="true">18.3.</strong> Destructuring Arrays</a></li><li class="chapter-item "><a href="pattern-matching/match-guards.html"><strong aria-hidden="true">18.4.</strong> Match Guards</a></li></ol></li><li class="chapter-item "><a href="exercises/course-3/morning.html"><strong aria-hidden="true">19.</strong> Exercises</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="exercises/course-3/health-statistics.html"><strong aria-hidden="true">19.1.</strong> Health Statistics</a></li><li class="chapter-item "><a href="exercises/course-3/points-polygons.html"><strong aria-hidden="true">19.2.</strong> Points and Polygons</a></li><li class="chapter-item "><a href="exercises/course-3/expression-eval.html"><strong aria-hidden="true">19.3.</strong> Expression Evaluation</a></li></ol></li><li class="chapter-item "><li class="part-title">Course 4</li><li class="spacer"></li><li class="chapter-item "><a href="course-4.html"><strong aria-hidden="true">20.</strong> Welcome</a></li><li class="chapter-item "><a href="control-flow.html"><strong aria-hidden="true">21.</strong> Control Flow</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="control-flow/if-let-expressions.html"><strong aria-hidden="true">21.1.</strong> if let expressions</a></li><li class="chapter-item "><a href="control-flow/while-expressions.html"><strong aria-hidden="true">21.2.</strong> while expressions</a></li><li class="chapter-item "><a href="control-flow/while-let-expressions.html"><strong aria-hidden="true">21.3.</strong> while let expressions</a></li><li class="chapter-item "><a href="control-flow/for-expressions.html"><strong aria-hidden="true">21.4.</strong> for expressions</a></li><li class="chapter-item "><a href="control-flow/loop-expressions.html"><strong aria-hidden="true">21.5.</strong> loop expressions</a></li><li class="chapter-item "><a href="control-flow/match-expressions.html"><strong aria-hidden="true">21.6.</strong> match expressions</a></li><li class="chapter-item "><a href="control-flow/break-continue.html"><strong aria-hidden="true">21.7.</strong> break & continue</a></li></ol></li><li class="chapter-item "><a href="std.html"><strong aria-hidden="true">22.</strong> Standard Library</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="std/option-result.html"><strong aria-hidden="true">22.1.</strong> Option and Result</a></li><li class="chapter-item "><a href="std/string.html"><strong aria-hidden="true">22.2.</strong> String</a></li><li class="chapter-item "><a href="std/vec.html"><strong aria-hidden="true">22.3.</strong> Vec</a></li><li class="chapter-item "><a href="std/hashmap.html"><strong aria-hidden="true">22.4.</strong> HashMap</a></li><li class="chapter-item "><a href="std/box.html"><strong aria-hidden="true">22.5.</strong> Box</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="std/box-recursive.html"><strong aria-hidden="true">22.5.1.</strong> Recursive Data Types</a></li><li class="chapter-item "><a href="std/box-niche.html"><strong aria-hidden="true">22.5.2.</strong> Niche Optimization</a></li></ol></li><li class="chapter-item "><a href="std/rc.html"><strong aria-hidden="true">22.6.</strong> Rc</a></li></ol></li><li class="chapter-item "><a href="iterators.html"><strong aria-hidden="true">23.</strong> Iterators</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="iterators/motivation.html"><strong aria-hidden="true">23.1.</strong> Motivation</a></li><li class="chapter-item "><a href="iterators/iterator.html"><strong aria-hidden="true">23.2.</strong> Iterator Trait</a></li><li class="chapter-item "><a href="iterators/helpers.html"><strong aria-hidden="true">23.3.</strong> Helper Methods</a></li><li class="chapter-item "><a href="iterators/collect.html"><strong aria-hidden="true">23.4.</strong> collect</a></li><li class="chapter-item "><a href="iterators/intoiterator.html"><strong aria-hidden="true">23.5.</strong> IntoIterator</a></li></ol></li><li class="chapter-item "><a href="modules.html"><strong aria-hidden="true">24.</strong> Modules</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="modules/visibility.html"><strong aria-hidden="true">24.1.</strong> Visibility</a></li><li class="chapter-item "><a href="modules/paths.html"><strong aria-hidden="true">24.2.</strong> Paths</a></li><li class="chapter-item "><a href="modules/filesystem.html"><strong aria-hidden="true">24.3.</strong> Filesystem Hierarchy</a></li></ol></li><li class="chapter-item "><a href="exercises/course-4/afternoon.html"><strong aria-hidden="true">25.</strong> Exercises</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="exercises/course-4/luhn.html"><strong aria-hidden="true">25.1.</strong> Luhn Algorithm</a></li><li class="chapter-item "><a href="exercises/course-4/strings-iterators.html"><strong aria-hidden="true">25.2.</strong> Strings and Iterators</a></li><li class="chapter-item "><a href="exercises/course-4/iterator-chain.html"><strong aria-hidden="true">25.3.</strong> Iterator Method Chaining</a></li></ol></li><li class="chapter-item "><li class="part-title">Course 5</li><li class="spacer"></li><li class="chapter-item "><a href="course-5.html"><strong aria-hidden="true">26.</strong> Welcome</a></li><li class="chapter-item "><a href="traits.html"><strong aria-hidden="true">27.</strong> Traits</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="traits/deriving-traits.html"><strong aria-hidden="true">27.1.</strong> Deriving Traits</a></li><li class="chapter-item "><a href="traits/default-methods.html"><strong aria-hidden="true">27.2.</strong> Default Methods</a></li><li class="chapter-item "><a href="traits/important-traits.html"><strong aria-hidden="true">27.3.</strong> Important Traits</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="traits/iterator.html"><strong aria-hidden="true">27.3.1.</strong> Iterator</a></li><li class="chapter-item "><a href="traits/from-iterator.html"><strong aria-hidden="true">27.3.2.</strong> FromIterator</a></li><li class="chapter-item "><a href="traits/from-into.html"><strong aria-hidden="true">27.3.3.</strong> From and Into</a></li><li class="chapter-item "><a href="traits/read-write.html"><strong aria-hidden="true">27.3.4.</strong> Read and Write</a></li><li class="chapter-item "><a href="traits/operators.html"><strong aria-hidden="true">27.3.5.</strong> Add, Mul, ...</a></li><li class="chapter-item "><a href="traits/drop.html"><strong aria-hidden="true">27.3.6.</strong> Drop</a></li></ol></li></ol></li><li class="chapter-item "><a href="generics.html"><strong aria-hidden="true">28.</strong> Generics</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="generics/data-types.html"><strong aria-hidden="true">28.1.</strong> Generic Data Types</a></li><li class="chapter-item "><a href="generics/methods.html"><strong aria-hidden="true">28.2.</strong> Generic Methods</a></li><li class="chapter-item "><a href="generics/trait-bounds.html"><strong aria-hidden="true">28.3.</strong> Trait Bounds</a></li><li class="chapter-item "><a href="generics/impl-trait.html"><strong aria-hidden="true">28.4.</strong> impl Trait</a></li><li class="chapter-item "><a href="generics/monomorphization.html"><strong aria-hidden="true">28.5.</strong> Monomorphization</a></li></ol></li><li class="chapter-item "><a href="closures.html"><strong aria-hidden="true">29.</strong> Closures</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="closures/syntax.html"><strong aria-hidden="true">29.1.</strong> Syntax</a></li><li class="chapter-item "><a href="closures/capturing.html"><strong aria-hidden="true">29.2.</strong> Capturing</a></li><li class="chapter-item "><a href="closures/traits.html"><strong aria-hidden="true">29.3.</strong> Closure Traits</a></li><li class="chapter-item "><a href="generics/trait-objects.html"><strong aria-hidden="true">29.4.</strong> Trait Objects</a></li></ol></li><li class="chapter-item "><a href="exercises/course-5/morning.html"><strong aria-hidden="true">30.</strong> Exercises</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="exercises/course-5/simple-gui.html"><strong aria-hidden="true">30.1.</strong> A Simple GUI Library</a></li><li class="chapter-item "><a href="exercises/course-5/log-filter.html"><strong aria-hidden="true">30.2.</strong> Log Filter</a></li></ol></li><li class="chapter-item "><li class="part-title">Course 6</li><li class="spacer"></li><li class="chapter-item "><a href="course-6.html"><strong aria-hidden="true">31.</strong> Welcome</a></li><li class="chapter-item "><a href="error-handling.html"><strong aria-hidden="true">32.</strong> Error Handling</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="error-handling/panics.html"><strong aria-hidden="true">32.1.</strong> Panics</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="error-handling/panic-unwind.html"><strong aria-hidden="true">32.1.1.</strong> Catching Stack Unwinding</a></li></ol></li><li class="chapter-item "><a href="error-handling/result.html"><strong aria-hidden="true">32.2.</strong> Structured Error Handling</a></li><li class="chapter-item "><a href="error-handling/try-operator.html"><strong aria-hidden="true">32.3.</strong> Propagating Errors with ?</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="error-handling/converting-error-types.html"><strong aria-hidden="true">32.3.1.</strong> Converting Error Types</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="error-handling/converting-error-types-example.html"><strong aria-hidden="true">32.3.1.1.</strong> Example</a></li></ol></li><li class="chapter-item "><a href="error-handling/deriving-error-enums.html"><strong aria-hidden="true">32.3.2.</strong> Deriving Error Enums</a></li><li class="chapter-item "><a href="error-handling/dynamic-errors.html"><strong aria-hidden="true">32.3.3.</strong> Dynamic Error Types</a></li><li class="chapter-item "><a href="error-handling/error-contexts.html"><strong aria-hidden="true">32.3.4.</strong> Adding Context to Errors</a></li></ol></li></ol></li><li class="chapter-item "><a href="testing.html"><strong aria-hidden="true">33.</strong> Testing</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="testing/unit-tests.html"><strong aria-hidden="true">33.1.</strong> Unit Tests</a></li><li class="chapter-item "><a href="testing/test-modules.html"><strong aria-hidden="true">33.2.</strong> Test Modules</a></li><li class="chapter-item "><a href="testing/doc-tests.html"><strong aria-hidden="true">33.3.</strong> Documentation Tests</a></li><li class="chapter-item "><a href="testing/integration-tests.html"><strong aria-hidden="true">33.4.</strong> Integration Tests</a></li></ol></li><li class="chapter-item "><a href="unsafe.html"><strong aria-hidden="true">34.</strong> Unsafe Rust</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="unsafe/raw-pointers.html"><strong aria-hidden="true">34.1.</strong> Dereferencing Raw Pointers</a></li><li class="chapter-item "><a href="unsafe/mutable-static-variables.html"><strong aria-hidden="true">34.2.</strong> Mutable Static Variables</a></li><li class="chapter-item "><a href="unsafe/unions.html"><strong aria-hidden="true">34.3.</strong> Unions</a></li><li class="chapter-item "><a href="unsafe/calling-unsafe-functions.html"><strong aria-hidden="true">34.4.</strong> Calling Unsafe Functions</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="unsafe/writing-unsafe-functions.html"><strong aria-hidden="true">34.4.1.</strong> Writing Unsafe Functions</a></li><li class="chapter-item "><a href="unsafe/extern-functions.html"><strong aria-hidden="true">34.4.2.</strong> Extern Functions</a></li></ol></li><li class="chapter-item "><a href="unsafe/unsafe-traits.html"><strong aria-hidden="true">34.5.</strong> Implementing Unsafe Traits</a></li></ol></li><li class="chapter-item "><a href="exercises/course-6/afternoon.html"><strong aria-hidden="true">35.</strong> Exercises</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="exercises/course-6/safe-ffi-wrapper.html"><strong aria-hidden="true">35.1.</strong> Safe FFI Wrapper</a></li></ol></li><li class="chapter-item "><li class="part-title">Course 7</li><li class="spacer"></li><li class="chapter-item "><a href="course-7.html"><strong aria-hidden="true">36.</strong> Welcome</a></li><li class="chapter-item "><a href="concurrency.html"><strong aria-hidden="true">37.</strong> Concurrency</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="concurrency/threads.html"><strong aria-hidden="true">37.1.</strong> Threads</a></li><li class="chapter-item "><a href="concurrency/scoped-threads.html"><strong aria-hidden="true">37.2.</strong> Scoped Threads</a></li><li class="chapter-item "><a href="concurrency/channels.html"><strong aria-hidden="true">37.3.</strong> Channels</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="concurrency/channels/unbounded.html"><strong aria-hidden="true">37.3.1.</strong> Unbounded Channels</a></li><li class="chapter-item "><a href="concurrency/channels/bounded.html"><strong aria-hidden="true">37.3.2.</strong> Bounded Channels</a></li></ol></li><li class="chapter-item "><a href="concurrency/shared_state.html"><strong aria-hidden="true">37.4.</strong> Shared State</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="concurrency/shared_state/arc.html"><strong aria-hidden="true">37.4.1.</strong> Arc</a></li><li class="chapter-item "><a href="concurrency/shared_state/mutex.html"><strong aria-hidden="true">37.4.2.</strong> Mutex</a></li><li class="chapter-item "><a href="concurrency/shared_state/example.html"><strong aria-hidden="true">37.4.3.</strong> Example</a></li></ol></li><li class="chapter-item "><a href="concurrency/send-sync.html"><strong aria-hidden="true">37.5.</strong> Send and Sync</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="concurrency/send-sync/send.html"><strong aria-hidden="true">37.5.1.</strong> Send</a></li><li class="chapter-item "><a href="concurrency/send-sync/sync.html"><strong aria-hidden="true">37.5.2.</strong> Sync</a></li><li class="chapter-item "><a href="concurrency/send-sync/examples.html"><strong aria-hidden="true">37.5.3.</strong> Examples</a></li></ol></li></ol></li><li class="chapter-item "><a href="exercises/course-7/morning.html"><strong aria-hidden="true">38.</strong> Exercises</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="exercises/course-7/dining-philosophers.html"><strong aria-hidden="true">38.1.</strong> Dining Philosophers</a></li><li class="chapter-item "><a href="exercises/course-7/link-checker.html"><strong aria-hidden="true">38.2.</strong> Multi-threaded Link Checker</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust-LINFO2315</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/cpelsser/rust-mdbook" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="welcome-to-rust"><a class="header" href="#welcome-to-rust">Welcome to Rust</a></h1>
<h1 id="adapted-from-comprehensive-rust-"><a class="header" href="#adapted-from-comprehensive-rust-">(Adapted from Comprehensive Rust) ü¶Ä</a></h1>
<p>The goal of the course is to teach you Rust. We assume you don't know anything
about Rust and hope to:</p>
<ul>
<li>Give you a comprehensive understanding of the Rust syntax and language.</li>
<li>Enable you to modify existing programs</li>
<li>Write new programs in Rust for embedded systems</li>
<li>Show interoperability with C</li>
</ul>
<h2 id="assumptions"><a class="header" href="#assumptions">Assumptions</a></h2>
<p>The course assumes that you already know how to program. Rust is a statically
typed language and we will sometimes make comparisons with C and C++ to better
explain or contrast the Rust approach.</p>
<p>If you know how to program in a dynamically typed language such as Python or
JavaScript, then you will be able to follow along just fine too.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="course-structure"><a class="header" href="#course-structure">Course Structure</a></h1>
<p>The course is fast paced and covers a lot of ground:</p>
<ul>
<li>Course 1: Basic Rust.</li>
<li>Course 2: Ownership and the borrow checker.</li>
<li>Course 3: Compound data types,  pattern matching.</li>
<li>Course 4: The standard library.</li>
<li>Course 5: Traits and generics, error handling</li>
<li>Course 6: Testing, unsafe Rust.</li>
<li>Course 7: Concurrency in Rust and interoperability with other languages</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="keyboard-shortcuts"><a class="header" href="#keyboard-shortcuts">Keyboard Shortcuts</a></h1>
<p>There are several useful keyboard shortcuts in mdBook:</p>
<ul>
<li><kbd>Arrow-Left</kbd>: Navigate to the previous page.</li>
<li><kbd>Arrow-Right</kbd>: Navigate to the next page.</li>
<li><kbd>Ctrl + Enter</kbd>: Execute the code sample that has focus.</li>
<li><kbd>s</kbd>: Activate the search bar.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-cargo"><a class="header" href="#using-cargo">Using Cargo</a></h1>
<p>When you start reading about Rust, you will soon meet <a href="https://doc.rust-lang.org/cargo/">Cargo</a>, the standard tool
used in the Rust ecosystem to build and run Rust applications. Here we want to
give a brief overview of what Cargo is and how it fits into the wider ecosystem
and how it fits into this training.</p>
<h2 id="installation"><a class="header" href="#installation">Installation</a></h2>
<h3 id="rustup-recommended"><a class="header" href="#rustup-recommended">Rustup (Recommended)</a></h3>
<p>You can follow the instructions to install cargo and rust compiler, among other standard ecosystem tools with the <a href="https://rustup.rs/">rustup</a> tool, which is maintained by the Rust Foundation.</p>
<p>Along with cargo and rustc, Rustup will install itself as a command line utility that you can use to install/switch toolchains, setup cross compilation, etc.</p>
<h3 id="package-managers"><a class="header" href="#package-managers">Package Managers</a></h3>
<h4 id="debian"><a class="header" href="#debian">Debian</a></h4>
<p>On Debian/Ubuntu, you can install Cargo, the Rust source and the <a href="https://github.com/rust-lang/rustfmt">Rust formatter</a> with</p>
<pre><code class="language-shell">$ sudo apt install cargo rust-src rustfmt
</code></pre>
<p>This will allow <a href="https://rust-analyzer.github.io/">rust-analyzer</a> to jump to the definitions. We suggest using
<a href="https://code.visualstudio.com/">VS Code</a> to edit the code (but any LSP compatible editor works).</p>
<p>Some folks also like to use the <a href="https://www.jetbrains.com/clion/">JetBrains</a> family of IDEs, which do their own analysis but have their own tradeoffs. If you prefer them, you can install the <a href="https://www.jetbrains.com/rust/">Rust Plugin</a>. Please take note that as of January 2023 debugging only works on the CLion version of the JetBrains IDEA suite.</p>
<details>
<p><strong>Key points for speakers:</strong></p>
<ul>
<li>Cargo is Rust's build system AND package manager (like npm + webpack for JS, or Maven for Java).</li>
<li><code>rustup</code> manages Rust versions; <code>cargo</code> manages project dependencies and builds.</li>
<li>Most students should use <code>rustup</code> for installation as it's the official method.</li>
</ul>
<p><strong>Common student questions:</strong></p>
<ul>
<li><em>&quot;Why not just use apt/brew?&quot;</em> - System packages are often outdated. Rustup gives you the latest stable, beta, or nightly.</li>
<li><em>&quot;What's rust-analyzer?&quot;</em> - It's the language server that provides IDE features (autocomplete, go-to-definition, etc.).</li>
<li><em>&quot;Do I need an IDE?&quot;</em> - No, but rust-analyzer + VS Code or similar makes learning much easier.</li>
</ul>
<p><strong>Demo suggestions:</strong></p>
<ul>
<li>Show <code>rustup --version</code> and <code>cargo --version</code></li>
<li>Create a new project with <code>cargo new hello</code> and explore the generated files</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-rust-ecosystem"><a class="header" href="#the-rust-ecosystem">The Rust Ecosystem</a></h1>
<p>The Rust ecosystem consists of a number of tools, of which the main ones are:</p>
<ul>
<li>
<p><code>rustc</code>: the Rust compiler which turns <code>.rs</code> files into binaries and other
intermediate formats.</p>
</li>
<li>
<p><code>cargo</code>: the Rust dependency manager and build tool. Cargo knows how to
download dependencies hosted on <a href="https://crates.io">https://crates.io</a> and it will pass them to
<code>rustc</code> when building your project. Cargo also comes with a built-in test
runner which is used to execute unit tests.</p>
</li>
<li>
<p><code>rustup</code>: the Rust toolchain installer and updater. This tool is used to
install and update <code>rustc</code> and <code>cargo</code> when new versions of Rust is released.
In addition, <code>rustup</code> can also download documentation for the standard
library. You can have multiple versions of Rust installed at once and <code>rustup</code>
will let you switch between them as needed.</p>
</li>
</ul>
<details>
<p>Key points:</p>
<ul>
<li>
<p>Rust has a rapid release schedule with a new release coming out
every six weeks. New releases maintain backwards compatibility with
old releases --- plus they enable new functionality.</p>
</li>
<li>
<p>There are three release channels: &quot;stable&quot;, &quot;beta&quot;, and &quot;nightly&quot;.</p>
</li>
<li>
<p>New features are being tested on &quot;nightly&quot;, &quot;beta&quot; is what becomes
&quot;stable&quot; every six weeks.</p>
</li>
<li>
<p>Rust also has <a href="https://doc.rust-lang.org/edition-guide/">editions</a>: the current edition is Rust 2021. Previous
editions were Rust 2015 and Rust 2018.</p>
<ul>
<li>
<p>The editions are allowed to make backwards incompatible changes to
the language.</p>
</li>
<li>
<p>To prevent breaking code, editions are opt-in: you select the
edition for your crate via the <code>Cargo.toml</code> file.</p>
</li>
<li>
<p>To avoid splitting the ecosystem, Rust compilers can mix code
written for different editions.</p>
</li>
<li>
<p>Mention that it is quite rare to ever use the compiler directly not through <code>cargo</code> (most users never do).</p>
</li>
<li>
<p>It might be worth alluding that Cargo itself is an extremely powerful and comprehensive tool.  It is capable of many advanced features including but not limited to:</p>
<ul>
<li>Project/package structure</li>
<li><a href="https://doc.rust-lang.org/cargo/reference/workspaces.html">workspaces</a></li>
<li>Dev Dependencies and Runtime Dependency management/caching</li>
<li><a href="https://doc.rust-lang.org/cargo/reference/build-scripts.html">build scripting</a></li>
<li><a href="https://doc.rust-lang.org/cargo/commands/cargo-install.html">global installation</a></li>
<li>It is also extensible with sub command plugins as well (such as <a href="https://github.com/rust-lang/rust-clippy">cargo clippy</a>).</li>
</ul>
</li>
<li>
<p>Read more from the <a href="https://doc.rust-lang.org/cargo/">official Cargo Book</a></p>
</li>
</ul>
</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="code-samples-in-this-training"><a class="header" href="#code-samples-in-this-training">Code Samples in This Training</a></h1>
<p>For this training, we will mostly explore the Rust language through examples
which can be executed through your browser. This makes the setup much easier and
ensures a consistent experience for everyone.</p>
<p>Installing Cargo is still encouraged: it will make it easier for you to do the
exercises. On the last day, we will do a larger exercise which shows you how to
work with dependencies and for that you need Cargo.</p>
<p>The code blocks in this course are fully interactive:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    println!(&quot;Edit me!&quot;);
}
</code></pre></pre>
<p>You can use <kbd>Ctrl + Enter</kbd> to execute the code when focus is in the
text box.</p>
<details>
<p>Most code samples are editable like shown above. A few code samples
are not editable for various reasons:</p>
<ul>
<li>
<p>The embedded playgrounds cannot execute unit tests. Copy-paste the
code and open it in the real Playground to demonstrate unit tests.</p>
</li>
<li>
<p>The embedded playgrounds lose their state the moment you navigate
away from the page! This is the reason that the students should
solve the exercises using a local Rust installation or via the
Playground.</p>
</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="running-code-locally-with-cargo"><a class="header" href="#running-code-locally-with-cargo">Running Code Locally with Cargo</a></h1>
<p>If you want to experiment with the code on your own system, then you will need
to first install Rust. Do this by following the <a href="https://doc.rust-lang.org/book/ch01-01-installation.html">instructions in the Rust
Book</a>. This should give you a working <code>rustc</code> and <code>cargo</code>. At the time of
writing, the latest stable Rust release has these version numbers:</p>
<pre><code class="language-shell">% rustc --version
rustc 1.61.0 (fe5b13d68 2022-05-18)
% cargo --version
cargo 1.61.0 (a028ae4 2022-04-29)
</code></pre>
<p>With this is in place, then follow these steps to build a Rust binary from one
of the examples in this training:</p>
<ol>
<li>
<p>Click the &quot;Copy to clipboard&quot; button on the example you want to copy.</p>
</li>
<li>
<p>Use <code>cargo new exercise</code> to create a new <code>exercise/</code> directory for your code:</p>
<pre><code class="language-shell">$ cargo new exercise
     Created binary (application) `exercise` package
</code></pre>
</li>
<li>
<p>Navigate into <code>exercise/</code> and use <code>cargo run</code> to build and run your binary:</p>
<pre><code class="language-shell">$ cd exercise
$ cargo run
   Compiling exercise v0.1.0 (/home/mgeisler/tmp/exercise)
    Finished dev [unoptimized + debuginfo] target(s) in 0.75s
     Running `target/debug/exercise`
Hello, world!
</code></pre>
</li>
<li>
<p>Replace the boiler-plate code in <code>src/main.rs</code> with your own code. For
example, using the example on the previous page, make <code>src/main.rs</code> look like</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    println!(&quot;Edit me!&quot;);
}
</code></pre></pre>
</li>
<li>
<p>Use <code>cargo run</code> to build and run your updated binary:</p>
<pre><code class="language-shell">$ cargo run
   Compiling exercise v0.1.0 (/home/mgeisler/tmp/exercise)
    Finished dev [unoptimized + debuginfo] target(s) in 0.24s
     Running `target/debug/exercise`
Edit me!
</code></pre>
</li>
<li>
<p>Use <code>cargo check</code> to quickly check your project for errors, use <code>cargo build</code>
to compile it without running it. You will find the output in <code>target/debug/</code>
for a normal debug build. Use <code>cargo build --release</code> to produce an optimized
release build in <code>target/release/</code>.</p>
</li>
<li>
<p>You can add dependencies for your project by editing <code>Cargo.toml</code>. When you
run <code>cargo</code> commands, it will automatically download and compile missing
dependencies for you.</p>
</li>
</ol>
<details>
<p>Try to encourage the class participants to install Cargo and use a
local editor. It will make their life easier since they will have a
normal development environment.</p>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="welcome-to-course-1"><a class="header" href="#welcome-to-course-1">Welcome to course 1</a></h1>
<p>In this first session we will cover:</p>
<ul>
<li>Basic Rust syntax: variables, scalar and compound types, enums, structs,
references, functions, and methods.</li>
</ul>
<!-- * Memory management: stack vs heap, manual memory management, scope-based memory
  management, and garbage collection.

* Ownership: move semantics, copying and cloning, borrowing, and lifetimes.
 -->
<!-- <details>

Please remind the students that:

* They should ask questions when they get them, don't save them to the end.
* The class is meant to be interactive and discussions are very much encouraged!
  * As an instructor, you should try to keep the discussions relevant, i.e.,
    keep the related to how Rust does things vs some other language. It can be
    hard to find the right balance, but err on the side of allowing discussions
    since they engage people much more than one-way communication.
* The questions will likely mean that we about things ahead of the slides.
  * This is perfectly okay! Repetition is an important part of learning. Remember
    that the slides are just a support and you are free to skip them as you
    like.

The idea for the first day is to show _just enough_ of Rust to be able to speak
about the famous borrow checker. The way Rust handles memory is a major feature
and we should show students this right away.

If you're teaching this in a classroom, this is a good place to go over the
schedule. We suggest splitting the day into two parts (following the slides):

* Morning: 9:00 to 12:00,
* Afternoon: 13:00 to 16:00.

You can of course adjust this as necessary. Please make sure to include breaks,
we recommend a break every hour!

</details>
 --><div style="break-before: page; page-break-before: always;"></div><h1 id="what-is-rust"><a class="header" href="#what-is-rust">What is Rust?</a></h1>
<p>Rust is a new programming language which had its <a href="https://blog.rust-lang.org/2015/05/15/Rust-1.0.html">1.0 release in 2015</a>:</p>
<ul>
<li>Rust is a statically compiled language in a similar role as C++
<ul>
<li><code>rustc</code> uses LLVM as its backend.</li>
</ul>
</li>
<li>Rust supports many <a href="https://doc.rust-lang.org/nightly/rustc/platform-support.html">platforms and
architectures</a>:
<ul>
<li>x86, ARM, WebAssembly, ...</li>
<li>Linux, Mac, Windows, ...</li>
</ul>
</li>
<li>Rust is used for a wide range of devices:
<ul>
<li>firmware and boot loaders,</li>
<li>smart displays,</li>
<li>mobile phones,</li>
<li>desktops,</li>
<li>servers.</li>
</ul>
</li>
</ul>
<details>
<p>Rust fits in the same area as C++:</p>
<ul>
<li>High flexibility.</li>
<li>High level of control.</li>
<li>Can be scaled down to very constrained devices like mobile phones.</li>
<li>Has no runtime or garbage collection.</li>
<li>Focuses on reliability and safety without sacrificing performance.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hello-world"><a class="header" href="#hello-world">Hello World!</a></h1>
<p>Let us jump into the simplest possible Rust program, a classic Hello World
program:</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    println!(&quot;Hello üåç!&quot;);
}
</code></pre></pre>
<p>What you see:</p>
<ul>
<li>Functions are introduced with <code>fn</code>.</li>
<li>Blocks are delimited by curly braces like in C and C++.</li>
<li>The <code>main</code> function is the entry point of the program.</li>
<li>Rust has hygienic macros, <code>println!</code> is an example of this.</li>
<li>Rust strings are UTF-8 encoded and can contain any Unicode character.</li>
</ul>
<details>
<p>This slide tries to make the students comfortable with Rust code. They will see
a ton of it over the next four days so we start small with something familiar.</p>
<p>Key points:</p>
<ul>
<li>
<p>Rust is very much like other languages in the C/C++/Java tradition. It is
imperative (not functional) and it doesn't try to reinvent things unless
absolutely necessary.</p>
</li>
<li>
<p>Rust is modern with full support for things like Unicode.</p>
</li>
<li>
<p>Rust uses macros for situations where you want to have a variable number of
arguments (no function <a href="basic-syntax/functions-interlude.html">overloading</a>).</p>
</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="small-example"><a class="header" href="#small-example">Small Example</a></h1>
<p>Here is a small example program in Rust:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {              // Program entry point
    let mut x: i32 = 6;  // Mutable variable binding
    print!(&quot;{x}&quot;);       // Macro for printing, like printf
    while x != 1 {       // No parenthesis around expression
        if x % 2 == 0 {  // Math like in other languages
            x = x / 2;
        } else {
            x = 3 * x + 1;
        }
        print!(&quot; -&gt; {x}&quot;);
    }
    println!();
}
</code></pre></pre>
<details>
<p>The code implements the Collatz conjecture: it is believed that the loop will
always end, but this is not yet proved. Edit the code and play with different
inputs.</p>
<p>Key points:</p>
<ul>
<li>
<p>Explain that all variables are statically typed. Try removing <code>i32</code> to trigger
type inference. Try with <code>i8</code> instead and trigger a runtime integer overflow.</p>
</li>
<li>
<p>Change <code>let mut x</code> to <code>let x</code>, discuss the compiler error.</p>
</li>
<li>
<p>Show how <code>print!</code> gives a compilation error if the arguments don't match the
format string.</p>
</li>
<li>
<p>Show how you need to use <code>{}</code> as a placeholder if you want to print an
expression which is more complex than just a single variable.</p>
</li>
<li>
<p>Show the students the standard library, show them how to search for <code>std::fmt</code>
which has the rules of the formatting mini-language. It's important that the
students become familiar with searching in the standard library.</p>
</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="why-rust"><a class="header" href="#why-rust">Why Rust?</a></h1>
<p>Some unique selling points of Rust:</p>
<ul>
<li>Compile time memory safety.</li>
<li>Lack of undefined runtime behavior.</li>
<li>Modern language features.</li>
</ul>
<details>
<p>Make sure to ask the class which languages they have experience with. Depending
on the answer you can highlight different features of Rust:</p>
<ul>
<li>
<p>Experience with C or C++: Rust eliminates a whole class of <em>runtime errors</em>
via the borrow checker. You get performance like in C and C++, but you don't
have the memory unsafety issues. In addition, you get a modern language with
constructs like pattern matching and built-in dependency management.</p>
</li>
<li>
<p>Experience with Java, Go, Python, JavaScript...: You get the same memory safety
as in those languages, plus a similar high-level language feeling. In addition
you get fast and predictable performance like C and C++ (no garbage collector)
as well as access to low-level hardware (should you need it)</p>
</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="compile-time-guarantees"><a class="header" href="#compile-time-guarantees">Compile Time Guarantees</a></h1>
<p>Static memory management at compile time:</p>
<ul>
<li>No uninitialized variables.</li>
<li>No memory leaks (<em>mostly</em>, see notes).</li>
<li>No double-frees.</li>
<li>No use-after-free.</li>
<li>No <code>NULL</code> pointers.</li>
<li>No forgotten locked mutexes.</li>
<li>No data races between threads.</li>
<li>No iterator invalidation.</li>
</ul>
<p>For the purpose of this course, &quot;No memory leaks&quot; should be understood
as &quot;Pretty much no <em>accidental</em> memory leaks&quot;.</p>
<details>
<p>It is possible to produce memory leaks in (safe) Rust. Some examples
are:</p>
<ul>
<li>You can for example use <a href="https://doc.rust-lang.org/std/boxed/struct.Box.html#method.leak"><code>Box::leak</code></a> to leak a pointer. A use of this could
be to get runtime-initialized and runtime-sized static variables</li>
<li>You can use <a href="https://doc.rust-lang.org/std/mem/fn.forget.html"><code>std::mem::forget</code></a> to make the compiler &quot;forget&quot; about
a value (meaning the destructor is never run).</li>
<li>You can also accidentally create a <a href="https://doc.rust-lang.org/book/ch15-06-reference-cycles.html">reference cycle</a> with <code>Rc</code> or
<code>Arc</code>.</li>
<li>In fact, some will consider infinitely populating a collection a memory
leak and Rust does not protect from those.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="runtime-guarantees"><a class="header" href="#runtime-guarantees">Runtime Guarantees</a></h1>
<p>No undefined behavior at runtime:</p>
<ul>
<li>Array access is bounds checked.</li>
<li>Integer overflow is defined.</li>
</ul>
<details>
<p>Key points:</p>
<ul>
<li>
<p>Integer overflow is defined via a compile-time flag. The options are
either a panic (a controlled crash of the program) or wrap-around
semantics. By default, you get panics in debug mode (<code>cargo build</code>)
and wrap-around in release mode (<code>cargo build --release</code>).</p>
</li>
<li>
<p>Bounds checking cannot be disabled with a compiler flag. It can also
not be disabled directly with the <code>unsafe</code> keyword. However,
<code>unsafe</code> allows you to call functions such as <code>slice::get_unchecked</code>
which does not do bounds checking.</p>
</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="modern-features"><a class="header" href="#modern-features">Modern Features</a></h1>
<p>Rust is built with all the experience gained in the last 40 years.</p>
<!-- ## Language Features

* Enums and pattern matching.
* Generics.
* No overhead FFI (Foreign Function Interface).
* Zero-cost abstractions. -->
<h2 id="tooling"><a class="header" href="#tooling">Tooling</a></h2>
<ul>
<li>Great compiler errors.</li>
<li>Built-in dependency manager.</li>
<li>Built-in support for testing.</li>
<li>Excellent Language Server Protocol support.</li>
</ul>
<details>
<p>Key points:</p>
<!-- * Zero-cost abstractions, similar to C++, means that you don't have to 'pay'
  for higher-level programming constructs with memory or CPU. For example,
  writing a loop using `for` should result in roughly the same low level
  instructions as using the `.iter().fold()` construct.

* It may be worth mentioning that Rust enums are 'Algebraic Data Types', also
  known as 'sum types', which allow the type system to express things like
  `Option<T>` and `Result<T, E>`. -->
<ul>
<li>
<p>Remind people to read the errors --- many developers have gotten used to
ignore lengthy compiler output. The Rust compiler is significantly more
talkative than other compilers. It will often provide you with <em>actionable</em>
feedback, ready to copy-paste into your code.</p>
</li>
<li>
<p>The Rust standard library is small compared to languages like Java, Python,
and Go. Rust does not come with several things you might consider standard and
essential:</p>
<ul>
<li>a random number generator, but see <a href="https://docs.rs/rand/">rand</a>.</li>
<li>support for SSL or TLS, but see <a href="https://docs.rs/rustls/">rusttls</a>.</li>
<li>support for JSON, but see <a href="https://docs.rs/serde_json/">serde_json</a>.
The reasoning behind this is that functionality in the standard library cannot
go away, so it has to be very stable. For the examples above, the Rust
community is still working on finding the best solution --- and perhaps there
isn't a single &quot;best solution&quot; for some of these things.</li>
</ul>
<p>Rust comes with a built-in package manager in the form of Cargo and this makes
it trivial to download and compile third-party crates. A consequence of this
is that the standard library can be smaller.</p>
<p>Discovering good third-party crates can be a problem. Sites like
<a href="https://lib.rs/">https://lib.rs/</a> help with this by letting you compare health metrics for
crates to find a good and trusted one.</p>
</li>
<li>
<p><a href="https://rust-analyzer.github.io/">rust-analyzer</a> is a well supported LSP implementation used in major
IDEs and text editors.</p>
</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="basic-syntax"><a class="header" href="#basic-syntax">Basic Syntax</a></h1>
<p>Much of the Rust syntax will be familiar to you from C, C++ or Java:</p>
<ul>
<li>Blocks and scopes are delimited by curly braces.</li>
<li>Line comments are started with <code>//</code>, block comments are delimited by <code>/* ... */</code>.</li>
<li>Keywords like <code>if</code> and <code>while</code> work the same.</li>
<li>Variable assignment is done with <code>=</code>, comparison is done with <code>==</code>.</li>
</ul>
<details>
<ul>
<li>Rust uses <code>let</code> for variable declarations, not a type name.</li>
<li>Variables are immutable by default; use <code>let mut</code> for mutable variables.</li>
<li>Rust has strong type inference, so you often don't need type annotations.</li>
<li>Semicolons are required at the end of statements but not expressions.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="if-expressions"><a class="header" href="#if-expressions">If expressions</a></h1>
<p>You use
<a href="https://doc.rust-lang.org/reference/expressions/if-expr.html#if-expressions"><code>if</code> expressions</a>
exactly like <code>if</code> statements in other languages:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let x = 10;
    if x &lt; 20 {
        println!(&quot;small&quot;);
    } else if x &lt; 100 {
        println!(&quot;biggish&quot;);
    } else {
        println!(&quot;huge&quot;);
    }
}
</code></pre></pre>
<p>In addition, you can use <code>if</code> as an expression. The last expression of each
block becomes the value of the <code>if</code> expression:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let x = 10;
    let size = if x &lt; 20 { &quot;small&quot; } else { &quot;large&quot; };
    println!(&quot;number size: {}&quot;, size);
}
</code></pre></pre>
<details>
<p>Because <code>if</code> is an expression and must have a particular type, both of its
branch blocks must have the same type. Show what happens if you add <code>;</code> after
<code>&quot;small&quot;</code> in the second example.</p>
<p>When <code>if</code> is used in an expression, the expression must have a <code>;</code> to separate
it from the next statement. Remove the <code>;</code> before <code>println!</code> to see the compiler
error.</p>
</details><div style="break-before: page; page-break-before: always;"></div><h1 id="scalar-types"><a class="header" href="#scalar-types">Scalar Types</a></h1>
<div class="table-wrapper"><table><thead><tr><th></th><th>Types</th><th>Literals</th></tr></thead><tbody>
<tr><td>Signed integers</td><td><code>i8</code>, <code>i16</code>, <code>i32</code>, <code>i64</code>, <code>i128</code>, <code>isize</code></td><td><code>-10</code>, <code>0</code>, <code>1_000</code>, <code>123i64</code></td></tr>
<tr><td>Unsigned integers</td><td><code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code>, <code>u128</code>, <code>usize</code></td><td><code>0</code>, <code>123</code>, <code>10u16</code></td></tr>
<tr><td>Floating point numbers</td><td><code>f32</code>, <code>f64</code></td><td><code>3.14</code>, <code>-10.0e20</code>, <code>2f32</code></td></tr>
<tr><td>Strings</td><td><code>&amp;str</code></td><td><code>&quot;foo&quot;</code>, <code>r#&quot;\\&quot;#</code></td></tr>
<tr><td>Unicode scalar values</td><td><code>char</code></td><td><code>'a'</code>, <code>'Œ±'</code>, <code>'‚àû'</code></td></tr>
<tr><td>Byte strings</td><td><code>&amp;[u8]</code></td><td><code>b&quot;abc&quot;</code>, <code>br#&quot; &quot; &quot;#</code></td></tr>
<tr><td>Booleans</td><td><code>bool</code></td><td><code>true</code>, <code>false</code></td></tr>
</tbody></table>
</div>
<p>The types have widths as follows:</p>
<ul>
<li><code>iN</code>, <code>uN</code>, and <code>fN</code> are <em>N</em> bits wide,</li>
<li><code>isize</code> and <code>usize</code> are the width of a pointer,</li>
<li><code>char</code> is 32 bit wide,</li>
<li><code>bool</code> is 8 bit wide.</li>
</ul>
<details>
<p><code>r</code> is used to denote raw string literals. Raw string literals do not process any escapes.
It is followed by <code>(#)+</code>, then <code>&quot;</code>, the litteral, <code>&quot;</code> and <code>(#)+</code>, where <code>+</code> means one or more occurences.</p>
<p><code>r#&quot;&quot;foo&quot;&quot;#</code> stands for <code>&quot;foo&quot;</code>.</p>
<p><code>r##&quot;foo #&quot;# bar&quot;##</code> stands for <code>foo #&quot;# bar</code>.
Each character in a raw string literal is represented as a Unicode scalar value.
<code>r#&quot;Hello, &quot;Rust&quot;!&quot;#</code> is a string that includes the characters <code>H, e, l, l, o, ,, , &quot;, R, u, s, t, &quot;, !</code>.</p>
<p><code>b#&quot;...&quot;#</code> denotes a byte string, ie a sequence of bytes.
<code>b&quot;hello&quot;</code> is equivalent to <code>[104, 101, 108, 108, 111]</code> (ASCII values for 'h', 'e', 'l', 'l', 'o').</p>
<p><code>br#&quot;...&quot;#</code> is for a raw byte string.</p>
</details><div style="break-before: page; page-break-before: always;"></div><h1 id="compound-types"><a class="header" href="#compound-types">Compound Types</a></h1>
<div class="table-wrapper"><table><thead><tr><th></th><th>Types</th><th>Literals</th></tr></thead><tbody>
<tr><td>Arrays</td><td><code>[T; N]</code></td><td><code>[20, 30, 40]</code>, <code>[0; 3]</code></td></tr>
<tr><td>Tuples</td><td><code>()</code>, <code>(T,)</code>, <code>(T1, T2)</code>, ...</td><td><code>()</code>, <code>('x',)</code>, <code>('x', 1.2)</code>, ...</td></tr>
</tbody></table>
</div>
<p>Array assignment and access:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let mut a: [i8; 10] = [42; 10];
    a[5] = 0;
    println!(&quot;a: {:?}&quot;, a);
}
</code></pre></pre>
<p>Tuple assignment and access:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let t: (i8, bool) = (7, true);
    println!(&quot;1st index: {}&quot;, t.0);
    println!(&quot;2nd index: {}&quot;, t.1);
}
</code></pre></pre>
<details>
<p>Key points:</p>
<p>Arrays:</p>
<ul>
<li>
<p>Arrays have elements of the same type, <code>T</code>, and length, <code>N</code>, which is a compile-time constant.
Note that the length of the array is <em>part of its type</em>, which means that <code>[u8; 3]</code> and
<code>[u8; 4]</code> are considered two different types.</p>
</li>
<li>
<p>We can use literals to assign values to arrays.</p>
</li>
<li>
<p>In the main function, the print statement asks for the debug implementation with the <code>?</code> format
parameter: <code>{}</code> gives the default output, <code>{:?}</code> gives the debug output. We
could also have used <code>{a}</code> and <code>{a:?}</code> without specifying the value after the
format string.</p>
</li>
<li>
<p>Adding <code>#</code>, eg <code>{a:#?}</code>, invokes a &quot;pretty printing&quot; format, which can be easier to read.</p>
</li>
</ul>
<p>Tuples:</p>
<ul>
<li>
<p>Like arrays, tuples have a fixed length.</p>
</li>
<li>
<p>Tuples group together values of different types into a compound type.</p>
</li>
<li>
<p>Fields of a tuple can be accessed by the period and the index of the value, e.g. <code>t.0</code>, <code>t.1</code>.</p>
</li>
<li>
<p>The empty tuple <code>()</code> is also known as the &quot;unit type&quot;. It is both a type, and
the only valid value of that type - that is to say both the type and its value
are expressed as <code>()</code>. It is used to indicate, for example, that a function or
expression has no return value, as we'll see in a future slide.</p>
<ul>
<li>You can think of it as <code>void</code> that can be familiar to you from other
programming languages.</li>
</ul>
</li>
</ul>
<p>T is a generic type</p>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="references"><a class="header" href="#references">References</a></h1>
<p>Like C++, Rust has references:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let mut x: i32 = 10;
    let ref_x: &amp;mut i32 = &amp;mut x;
    *ref_x = 20;
    println!(&quot;x: {x}&quot;);
}
</code></pre></pre>
<p>Some notes:</p>
<ul>
<li>We must dereference <code>ref_x</code> when assigning to it, similar to C and C++ pointers.</li>
<li>Rust will auto-dereference in some cases, in particular when invoking
methods (try <code>ref_x.count_ones()</code>).</li>
<li>References that are declared as <code>mut</code> can be bound to different values over their lifetime.</li>
</ul>
<details>
Key points:
<ul>
<li>Be sure to note the difference between <code>let mut ref_x: &amp;i32</code> and <code>let ref_x: &amp;mut i32</code>. The first one represents a mutable reference which can be bound to
different values, while the second represents a reference to a mutable value.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dangling-references"><a class="header" href="#dangling-references">Dangling References</a></h1>
<p>Rust will statically forbid dangling references:</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail edition2021">fn main() {
    let ref_x: &amp;i32;
    {
        let x: i32 = 10;
        ref_x = &amp;x;
    }
    println!(&quot;ref_x: {ref_x}&quot;);
}
</code></pre></pre>
<ul>
<li>A reference is said to &quot;borrow&quot; the value it refers to.</li>
<li>Rust is tracking the lifetimes of all references to ensure they live long
enough.</li>
<li>We will talk more about borrowing when we get to ownership.</li>
</ul>
<details>
<p><strong>Key points for speakers:</strong></p>
<ul>
<li>This is a compile-time error, not a runtime crash. Rust prevents the bug before the program runs.</li>
<li>In C/C++, this code would compile and cause undefined behavior (use-after-free).</li>
<li>The inner <code>x</code> is dropped when its scope ends (at the <code>}</code>), but <code>ref_x</code> still tries to reference it.</li>
</ul>
<p><strong>Common student questions:</strong></p>
<ul>
<li><em>&quot;Why can't Rust just extend the lifetime of x?&quot;</em> - Because <code>x</code> is stack-allocated and must be freed when its scope ends. Extending it would require heap allocation.</li>
<li><em>&quot;How does Rust know this is wrong?&quot;</em> - The borrow checker tracks lifetimes. It sees that <code>ref_x</code> has a longer lifetime than <code>x</code>.</li>
<li><em>&quot;What if I need the value to live longer?&quot;</em> - Use <code>Clone</code> to copy the value, or allocate on the heap with <code>Box</code>.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="slices"><a class="header" href="#slices">Slices</a></h1>
<p>A slice gives you a view into a larger collection:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let a: [i32; 6] = [10, 20, 30, 40, 50, 60];
    println!(&quot;a: {a:?}&quot;);

    let s: &amp;[i32] = &amp;a[2..4];
    println!(&quot;s: {s:?}&quot;);
}
</code></pre></pre>
<ul>
<li>Slices borrow data from the sliced type.</li>
<li>Question: What happens if you modify <code>a[3]</code>?</li>
</ul>
<details>
<ul>
<li>
<p>We create a slice by borrowing <code>a</code> and specifying the starting and ending indexes in brackets.</p>
</li>
<li>
<p>If the slice starts at index 0, Rust‚Äôs range syntax allows us to drop the starting index, meaning that <code>&amp;a[0..a.len()]</code> and <code>&amp;a[..a.len()]</code> are identical.</p>
</li>
<li>
<p>The same is true for the last index, so <code>&amp;a[2..a.len()]</code> and <code>&amp;a[2..]</code> are identical.</p>
</li>
<li>
<p>To easily create a slice of the full array, we can therefore use <code>&amp;a[..]</code>.</p>
</li>
<li>
<p><code>s</code> is a reference to a slice of <code>i32</code>s. Notice that the type of <code>s</code> (<code>&amp;[i32]</code>) no longer mentions the array length. This allows us to perform computation on slices of different sizes.</p>
</li>
<li>
<p>Slices always borrow from another object. In this example, <code>a</code> has to remain 'alive' (in scope) for at least as long as our slice.</p>
</li>
<li>
<p>The question about modifying <code>a[3]</code> can spark an interesting discussion, but the answer is that for memory safety reasons
you cannot do it through <code>a</code> after you created a slice, but you can read the data from both <code>a</code> and <code>s</code> safely.
More details will be explained in the borrow checker section.</p>
<pre><code>// We cannot change a[3] after it has been borrowed by s.
fn main() {
  let mut a: [i32; 6] = [10, 20, 30, 40, 50, 60];
  println!(&quot;a: {a:?}&quot;);

  let s: &amp;mut [i32] = &amp;mut a[2..4];
  s[0] = 1;
  println!(&quot;s: {s:?}&quot;);
}

// but we can still read the content of a
fn main() {
  let mut a: [i32; 6] = [10, 20, 30, 40, 50, 60];
  println!(&quot;a: {a:?}&quot;);

  let s: &amp;mut [i32] = &amp;mut a[2..4];
  s[0] = 1;
  println!(&quot;a: {a:?}&quot;);
}
</code></pre>
</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="string-vs-str"><a class="header" href="#string-vs-str"><code>String</code> vs <code>str</code></a></h1>
<p>We can now understand the two string types in Rust:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let s1: &amp;str = &quot;World&quot;;
    println!(&quot;s1: {s1}&quot;);

    let mut s2: String = String::from(&quot;Hello &quot;);
    println!(&quot;s2: {s2}&quot;);
    s2.push_str(s1);
    println!(&quot;s2: {s2}&quot;);
    
    let s3: &amp;str = &amp;s2[6..];
    println!(&quot;s3: {s3}&quot;);
}
</code></pre></pre>
<p>Rust terminology:</p>
<ul>
<li><code>&amp;str</code> an immutable reference to a string slice.</li>
<li><code>String</code> a mutable string buffer.</li>
</ul>
<details>
<ul>
<li>
<p><code>&amp;str</code> introduces a string slice, which is an immutable reference to UTF-8 encoded string data
stored in a block of memory. String literals (<code>‚ÄùHello‚Äù</code>), are stored in the program‚Äôs binary.</p>
</li>
<li>
<p>Rust‚Äôs <code>String</code> type is a wrapper around a vector of bytes. As with a <code>Vec&lt;T&gt;</code>, it is owned.
<code>Vec&lt;T&gt;</code> is an array that changes size dynamically.</p>
</li>
<li>
<p>As with many other types <code>String::from()</code> creates a string from a string literal; <code>String::new()</code>
creates a new empty string, to which string data can be added using the <code>push()</code> and <code>push_str()</code> methods.</p>
</li>
<li>
<p>The <code>format!()</code> macro is a convenient way to generate an owned string from dynamic values. It
accepts the same format specification as <code>println!()</code>.</p>
</li>
<li>
<p>You can borrow <code>&amp;str</code> slices from <code>String</code> via <code>&amp;</code> and optionally range selection.</p>
</li>
<li>
<p>For C++ programmers: think of <code>&amp;str</code> as <code>const char*</code> from C++, but the one that always points
to a valid string in memory. Rust <code>String</code> is a rough equivalent of <code>std::string</code> from C++
(main difference: it can only contain UTF-8 encoded bytes and will never use a small-string optimization).</p>
</li>
<li>
<p>How do I modify s1? Here is an example built by iteratively following the guidelines of the compiler.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let mut s1: &amp;str = &quot;World&quot;;
    println!(&quot;s1: {s1}&quot;);
    let binding  = &amp;(s1.to_owned() + &quot; hobbit&quot;);
    s1 = &amp;binding;

    let mut s2: String = String::from(&quot;Hello &quot;);
    println!(&quot;s2: {s2}&quot;);
    s2.push_str(s1);
    println!(&quot;s2: {s2}&quot;);
  
    let s3: &amp;str = &amp;s2[6..];
    println!(&quot;s3: {s3}&quot;);
}
</code></pre></pre>
<pre><code>fn to_owned(&amp;self) -&gt; Self::Owned
</code></pre>
<p>Creates owned data from borrowed data, usually by cloning.</p>
</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="functions"><a class="header" href="#functions">Functions</a></h1>
<p>A Rust version of the famous <a href="https://en.wikipedia.org/wiki/Fizz_buzz">FizzBuzz</a> interview question:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    fizzbuzz_to(20);   // Defined below, no forward declaration needed
}

fn is_divisible_by(lhs: u32, rhs: u32) -&gt; bool {
    if rhs == 0 {
        return false;  // Corner case, early return
    }
    lhs % rhs == 0     // The last expression in a block is the return value
}

fn fizzbuzz(n: u32) -&gt; () {  // No return value means returning the unit type `()`
    match (is_divisible_by(n, 3), is_divisible_by(n, 5)) {
        (true,  true)  =&gt; println!(&quot;fizzbuzz&quot;),
        (true,  false) =&gt; println!(&quot;fizz&quot;),
        (false, true)  =&gt; println!(&quot;buzz&quot;),
        (false, false) =&gt; println!(&quot;{n}&quot;),
    }
}

fn fizzbuzz_to(n: u32) {  // `-&gt; ()` is normally omitted
    for i in 1..=n {
        fizzbuzz(i);
    }
}
</code></pre></pre>
<p>In FizzBuzz, players take turns to count incrementally, replacing any number divisible by three with the word &quot;fizz&quot;, and any number divisible by five with the word &quot;buzz&quot;, and any number divisible by both 3 and 5 with the word &quot;fizzbuzz&quot;.</p>
<details>
<ul>
<li>
<p>We refer in <code>main</code> to a function written below. Neither forward declarations nor headers are necessary.</p>
</li>
<li>
<p>Declaration parameters are followed by a type (the reverse of some programming languages), then a return type.</p>
</li>
<li>
<p>The last expression in a function body (or any block) becomes the return value. Simply omit the <code>;</code> at the end of the expression.</p>
</li>
<li>
<p>Some functions have no return value, and return the 'unit type', <code>()</code>. The compiler will infer this if the <code>-&gt; ()</code> return type is omitted.</p>
</li>
<li>
<p>The range expression in the <code>for</code> loop in <code>fizzbuzz_to()</code> contains <code>=n</code>, which causes it to include the upper bound.</p>
</li>
<li>
<p>The <code>match</code> expression in <code>fizzbuzz()</code> is doing a lot of work. It is expanded below to show what is happening.</p>
<p>(Type annotations added for clarity, but they can be elided.)</p>
<pre><code class="language-rust ignore">let by_3: bool = is_divisible_by(n, 3);
let by_5: bool = is_divisible_by(n, 5);
let by_35: (bool, bool) = (by_3, by_5);
match by_35 {
  // ...
</code></pre>
</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="methods"><a class="header" href="#methods">Methods</a></h1>
<p>Rust has methods. They are simply functions that are associated with a particular type. The
first argument of a method is an instance of the type it is associated with:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn area(&amp;self) -&gt; u32 {
        self.width * self.height
    }

    fn inc_width(&amp;mut self, delta: u32) {
        self.width += delta;
    }
}

fn main() {
    let mut rect = Rectangle { width: 10, height: 5 };
    println!(&quot;old area: {}&quot;, rect.area());
    rect.inc_width(5);
    println!(&quot;new area: {}&quot;, rect.area());
}
</code></pre></pre>
<ul>
<li>We will look much more at methods in this class' exercise and in the next class.</li>
</ul>
<details>
<ul>
<li><code>&amp;self</code> is short for <code>self: &amp;Self</code> - an immutable borrow of the instance.</li>
<li><code>&amp;mut self</code> allows the method to mutate the instance.</li>
<li><code>self</code> (without <code>&amp;</code>) takes ownership of the instance.</li>
<li>Methods are called with dot notation: <code>rect.area()</code>.</li>
<li>Associated functions (no <code>self</code>) are called with <code>::</code>: <code>Rectangle::new()</code>.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="function-overloading"><a class="header" href="#function-overloading">Function Overloading</a></h1>
<p>Overloading is not supported:</p>
<ul>
<li>Each function has a single implementation:
<ul>
<li>Always takes a fixed number of parameters.</li>
<li>Always takes a single set of parameter types.</li>
</ul>
</li>
<li>Default values are not supported:
<ul>
<li>All call sites have the same number of arguments.</li>
<li>Macros are sometimes used as an alternative.</li>
</ul>
</li>
</ul>
<p>However, function parameters can be generic:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn pick_one&lt;T&gt;(a: T, b: T) -&gt; T {
    if std::process::id() % 2 == 0 { a } else { b }
}

fn main() {
    println!(&quot;coin toss: {}&quot;, pick_one(&quot;heads&quot;, &quot;tails&quot;));
    println!(&quot;cash prize: {}&quot;, pick_one(500, 1000));
}
</code></pre></pre>
<details>
<ul>
<li>
<p>When using generics, the standard library's <code>Into&lt;T&gt;</code> can provide a kind of limited
polymorphism on argument types. We will see more details in a later section.</p>
</li>
<li>
<p><a href="https://doc.rust-lang.org/std/process/fn.id.html">std::process::id()</a> returns the
pid of the current process</p>
</li>
</ul>
</defails>
<div style="break-before: page; page-break-before: always;"></div><h1 id="course-1-exercises"><a class="header" href="#course-1-exercises">Course 1: Exercises</a></h1>
<p>In these exercises, we will explore two parts of Rust:</p>
<ul>
<li>
<p>Implicit conversions between types.</p>
</li>
<li>
<p>Arrays and <code>for</code> loops.</p>
</li>
</ul>
<details>
<p>A few things to consider while solving the exercises:</p>
<ul>
<li>
<p>Use a local Rust installation, if possible. This way you can get
auto-completion in your editor. See the page about <a href="exercises/course-1/../../cargo.html">Using Cargo</a> for details
on installing Rust.</p>
</li>
<li>
<p>Alternatively, use the Rust Playground.</p>
</li>
</ul>
<p>The code snippets are not editable on purpose: the inline code snippets lose
their state if you navigate away from the page.</p>
<!-- After looking at the exercises, you can look at the [solutions] provided. -->
<!-- [solutions]: solutions-morning.md -->
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="implicit-conversions"><a class="header" href="#implicit-conversions">Implicit Conversions</a></h1>
<p>Rust will not automatically apply <em>implicit conversions</em> between types (<a href="https://en.cppreference.com/w/cpp/language/implicit_conversion">unlike
C++</a>). You can see this in a program like this:</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail edition2021">fn multiply(x: i16, y: i16) -&gt; i16 {
    x * y
}

fn main() {
    let x: i8 = 15;
    let y: i16 = 1000;

    println!(&quot;{x} * {y} = {}&quot;, multiply(x, y));
}
</code></pre></pre>
<p>The Rust integer types all implement the <a href="https://doc.rust-lang.org/std/convert/trait.From.html"><code>From&lt;T&gt;</code></a> and <a href="https://doc.rust-lang.org/std/convert/trait.Into.html"><code>Into&lt;T&gt;</code></a>
traits to let us convert between them. The <code>From&lt;T&gt;</code> trait has a single <code>from()</code>
method and similarly, the <code>Into&lt;T&gt;</code> trait has a single <code>into()</code> method.
Implementing these traits is how a type expresses that it can be converted into
another type.</p>
<p>The standard library has an implementation of <code>From&lt;i8&gt; for i16</code>, which means
that we can convert a variable <code>x</code> of type <code>i8</code> to an <code>i16</code> by calling
<code>i16::from(x)</code>. Or, simpler, with <code>x.into()</code>, because <code>From&lt;i8&gt; for i16</code>
implementation automatically create an implementation of <code>Into&lt;i16&gt; for i8</code>.</p>
<p>The same applies for your own <code>From</code> implementations for your own types, so it is
sufficient to only implement <code>From</code> to get a respective <code>Into</code> implementation automatically.</p>
<ol>
<li>
<p>Execute the above program and look at the compiler error.</p>
</li>
<li>
<p>Update the code above to use <code>into()</code> to do the conversion.</p>
</li>
<li>
<p>Change the types of <code>x</code> and <code>y</code> to other things (such as <code>f32</code>, <code>bool</code>,
<code>i128</code>) to see which types you can convert to which other types. Try
converting small types to big types and the other way around. Check the
<a href="https://doc.rust-lang.org/std/convert/trait.From.html">standard library documentation</a> to see if <code>From&lt;T&gt;</code> is implemented for
the pairs you check.</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="matrix-multiplication"><a class="header" href="#matrix-multiplication">Matrix multiplication</a></h1>
<p>Your task is to write a function that performs matrix multiplication in Rust. The function signature should look like this:</p>
<pre><code class="language-rs">fn multiply_matrices(a: &amp;Vec&lt;Vec&lt;i32&gt;&gt;, b: &amp;Vec&lt;Vec&lt;i32&gt;&gt;) -&gt; Vec&lt;Vec&lt;i32&gt;&gt; {
    // Your code
}
</code></pre>
<p>Your code should check that the matrices have the right dimensions.</p>
<p>There are different ways to represent 2-D arrays in Rust, here we chose the type <code>&amp;Vec&lt;Vec&lt;i32&gt;&gt;</code>. When you finish this exercice, feel free to explore other possible representations (e.g <code>ndarray::arr2</code>).</p>
<p>Usage example:</p>
<pre><code class="language-rs">fn main() {
    let matrix_a = vec![
        vec![1, 2, 3],
        vec![4, 5, 6],
    ];

    let matrix_b = vec![
        vec![7, 8],
        vec![9, 10],
        vec![11, 12],
    ];

    let result_matrix = multiply_matrices(&amp;matrix_a, &amp;matrix_b);

    // Print the result
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="arrays-and-for-loops"><a class="header" href="#arrays-and-for-loops">Arrays and <code>for</code> Loops</a></h1>
<p>We saw that an array can be declared like this:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let array = [10, 20, 30];
<span class="boring">}
</span></code></pre></pre>
<p>You can print such an array by asking for its debug representation with <code>{:?}</code>:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let array = [10, 20, 30];
    println!(&quot;array: {array:?}&quot;);
}
</code></pre></pre>
<p>Rust lets you iterate over things like arrays and ranges using the <code>for</code>
keyword:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let array = [10, 20, 30];
    print!(&quot;Iterating over array:&quot;);
    for n in array {
        print!(&quot; {n}&quot;);
    }
    println!();

    print!(&quot;Iterating over range:&quot;);
    for i in 0..3 {
        print!(&quot; {}&quot;, array[i]);
    }
    println!();
}
</code></pre></pre>
<p>Use the above to write a function <code>pretty_print</code> which pretty-print a matrix and
a function <code>transpose</code> which will transpose a matrix (turn rows into columns):</p>
<div style='width:100%; height:64px;'><style type="text/css">svg { width: 100% !important; }</style><svg xmlns="http://www.w3.org/2000/svg" width="272" height="64" class="svgbob"><style>.svgbob line, .svgbob path, .svgbob circle, .svgbob rect, .svgbob polygon {  stroke: var(--fg);  stroke-width: 2;  stroke-opacity: 1;  fill-opacity: 1;  stroke-linecap: round;  stroke-linejoin: miter;}.svgbob text {  white-space: pre;  fill: var(--fg);  font-family: Iosevka Fixed, monospace;  font-size: 14px;}.svgbob rect.backdrop {  stroke: none;  fill: transparent;}.svgbob .broken {  stroke-dasharray: 8;}.svgbob .filled {  fill: black;}.svgbob .bg_filled {  fill: transparent;  stroke-width: 1;}.svgbob .nofill {  fill: transparent;}.svgbob .end_marked_arrow {  marker-end: url(#arrow);}.svgbob .start_marked_arrow {  marker-start: url(#arrow);}.svgbob .end_marked_diamond {  marker-end: url(#diamond);}.svgbob .start_marked_diamond {  marker-start: url(#diamond);}.svgbob .end_marked_circle {  marker-end: url(#circle);}.svgbob .start_marked_circle {  marker-start: url(#circle);}.svgbob .end_marked_open_circle {  marker-end: url(#open_circle);}.svgbob .start_marked_open_circle {  marker-start: url(#open_circle);}.svgbob .end_marked_big_open_circle {  marker-end: url(#big_open_circle);}.svgbob .start_marked_big_open_circle {  marker-start: url(#big_open_circle);}</style><defs><marker id="arrow" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,0 0,4 4,2 0,0"></polygon></marker><marker id="diamond" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,2 2,0 4,2 2,4 0,2"></polygon></marker><marker id="circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2" class="filled"></circle></marker><marker id="open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2" class="bg_filled"></circle></marker><marker id="big_open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="3" class="bg_filled"></circle></marker></defs><rect class="backdrop" x="0" y="0" width="272" height="64"></rect><text x="122" y="12" >2</text><text x="122" y="28" >5</text><text x="122" y="44" >8</text><text x="234" y="12" >4</text><text x="234" y="28" >5</text><text x="234" y="44" >6</text><text x="250" y="12" >7‚é§</text><text x="250" y="28" >8‚é•</text><text x="250" y="44" >9‚é¶</text><text x="2" y="28" >transpose</text><text x="178" y="28" >==</text><g><text x="90" y="12">‚éõ</text><text x="98" y="12">‚é°</text><text x="106" y="12">1</text></g><g><text x="90" y="28">‚éú</text><text x="98" y="28">‚é¢</text><text x="106" y="28">4</text></g><g><text x="90" y="44">‚éù</text><text x="98" y="44">‚é£</text><text x="106" y="44">7</text></g><g><text x="138" y="12">3‚é§</text><text x="154" y="12">‚éû</text></g><g><text x="138" y="28">6‚é•</text><text x="154" y="28">‚éü</text></g><g><text x="138" y="44">9‚é¶</text><text x="154" y="44">‚é†</text></g><g><text x="210" y="12">‚é°</text><text x="218" y="12">1</text></g><g><text x="210" y="28">‚é¢</text><text x="218" y="28">2</text></g><g><text x="210" y="44">‚é£</text><text x="218" y="44">3</text></g></svg></div>
<p>Hard-code both functions to operate on 3 √ó 3 matrices.</p>
<p>Copy the code below to <a href="https://play.rust-lang.org/">https://play.rust-lang.org/</a> and implement the
functions:</p>
<pre><pre class="playground"><code class="language-rust should_panic edition2021">// TODO: remove this when you're done with your implementation.
#![allow(unused_variables, dead_code)]

fn transpose(matrix: [[i32; 3]; 3]) -&gt; [[i32; 3]; 3] {
    unimplemented!()
}

fn pretty_print(matrix: &amp;[[i32; 3]; 3]) {
    unimplemented!()
}

fn main() {
    let matrix = [
        [101, 102, 103], // &lt;-- the comment makes rustfmt add a newline
        [201, 202, 203],
        [301, 302, 303],
    ];

    println!(&quot;matrix:&quot;);
    pretty_print(&amp;matrix);

    let transposed = transpose(matrix);
    println!(&quot;transposed:&quot;);
    pretty_print(&amp;transposed);
}
</code></pre></pre>
<h2 id="bonus-question"><a class="header" href="#bonus-question">Bonus Question</a></h2>
<p>Could you use <code>&amp;[i32]</code> slices instead of hard-coded 3 √ó 3 matrices for your
argument and return types? Something like <code>&amp;[&amp;[i32]]</code> for a two-dimensional
slice-of-slices. Why or why not?</p>
<p>See the <a href="https://docs.rs/ndarray/"><code>ndarray</code> crate</a> for a production quality
implementation.</p>
<!-- <details>

The solution and the answer to the bonus section are available in the 
[Solution](solutions-morning.md#arrays-and-for-loops) section.

</details> -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="palindrome"><a class="header" href="#palindrome">Palindrome</a></h1>
<p>Implement a Rust function that determines whether a given string is a palindrome.</p>
<p>A palindrome is a sequence of characters that reads the same forward and backward (e.g. kayak, madam, racecar, ...).</p>
<p>In this exercices we ask you to ignore spaces, punctuation, and case.</p>
<p>Have a look at the <a href="https://doc.rust-lang.org/std/primitive.str.html"><code>std::str</code></a> documentation if needed.</p>
<p>Function signature:</p>
<pre><code class="language-rs">fn is_palindrome(s: &amp;str) -&gt; bool{
    // Your code
}
</code></pre>
<p>Usage example:</p>
<pre><code class="language-rs">fn main() {
    let palindrome1 = &quot;A man, a plan, a canal, Panama&quot;;
    let palindrome2 = &quot;Madam, in Eden, I'm Adam&quot;;
    let non_palindrome = &quot;Having class 8:30am is fun!!&quot;;

    println!(&quot;Is '{}' a palindrome? {}&quot;, palindrome1, is_palindrome(palindrome1)); // True
    println!(&quot;Is '{}' a palindrome? {}&quot;, palindrome2, is_palindrome(palindrome2)); // True
    println!(&quot;Is '{}' a palindrome? {}&quot;, non_palindrome, is_palindrome(non_palindrome)); // False
}
</code></pre>
<details>
<p><strong>Exercise guidance for speakers:</strong></p>
<ul>
<li>This is a great introductory exercise for string manipulation.</li>
<li>Students practice <code>chars()</code>, <code>filter()</code>, and iterator methods.</li>
<li>Key insight: compare filtered chars with reversed filtered chars.</li>
</ul>
<p><strong>Key concepts practiced:</strong></p>
<ol>
<li>String methods: <code>chars()</code>, <code>to_lowercase()</code>.</li>
<li>Iterator methods: <code>filter()</code>, <code>rev()</code>, <code>eq()</code>.</li>
<li>Closures for filtering predicates.</li>
<li>Character methods: <code>is_alphanumeric()</code>.</li>
</ol>
<p><strong>Hints to give if stuck:</strong></p>
<ul>
<li>Filter to keep only alphanumeric characters.</li>
<li>Convert to lowercase for case-insensitive comparison.</li>
<li>Use <code>rev()</code> to reverse an iterator.</li>
<li>Compare with <code>eq()</code> or <code>collect()</code> and compare collections.</li>
</ul>
<p><strong>Elegant solution:</strong></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn is_palindrome(s: &amp;str) -&gt; bool {
    let chars: Vec&lt;_&gt; = s.chars()
        .filter(|c| c.is_alphanumeric())
        .map(|c| c.to_ascii_lowercase())
        .collect();
    chars.iter().eq(chars.iter().rev())
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>Common mistakes:</strong></p>
<ul>
<li>Forgetting to handle case sensitivity.</li>
<li>Not filtering out spaces and punctuation.</li>
<li>Inefficient double iteration (can be done in one pass with <code>take(n/2)</code> comparison).</li>
</ul>
</details><div style="break-before: page; page-break-before: always;"></div><h1 id="exercise-fibonacci"><a class="header" href="#exercise-fibonacci">Exercise: Fibonacci</a></h1>
<p>The Fibonacci sequence begins with <code>[0, 1]</code>. For <code>n &gt; 1</code>, the next number is the
sum of the previous two.</p>
<p>Write a function <code>fib(n)</code> that calculates the nth Fibonacci number. When will
this function panic?</p>
<pre><pre class="playground"><code class="language-rust editable should_panic edition2021">fn fib(n: u32) -&gt; u32 {
    if n &lt; 2 {
        // The base case.
        return todo!(&quot;Implement this&quot;);
    } else {
        // The recursive case.
        return todo!(&quot;Implement this&quot;);
    }
}

fn main() {
    let n = 20;
    println!(&quot;fib({n}) = {}&quot;, fib(n));
}
</code></pre></pre>
<details>
<summary>Hints</summary>
<ul>
<li>This exercise is a classic introduction to recursion.</li>
<li>Think about the base cases and the recursive step.</li>
<li>The question &quot;When will this function panic?&quot; is a hint to think about integer
overflow. The Fibonacci sequence grows quickly!</li>
<li>An iterative solution is also valid - consider the trade-offs between recursion
and iteration (e.g., performance, stack overflow for deep recursion).</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="exercise-collatz-sequence"><a class="header" href="#exercise-collatz-sequence">Exercise: Collatz Sequence</a></h1>
<p>The <a href="https://en.wikipedia.org/wiki/Collatz_conjecture">Collatz Sequence</a> is
defined as follows, for an arbitrary n‚ÇÅ greater than zero:</p>
<ul>
<li>If <em>n·µ¢</em> is 1, then the sequence terminates at <em>n·µ¢</em>.</li>
<li>If <em>n·µ¢</em> is even, then <em>n·µ¢‚Çä‚ÇÅ = n·µ¢ / 2</em>.</li>
<li>If <em>n·µ¢</em> is odd, then <em>n·µ¢‚Çä‚ÇÅ = 3 * n·µ¢ + 1</em>.</li>
</ul>
<p>For example, beginning with <em>n‚ÇÅ</em> = 3:</p>
<ul>
<li>3 is odd, so <em>n‚ÇÇ</em> = 3 * 3 + 1 = 10;</li>
<li>10 is even, so <em>n‚ÇÉ</em> = 10 / 2 = 5;</li>
<li>5 is odd, so <em>n‚ÇÑ</em> = 3 * 5 + 1 = 16;</li>
<li>16 is even, so <em>n‚ÇÖ</em> = 16 / 2 = 8;</li>
<li>8 is even, so <em>n‚ÇÜ</em> = 8 / 2 = 4;</li>
<li>4 is even, so <em>n‚Çá</em> = 4 / 2 = 2;</li>
<li>2 is even, so <em>n‚Çà</em> = 1; and</li>
<li>the sequence terminates.</li>
</ul>
<p>Write a function to calculate the length of the Collatz sequence for a given
initial <code>n</code>.</p>
<pre><pre class="playground"><code class="language-rust editable should_panic edition2021">/// Determine the length of the collatz sequence beginning at `n`.
fn collatz_length(mut n: i32) -&gt; u32 {
    todo!(&quot;Implement this&quot;)
}

fn main() {
    println!(&quot;Length: {}&quot;, collatz_length(11)); // should be 15
}
</code></pre></pre>
<details>
<summary>Hints</summary>
<ul>
<li>Use a <code>while</code> loop to iterate until <code>n</code> reaches 1.</li>
<li>Use <code>if</code> expressions to check if <code>n</code> is even or odd.</li>
<li>Remember to count each step!</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="welcome-to-course-2"><a class="header" href="#welcome-to-course-2">Welcome to course 2</a></h1>
<p>We will cover:</p>
<ul>
<li>
<p>Memory management: stack vs heap, manual memory management, scope-based memory
management, and garbage collection.</p>
</li>
<li>
<p>Ownership: move semantics, copying and cloning, borrowing, and lifetimes.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="variables"><a class="header" href="#variables">Variables</a></h1>
<p>Rust provides type safety via static typing. Variable bindings are immutable by
default:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let x: i32 = 10;
    println!(&quot;x: {x}&quot;);
    // x = 20;
    // println!(&quot;x: {x}&quot;);
}
</code></pre></pre>
<details>
<ul>
<li>Due to type inference the <code>i32</code> is optional. We will gradually show the types less and less as the course progresses.</li>
<li>Note that since <code>println!</code> is a macro, <code>x</code> is not moved, even using the function like syntax of <code>println!(&quot;x: {}&quot;, x)</code></li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="type-inference"><a class="header" href="#type-inference">Type Inference</a></h1>
<p>Rust will look at how the variable is <em>used</em> to determine the type:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn takes_u32(x: u32) {
    println!(&quot;u32: {x}&quot;);
}

fn takes_i8(y: i8) {
    println!(&quot;i8: {y}&quot;);
}

fn main() {
    let x = 10;
    let y = 20;

    takes_u32(x);
    takes_i8(y);
    // takes_u32(y);
}
</code></pre></pre>
<details>
<p>This slide demonstrates how the Rust compiler infers types based on constraints given by variable declarations and usages.</p>
<p>It is very important to emphasize that variables declared like this are not of some sort of dynamic &quot;any type&quot; that can
hold any data. The machine code generated by such declaration is identical to the explicit declaration of a type.
The compiler does the job for us and helps us to write a more concise code.</p>
<p>The following code tells the compiler to copy into a certain generic container without the code ever explicitly specifying the contained type, using <code>_</code> as a placeholder:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let mut v = Vec::new();
    v.push((10, false));
    v.push((20, true));
    println!(&quot;v: {v:?}&quot;);

    let vv = v.iter().collect::&lt;std::collections::HashSet&lt;_&gt;&gt;();
    println!(&quot;vv: {vv:?}&quot;);
}
</code></pre></pre>
<p><a href="https://doc.rust-lang.org/stable/std/iter/trait.Iterator.html#method.collect"><code>collect</code></a> relies on <code>FromIterator</code>, which <a href="https://doc.rust-lang.org/std/iter/trait.FromIterator.html"><code>HashSet</code></a> implements.</p>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="option"><a class="header" href="#option">Option</a></h1>
<p>Option<type> comes from <code>std::option</code>. It is used to represent an optional value. Option is either <code>Some</code> or <code>None</code>.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn divide(numerator: f64, denominator: f64) -&gt; Option&lt;f64&gt; {
    if denominator == 0.0 {
        None
    } else {
        Some(numerator / denominator)
    }
}

fn main () {
    // The return value of the function is an option
    let result = divide(2.0, 3.0);

    // Pattern match to retrieve the value
    match result {
        // The division was valid
        Some(x) =&gt; println!(&quot;Result: {x}&quot;),
        // The division was invalid
        None    =&gt; println!(&quot;Cannot divide by 0&quot;),
    }
}
</code></pre></pre>
<details>
<ul>
<li>See <a href="https://doc.rust-lang.org/std/option/">std::option</a> for more info.</li>
</ul>
</details><div style="break-before: page; page-break-before: always;"></div><h1 id="static-and-constant-variables"><a class="header" href="#static-and-constant-variables">Static and Constant Variables</a></h1>
<p>Global state is managed with static and constant variables.</p>
<h2 id="const"><a class="header" href="#const"><code>const</code></a></h2>
<p>You can declare compile-time constants:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">const DIGEST_SIZE: usize = 3;
const ZERO: Option&lt;u8&gt; = Some(42);

fn compute_digest(text: &amp;str) -&gt; [u8; DIGEST_SIZE] {

    // println!(&quot;{:?}&quot;, text.as_bytes());
    // println!(&quot;{}&quot;, ZERO.unwrap_or(0));

    let mut digest = [ZERO.unwrap_or(0); DIGEST_SIZE];

    // println!(&quot;{:?}&quot;, digest);

    for (idx, &amp;b) in text.as_bytes().iter().enumerate() {

        // println!(&quot;[{:?}]: {:?}&quot;, idx, &amp;b);
        
        digest[idx % DIGEST_SIZE] = digest[idx % DIGEST_SIZE].wrapping_add(b);
    }
    digest
}

fn main() {
    let digest = compute_digest(&quot;Hello&quot;);
    println!(&quot;Digest: {digest:?}&quot;);
}
</code></pre></pre>
<p>According the the <a href="https://rust-lang.github.io/rfcs/0246-const-vs-static.html">Rust RFC Book</a> these are inlined upon use.</p>
<h2 id="static"><a class="header" href="#static"><code>static</code></a></h2>
<p>You can also declare static variables:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">static BANNER: &amp;str = &quot;Welcome to RustOS 3.14&quot;;

fn main() {
    println!(&quot;{BANNER}&quot;);
}
</code></pre></pre>
<p>As noted in the <a href="https://rust-lang.github.io/rfcs/0246-const-vs-static.html">Rust RFC Book</a>, these are not inlined upon use and have an actual associated memory location.  This is useful for unsafe and embedded code, and the variable lives through the entirety of the program execution.</p>
<p>We will look at mutating static data in the <a href="basic-syntax/../unsafe.html">chapter on Unsafe Rust</a>.</p>
<details>
<ul>
<li><code>pub fn unwrap_or(self, default: T) -&gt; T</code>. Returns the contained <code>Some</code> value or a provided default. Here, ZERO.unwrap_or(0) is equal to 42. It would return 0 if ZERO was equal to None.</li>
<li><code>const</code> is used to define a constant value that is inlined wherever it is used. inlingin means that the compiler replaces all instances of the constant with its value.</li>
<li><code>static</code>, on the other hand have a fixed memory location and can be mutated.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="scopes-and-shadowing"><a class="header" href="#scopes-and-shadowing">Scopes and Shadowing</a></h1>
<p>You can shadow variables, both those from outer scopes and variables from the
same scope:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let a = 10;
    println!(&quot;before: {a}&quot;);

    {
        let a = &quot;hello&quot;;
        println!(&quot;inner scope: {a}&quot;);

        let a = true;
        println!(&quot;shadowed in inner scope: {a}&quot;);
    }

    println!(&quot;after: {a}&quot;);
}
</code></pre></pre>
<details>
<ul>
<li>Definition: Shadowing is different from mutation, because after shadowing both variable's memory locations exist at the same time. Both are available under the same name, depending where you use it in the code.</li>
<li>A shadowing variable can have a different type.</li>
<li>Shadowing looks obscure at first, but is convenient for holding on to values after <code>.unwrap()</code>.</li>
<li>The following code demonstrates why the compiler can't simply reuse memory locations when shadowing an immutable variable in a scope, even if the type does not change.</li>
</ul>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let a = 1;
    let b = &amp;a;
    let a = a + 1;
    println!(&quot;{a} {b}&quot;);
}
</code></pre></pre>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="memory-management"><a class="header" href="#memory-management">Memory Management</a></h1>
<p>Traditionally, languages have fallen into two broad categories:</p>
<ul>
<li>Full control via manual memory management: C, C++, Pascal, ...</li>
<li>Full safety via automatic memory management at runtime: Java, Python, Go, Haskell, ...</li>
</ul>
<p>Rust offers a new mix:</p>
<blockquote>
<p>Full control <em>and</em> safety via compile time enforcement of correct memory
management.</p>
</blockquote>
<p>It does this with an explicit ownership concept.</p>
<p>First, let's refresh how memory management works.</p>
<details>
<ul>
<li>C/C++ give full control but require manual memory management, leading to bugs
like use-after-free, double-free, and memory leaks.</li>
<li>Languages with garbage collection (Java, Go, Python) are safe but have
runtime overhead and less predictable performance.</li>
<li>Rust achieves both safety and control through compile-time ownership rules.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-stack-vs-the-heap"><a class="header" href="#the-stack-vs-the-heap">The Stack vs The Heap</a></h1>
<ul>
<li>
<p>Stack: Continuous area of memory for local variables.</p>
<ul>
<li>Values have fixed sizes known at compile time.</li>
<li>Extremely fast: just move a stack pointer.</li>
<li>Easy to manage: follows function calls.</li>
<li>Great memory locality.</li>
</ul>
</li>
<li>
<p>Heap: Storage of values outside of function calls.</p>
<ul>
<li>Values have dynamic sizes determined at runtime.</li>
<li>Slightly slower than the stack: some book-keeping needed.</li>
<li>No guarantee of memory locality.</li>
</ul>
</li>
</ul>
<details>
<p><strong>Key points for speakers:</strong></p>
<ul>
<li>Stack allocation is &quot;free&quot; ‚Äî just moving a pointer. Heap requires finding free space.</li>
<li>Stack size is typically limited (8MB default on Linux). Heap is limited by system memory.</li>
<li>Stack is LIFO (Last In, First Out) ‚Äî matches function call/return naturally.</li>
<li>Understanding this distinction is crucial for understanding Rust's ownership model.</li>
</ul>
<p><strong>Common student questions:</strong></p>
<ul>
<li><em>&quot;How do I know if something is on the stack or heap?&quot;</em> - Local variables of known size go on stack. <code>Box</code>, <code>Vec</code>, <code>String</code> allocate on heap. The type tells you!</li>
<li><em>&quot;Why is stack faster?&quot;</em> - No searching for free space, no fragmentation, better cache locality (data is contiguous).</li>
<li><em>&quot;What happens if I overflow the stack?&quot;</em> - Stack overflow error! Deep recursion or large arrays on stack can cause this.</li>
<li><em>&quot;Can I control where data goes?&quot;</em> - Yes! Use <code>Box::new(value)</code> to explicitly heap-allocate.</li>
</ul>
<p><strong>Visual suggestion:</strong>
Draw a diagram showing stack growing down from high addresses and heap growing up from low addresses.</p>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stack-memory"><a class="header" href="#stack-memory">Stack Memory</a></h1>
<p>Creating a <code>String</code> puts fixed-sized data on the stack and dynamically sized
data on the heap:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let s1 = String::from(&quot;Hello&quot;);
}
</code></pre></pre>
<div style='width:100%; height:192px;'><style type="text/css">svg { width: 100% !important; }</style><svg xmlns="http://www.w3.org/2000/svg" width="544" height="192" class="svgbob"><style>.svgbob line, .svgbob path, .svgbob circle, .svgbob rect, .svgbob polygon {  stroke: var(--fg);  stroke-width: 2;  stroke-opacity: 1;  fill-opacity: 1;  stroke-linecap: round;  stroke-linejoin: miter;}.svgbob text {  white-space: pre;  fill: var(--fg);  font-family: Iosevka Fixed, monospace;  font-size: 14px;}.svgbob rect.backdrop {  stroke: none;  fill: transparent;}.svgbob .broken {  stroke-dasharray: 8;}.svgbob .filled {  fill: black;}.svgbob .bg_filled {  fill: transparent;  stroke-width: 1;}.svgbob .nofill {  fill: transparent;}.svgbob .end_marked_arrow {  marker-end: url(#arrow);}.svgbob .start_marked_arrow {  marker-start: url(#arrow);}.svgbob .end_marked_diamond {  marker-end: url(#diamond);}.svgbob .start_marked_diamond {  marker-start: url(#diamond);}.svgbob .end_marked_circle {  marker-end: url(#circle);}.svgbob .start_marked_circle {  marker-start: url(#circle);}.svgbob .end_marked_open_circle {  marker-end: url(#open_circle);}.svgbob .start_marked_open_circle {  marker-start: url(#open_circle);}.svgbob .end_marked_big_open_circle {  marker-end: url(#big_open_circle);}.svgbob .start_marked_big_open_circle {  marker-start: url(#big_open_circle);}</style><defs><marker id="arrow" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,0 0,4 4,2 0,0"></polygon></marker><marker id="diamond" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,2 2,0 4,2 2,4 0,2"></polygon></marker><marker id="circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2" class="filled"></circle></marker><marker id="open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2" class="bg_filled"></circle></marker><marker id="big_open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="3" class="bg_filled"></circle></marker></defs><rect class="backdrop" x="0" y="0" width="544" height="192"></rect><text x="10" y="12" >Stack</text><line x1="24" y1="24" x2="32" y2="24" class="solid"></line><line x1="40" y1="24" x2="48" y2="24" class="solid"></line><text x="282" y="12" >Heap</text><line x1="296" y1="24" x2="304" y2="24" class="solid"></line><line x1="312" y1="24" x2="320" y2="24" class="solid"></line><text x="42" y="60" >s1</text><text x="50" y="92" >ptr</text><line x1="176" y1="88" x2="164" y2="88" class="solid end_marked_open_circle"></line><line x1="176" y1="88" x2="296" y2="88" class="solid"></line><polygon points="296,84 304,88 296,92" class="filled"></polygon><text x="322" y="92" >H</text><text x="362" y="92" >e</text><text x="402" y="92" >l</text><text x="442" y="92" >l</text><text x="482" y="92" >o</text><text x="50" y="108" >len</text><text x="178" y="108" >5</text><text x="50" y="124" >capacity</text><text x="178" y="124" >5</text><line x1="56" y1="24" x2="64" y2="24" class="solid"></line><line x1="72" y1="24" x2="80" y2="24" class="solid"></line><line x1="88" y1="24" x2="96" y2="24" class="solid"></line><line x1="104" y1="24" x2="112" y2="24" class="solid"></line><line x1="120" y1="24" x2="128" y2="24" class="solid"></line><line x1="136" y1="24" x2="144" y2="24" class="solid"></line><line x1="152" y1="24" x2="160" y2="24" class="solid"></line><line x1="168" y1="24" x2="176" y2="24" class="solid"></line><line x1="184" y1="24" x2="192" y2="24" class="solid"></line><line x1="200" y1="24" x2="208" y2="24" class="solid"></line><line x1="328" y1="24" x2="336" y2="24" class="solid"></line><line x1="344" y1="24" x2="352" y2="24" class="solid"></line><line x1="360" y1="24" x2="368" y2="24" class="solid"></line><line x1="376" y1="24" x2="384" y2="24" class="solid"></line><line x1="392" y1="24" x2="400" y2="24" class="solid"></line><line x1="408" y1="24" x2="416" y2="24" class="solid"></line><line x1="424" y1="24" x2="432" y2="24" class="solid"></line><line x1="440" y1="24" x2="448" y2="24" class="solid"></line><line x1="456" y1="24" x2="464" y2="24" class="solid"></line><line x1="472" y1="24" x2="480" y2="24" class="solid"></line><line x1="488" y1="24" x2="496" y2="24" class="solid"></line><line x1="504" y1="24" x2="512" y2="24" class="solid"></line><line x1="296" y1="152" x2="304" y2="152" class="solid"></line><line x1="312" y1="152" x2="320" y2="152" class="solid"></line><line x1="328" y1="152" x2="336" y2="152" class="solid"></line><line x1="344" y1="152" x2="352" y2="152" class="solid"></line><line x1="360" y1="152" x2="368" y2="152" class="solid"></line><line x1="376" y1="152" x2="384" y2="152" class="solid"></line><line x1="392" y1="152" x2="400" y2="152" class="solid"></line><line x1="408" y1="152" x2="416" y2="152" class="solid"></line><line x1="424" y1="152" x2="432" y2="152" class="solid"></line><line x1="440" y1="152" x2="448" y2="152" class="solid"></line><line x1="456" y1="152" x2="464" y2="152" class="solid"></line><line x1="472" y1="152" x2="480" y2="152" class="solid"></line><line x1="488" y1="152" x2="496" y2="152" class="solid"></line><line x1="504" y1="152" x2="512" y2="152" class="solid"></line><line x1="24" y1="168" x2="32" y2="168" class="solid"></line><line x1="40" y1="168" x2="48" y2="168" class="solid"></line><line x1="56" y1="168" x2="64" y2="168" class="solid"></line><line x1="72" y1="168" x2="80" y2="168" class="solid"></line><line x1="88" y1="168" x2="96" y2="168" class="solid"></line><line x1="104" y1="168" x2="112" y2="168" class="solid"></line><line x1="120" y1="168" x2="128" y2="168" class="solid"></line><line x1="136" y1="168" x2="144" y2="168" class="solid"></line><line x1="152" y1="168" x2="160" y2="168" class="solid"></line><line x1="168" y1="168" x2="176" y2="168" class="solid"></line><line x1="184" y1="168" x2="192" y2="168" class="solid"></line><line x1="200" y1="168" x2="208" y2="168" class="solid"></line><g><path d="M 8,24 A 4,4 0,0,0 4,28" class="nofill"></path><line x1="4" y1="28" x2="4" y2="164" class="broken"></line><line x1="8" y1="24" x2="16" y2="24" class="solid"></line><path d="M 4,164 A 4,4 0,0,0 8,168" class="nofill"></path><line x1="8" y1="168" x2="16" y2="168" class="solid"></line></g><g><line x1="216" y1="24" x2="224" y2="24" class="solid"></line><path d="M 224,24 A 4,4 0,0,1 228,28" class="nofill"></path><line x1="228" y1="28" x2="228" y2="164" class="broken"></line><line x1="216" y1="168" x2="224" y2="168" class="solid"></line><path d="M 228,164 A 4,4 0,0,1 224,168" class="nofill"></path></g><g><path d="M 280,24 A 4,4 0,0,0 276,28" class="nofill"></path><line x1="276" y1="28" x2="276" y2="148" class="broken"></line><line x1="280" y1="24" x2="288" y2="24" class="solid"></line><path d="M 276,148 A 4,4 0,0,0 280,152" class="nofill"></path><line x1="280" y1="152" x2="288" y2="152" class="solid"></line></g><g><line x1="36" y1="72" x2="196" y2="72" class="solid"></line><line x1="36" y1="72" x2="36" y2="136" class="solid"></line><line x1="132" y1="72" x2="132" y2="136" class="solid"></line><line x1="196" y1="72" x2="196" y2="136" class="solid"></line><line x1="36" y1="136" x2="196" y2="136" class="solid"></line></g><g><line x1="308" y1="72" x2="508" y2="72" class="solid"></line><line x1="308" y1="72" x2="308" y2="104" class="solid"></line><line x1="348" y1="72" x2="348" y2="104" class="solid"></line><line x1="388" y1="72" x2="388" y2="104" class="solid"></line><line x1="428" y1="72" x2="428" y2="104" class="solid"></line><line x1="468" y1="72" x2="468" y2="104" class="solid"></line><line x1="508" y1="72" x2="508" y2="104" class="solid"></line><line x1="308" y1="104" x2="508" y2="104" class="solid"></line></g><g><line x1="520" y1="24" x2="528" y2="24" class="solid"></line><path d="M 528,24 A 4,4 0,0,1 532,28" class="nofill"></path><line x1="532" y1="28" x2="532" y2="148" class="broken"></line><line x1="520" y1="152" x2="528" y2="152" class="solid"></line><path d="M 532,148 A 4,4 0,0,1 528,152" class="nofill"></path></g></svg></div>
<details>
<ul>
<li>Mention that a <code>String</code> is backed by a <code>Vec</code>, so it has a capacity and length and can grow if mutable via reallocation on the heap.</li>
</ul>
<!-- * If students ask about it, you can mention that the underlying memory is heap allocated using the [System Allocator] and custom allocators can be implemented using the [Allocator API] -->
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="manual-memory-management"><a class="header" href="#manual-memory-management">Manual Memory Management</a></h1>
<p>You allocate and deallocate heap memory yourself.</p>
<p>If not done with care, this can lead to crashes, bugs, security vulnerabilities, and memory leaks.</p>
<h2 id="c-example"><a class="header" href="#c-example">C Example</a></h2>
<p>You must call <code>free</code> on every pointer you allocate with <code>malloc</code>:</p>
<pre><code class="language-c">void foo(size_t n) {
    int* int_array = (int*)malloc(n * sizeof(int));
    //
    // ... lots of code
    //
    free(int_array);
}
</code></pre>
<p>Memory is leaked if the function returns early between <code>malloc</code> and <code>free</code>: the
pointer is lost and we cannot deallocate the memory.</p>
<details>
<p><strong>Key points for speakers:</strong></p>
<ul>
<li>Manual memory management requires perfect discipline ‚Äî every malloc needs a free.</li>
<li>Common bugs: use-after-free, double-free, memory leaks, buffer overflows.</li>
<li>These bugs cause security vulnerabilities (CVEs) in C/C++ codebases regularly.</li>
<li>Error paths make manual management especially error-prone.</li>
</ul>
<p><strong>Common student questions:</strong></p>
<ul>
<li><em>&quot;Why do people still use C?&quot;</em> - Legacy code, bare metal/embedded systems, maximum control. But new projects increasingly choose memory-safe languages.</li>
<li><em>&quot;What happens if you forget free?&quot;</em> - Memory leak. The memory is never returned to the OS until the program exits.</li>
<li><em>&quot;What's use-after-free?&quot;</em> - Accessing memory after it's been freed. Can cause crashes or security vulnerabilities.</li>
<li><em>&quot;How do programmers avoid these bugs?&quot;</em> - Strict coding standards, static analysis tools, and lots of testing. But mistakes still happen.</li>
</ul>
<p><strong>Real-world impact:</strong>
Microsoft reports ~70% of their security vulnerabilities are memory safety issues. This is why Rust's memory safety without GC is revolutionary.</p>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="scope-based-memory-management"><a class="header" href="#scope-based-memory-management">Scope-Based Memory Management</a></h1>
<p>Constructors and destructors let you hook into the lifetime of an object.</p>
<p>By wrapping a pointer in an object, you can free memory when the object is
destroyed. The compiler guarantees that this happens, even if an exception is
raised.</p>
<p>This is often called <em>resource acquisition is initialization</em> (RAII) and gives
you smart pointers.</p>
<h2 id="c-example-1"><a class="header" href="#c-example-1">C++ Example</a></h2>
<pre><code class="language-c++">void say_hello(std::unique_ptr&lt;Person&gt; person) {
  std::cout &lt;&lt; &quot;Hello &quot; &lt;&lt; person-&gt;name &lt;&lt; std::endl;
}
</code></pre>
<ul>
<li>The <code>std::unique_ptr</code> object is allocated on the stack, and points to
memory allocated on the heap.</li>
<li>At the end of <code>say_hello</code>, the <code>std::unique_ptr</code> destructor will run.</li>
<li>The destructor frees the <code>Person</code> object it points to.</li>
</ul>
<p>Special move constructors are used when passing ownership to a function:</p>
<pre><code class="language-c++">std::unique_ptr&lt;Person&gt; person = find_person(&quot;Carla&quot;);
say_hello(std::move(person));
</code></pre>
<details>
<p><strong>Key points for speakers:</strong></p>
<ul>
<li>RAII = &quot;Resource Acquisition Is Initialization&quot; ‚Äî resources tied to object lifetime.</li>
<li>This C++ pattern is the foundation for Rust's ownership model.</li>
<li>In C++, RAII is a convention. In Rust, it's enforced by the compiler.</li>
<li><code>std::move</code> in C++ is similar to Rust's move semantics, but C++ doesn't prevent use-after-move.</li>
</ul>
<p><strong>Common student questions:</strong></p>
<ul>
<li><em>&quot;What if I forget std::move in C++?&quot;</em> - It might compile but do the wrong thing (copy instead of move, or compile error depending on type).</li>
<li><em>&quot;How is Rust different?&quot;</em> - In Rust, moves are the default, and the compiler prevents use-after-move.</li>
<li><em>&quot;What resources besides memory use RAII?&quot;</em> - File handles, network sockets, mutex locks, database connections ‚Äî anything that needs cleanup.</li>
</ul>
<p><strong>Teaching tip:</strong>
This slide sets up <em>why</em> Rust's approach is valuable. Emphasize that C++ has the right idea but can't fully enforce it.</p>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="automatic-memory-management"><a class="header" href="#automatic-memory-management">Automatic Memory Management</a></h1>
<p>An alternative to manual and scope-based memory management is automatic memory
management:</p>
<ul>
<li>The programmer never allocates or deallocates memory explicitly.</li>
<li>A garbage collector finds unused memory and deallocates it for the programmer.</li>
</ul>
<h2 id="java-example"><a class="header" href="#java-example">Java Example</a></h2>
<p>The <code>person</code> object is not deallocated after <code>sayHello</code> returns:</p>
<pre><code class="language-java">void sayHello(Person person) {
  System.out.println(&quot;Hello &quot; + person.getName());
}
</code></pre>
<details>
<p><strong>Key points for speakers:</strong></p>
<ul>
<li>GC languages trade predictability for convenience ‚Äî you don't manage memory, but can't control when cleanup happens.</li>
<li>GC pauses can be problematic for real-time systems (games, audio, trading).</li>
<li>Java, Go, Python, JavaScript, C# all use garbage collection.</li>
<li>Rust chose a different path: compile-time memory management.</li>
</ul>
<p><strong>Common student questions:</strong></p>
<ul>
<li><em>&quot;Why doesn't Rust use GC?&quot;</em> - GC has runtime overhead and unpredictable pauses. Rust targets systems programming where these matter.</li>
<li><em>&quot;Is GC always bad?&quot;</em> - No! For many applications, GC is fine. But Rust's approach gives you GC-like safety without GC's costs.</li>
<li><em>&quot;Can I use GC in Rust?&quot;</em> - There are crate options, but idiomatic Rust doesn't need them.</li>
<li><em>&quot;What about reference counting?&quot;</em> - <code>Rc</code> and <code>Arc</code> are a form of automatic memory management, but deterministic (no pauses).</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="memory-management-in-rust"><a class="header" href="#memory-management-in-rust">Memory Management in Rust</a></h1>
<p>Memory management in Rust is a mix:</p>
<ul>
<li>Safe and correct like Java, but without a garbage collector.</li>
<li>Depending on which abstraction (or combination of abstractions) you choose, can be a single unique pointer, reference counted, or atomically reference counted.</li>
<li>Scope-based like C++, but the compiler enforces full adherence.</li>
<li>A Rust user can choose the right abstraction for the situation, some even have no cost at runtime like C.</li>
</ul>
<p>It achieves this by modeling <em>ownership</em> explicitly.</p>
<details>
<p><strong>Key points for speakers:</strong></p>
<ul>
<li>Rust's key innovation: compile-time ownership tracking with zero runtime cost.</li>
<li>The ownership model gives you C's performance with Java's safety guarantees.</li>
<li>Different smart pointers for different needs: <code>Box</code> (single owner), <code>Rc</code> (shared, single-threaded), <code>Arc</code> (shared, multi-threaded).</li>
<li>The <code>Drop</code> trait is Rust's destructor ‚Äî called automatically when a value goes out of scope.</li>
</ul>
<p><strong>Common student questions:</strong></p>
<ul>
<li><em>&quot;How can it be safe without a garbage collector?&quot;</em> - The compiler tracks ownership and ensures memory is freed exactly once, at the right time.</li>
<li><em>&quot;What if I need shared ownership?&quot;</em> - Use <code>Rc&lt;T&gt;</code> (single-threaded) or <code>Arc&lt;T&gt;</code> (multi-threaded) for reference counting.</li>
<li><em>&quot;What's the Drop trait?&quot;</em> - It's like a destructor. Implement <code>fn drop(&amp;mut self)</code> to run cleanup code when a value is dropped.</li>
<li><em>&quot;Can Rust reject valid programs?&quot;</em> - Yes, the borrow checker is conservative. Sometimes you need <code>unsafe</code> or refactoring to satisfy it.</li>
</ul>
<p><strong>Teaching tip:</strong>
Emphasize that this is the &quot;aha moment&quot; ‚Äî Rust gets the best of all worlds by using the type system to enforce memory safety at compile time.</p>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="comparison"><a class="header" href="#comparison">Comparison</a></h1>
<p>Here is a rough comparison of the memory management techniques.</p>
<h2 id="pros-of-different-memory-management-techniques"><a class="header" href="#pros-of-different-memory-management-techniques">Pros of Different Memory Management Techniques</a></h2>
<ul>
<li>Manual like C:
<ul>
<li>No runtime overhead.</li>
</ul>
</li>
<li>Automatic like Java:
<ul>
<li>Fully automatic.</li>
<li>Safe and correct.</li>
</ul>
</li>
<li>Scope-based like C++:
<ul>
<li>Partially automatic.</li>
<li>No runtime overhead.</li>
</ul>
</li>
<li>Compiler-enforced scope-based like Rust:
<ul>
<li>Enforced by compiler.</li>
<li>No runtime overhead.</li>
<li>Safe and correct.</li>
</ul>
</li>
</ul>
<h2 id="cons-of-different-memory-management-techniques"><a class="header" href="#cons-of-different-memory-management-techniques">Cons of Different Memory Management Techniques</a></h2>
<ul>
<li>Manual like C:
<ul>
<li>Use-after-free.</li>
<li>Double-frees.</li>
<li>Memory leaks.</li>
</ul>
</li>
<li>Automatic like Java:
<ul>
<li>Garbage collection pauses.</li>
<li>Destructor delays.</li>
</ul>
</li>
<li>Scope-based like C++:
<ul>
<li>Complex, opt-in by programmer.</li>
<li>Potential for use-after-free.</li>
</ul>
</li>
<li>Compiler-enforced and scope-based like Rust:
<ul>
<li>Some upfront complexity.</li>
<li>Can reject valid programs.</li>
</ul>
</li>
</ul>
<details>
<p><strong>Key points for speakers:</strong></p>
<ul>
<li>This is a summary slide ‚Äî use it to reinforce the trade-offs.</li>
<li>Rust's &quot;cons&quot; are really about learning curve, not fundamental limitations.</li>
<li>&quot;Can reject valid programs&quot; means the borrow checker is conservative ‚Äî better safe than sorry.</li>
<li>In practice, most &quot;rejected valid programs&quot; can be restructured to satisfy the compiler.</li>
</ul>
<p><strong>Common student questions:</strong></p>
<ul>
<li><em>&quot;What does 'reject valid programs' mean?&quot;</em> - The borrow checker can't prove all safe programs are safe. Example: two mutable references to different array indices.</li>
<li><em>&quot;Is the upfront complexity worth it?&quot;</em> - For systems programming, security-critical code, or long-running services ‚Äî absolutely yes.</li>
<li><em>&quot;Which should I choose for my project?&quot;</em> - Depends on your constraints. Rust excels where safety AND performance matter. GC languages are fine for many applications.</li>
</ul>
<p><strong>Discussion prompt:</strong>
Ask students: &quot;For a web server handling millions of requests, which approach would you choose and why?&quot;</p>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ownership"><a class="header" href="#ownership">Ownership</a></h1>
<p>All variable bindings have a <em>scope</em> where they are valid and it is an error to
use a variable outside its scope:</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail edition2021">struct Point(i32, i32);

fn main() {
    {
        let p = Point(3, 4);
        println!(&quot;x: {}&quot;, p.0);
    }
    println!(&quot;y: {}&quot;, p.1);
}
</code></pre></pre>
<ul>
<li>At the end of the scope, the variable is <em>dropped</em> and the data is freed.</li>
<li>A destructor can run here to free up resources.</li>
<li>We say that the variable <em>owns</em> the value.</li>
</ul>
<details>
<ul>
<li>Ownership is Rust's most unique feature and enables memory safety guarantees.</li>
<li>Each value has exactly one owner at a time.</li>
<li>When the owner goes out of scope, the value is dropped (freed).</li>
<li>Ownership can be transferred (moved) to another variable or function.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="move-semantics"><a class="header" href="#move-semantics">Move Semantics</a></h1>
<p>An assignment will transfer ownership between variables:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let s1: String = String::from(&quot;Hello!&quot;);
    let s2: String = s1;
    println!(&quot;s2: {s2}&quot;);
    // println!(&quot;s1: {s1}&quot;);
}
</code></pre></pre>
<ul>
<li>The assignment of <code>s1</code> to <code>s2</code> transfers ownership.</li>
<li>The data was <em>moved</em> from <code>s1</code> and <code>s1</code> is no longer accessible.</li>
<li>When <code>s1</code> goes out of scope, nothing happens: it has no ownership.</li>
<li>When <code>s2</code> goes out of scope, the string data is freed.</li>
<li>There is always <em>exactly</em> one variable binding which owns a value.</li>
</ul>
<details>
<ul>
<li>
<p>Mention that this is the opposite of the defaults in C++, which copies by value unless you use <code>std::move</code> (and the move constructor is defined!).</p>
</li>
<li>
<p>In Rust, your clones are explicit (by using <code>clone</code>).</p>
</li>
</ul>
</details><div style="break-before: page; page-break-before: always;"></div><h1 id="moved-strings-in-rust"><a class="header" href="#moved-strings-in-rust">Moved Strings in Rust</a></h1>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let s1: String = String::from(&quot;Rust&quot;);
    let s2: String = s1;
}
</code></pre></pre>
<ul>
<li>The heap data from <code>s1</code> is reused for <code>s2</code>.</li>
<li>When <code>s1</code> goes out of scope, nothing happens (it has been moved from).</li>
</ul>
<p>Before move to <code>s2</code>:</p>
<div style='width:100%; height:208px;'><style type="text/css">svg { width: 100% !important; }</style><svg xmlns="http://www.w3.org/2000/svg" width="512" height="208" class="svgbob"><style>.svgbob line, .svgbob path, .svgbob circle, .svgbob rect, .svgbob polygon {  stroke: var(--fg);  stroke-width: 2;  stroke-opacity: 1;  fill-opacity: 1;  stroke-linecap: round;  stroke-linejoin: miter;}.svgbob text {  white-space: pre;  fill: var(--fg);  font-family: Iosevka Fixed, monospace;  font-size: 14px;}.svgbob rect.backdrop {  stroke: none;  fill: transparent;}.svgbob .broken {  stroke-dasharray: 8;}.svgbob .filled {  fill: black;}.svgbob .bg_filled {  fill: transparent;  stroke-width: 1;}.svgbob .nofill {  fill: transparent;}.svgbob .end_marked_arrow {  marker-end: url(#arrow);}.svgbob .start_marked_arrow {  marker-start: url(#arrow);}.svgbob .end_marked_diamond {  marker-end: url(#diamond);}.svgbob .start_marked_diamond {  marker-start: url(#diamond);}.svgbob .end_marked_circle {  marker-end: url(#circle);}.svgbob .start_marked_circle {  marker-start: url(#circle);}.svgbob .end_marked_open_circle {  marker-end: url(#open_circle);}.svgbob .start_marked_open_circle {  marker-start: url(#open_circle);}.svgbob .end_marked_big_open_circle {  marker-end: url(#big_open_circle);}.svgbob .start_marked_big_open_circle {  marker-start: url(#big_open_circle);}</style><defs><marker id="arrow" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,0 0,4 4,2 0,0"></polygon></marker><marker id="diamond" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,2 2,0 4,2 2,4 0,2"></polygon></marker><marker id="circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2" class="filled"></circle></marker><marker id="open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2" class="bg_filled"></circle></marker><marker id="big_open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="3" class="bg_filled"></circle></marker></defs><rect class="backdrop" x="0" y="0" width="512" height="208"></rect><text x="10" y="12" >Stack</text><line x1="24" y1="24" x2="32" y2="24" class="solid"></line><line x1="40" y1="24" x2="48" y2="24" class="solid"></line><text x="282" y="12" >Heap</text><line x1="296" y1="24" x2="304" y2="24" class="solid"></line><line x1="312" y1="24" x2="320" y2="24" class="solid"></line><text x="42" y="60" >s1</text><text x="50" y="92" >ptr</text><line x1="176" y1="88" x2="164" y2="88" class="solid end_marked_open_circle"></line><line x1="176" y1="88" x2="296" y2="88" class="solid"></line><polygon points="296,84 304,88 296,92" class="filled"></polygon><text x="322" y="92" >R</text><text x="362" y="92" >u</text><text x="402" y="92" >s</text><text x="442" y="92" >t</text><text x="50" y="108" >len</text><text x="178" y="108" >4</text><text x="50" y="124" >capacity</text><text x="178" y="124" >4</text><line x1="56" y1="24" x2="64" y2="24" class="solid"></line><line x1="72" y1="24" x2="80" y2="24" class="solid"></line><line x1="88" y1="24" x2="96" y2="24" class="solid"></line><line x1="104" y1="24" x2="112" y2="24" class="solid"></line><line x1="120" y1="24" x2="128" y2="24" class="solid"></line><line x1="136" y1="24" x2="144" y2="24" class="solid"></line><line x1="152" y1="24" x2="160" y2="24" class="solid"></line><line x1="168" y1="24" x2="176" y2="24" class="solid"></line><line x1="184" y1="24" x2="192" y2="24" class="solid"></line><line x1="200" y1="24" x2="208" y2="24" class="solid"></line><line x1="328" y1="24" x2="336" y2="24" class="solid"></line><line x1="344" y1="24" x2="352" y2="24" class="solid"></line><line x1="360" y1="24" x2="368" y2="24" class="solid"></line><line x1="376" y1="24" x2="384" y2="24" class="solid"></line><line x1="392" y1="24" x2="400" y2="24" class="solid"></line><line x1="408" y1="24" x2="416" y2="24" class="solid"></line><line x1="424" y1="24" x2="432" y2="24" class="solid"></line><line x1="440" y1="24" x2="448" y2="24" class="solid"></line><line x1="456" y1="24" x2="464" y2="24" class="solid"></line><line x1="472" y1="24" x2="480" y2="24" class="solid"></line><line x1="296" y1="152" x2="304" y2="152" class="solid"></line><line x1="312" y1="152" x2="320" y2="152" class="solid"></line><line x1="328" y1="152" x2="336" y2="152" class="solid"></line><line x1="344" y1="152" x2="352" y2="152" class="solid"></line><line x1="360" y1="152" x2="368" y2="152" class="solid"></line><line x1="376" y1="152" x2="384" y2="152" class="solid"></line><line x1="392" y1="152" x2="400" y2="152" class="solid"></line><line x1="408" y1="152" x2="416" y2="152" class="solid"></line><line x1="424" y1="152" x2="432" y2="152" class="solid"></line><line x1="440" y1="152" x2="448" y2="152" class="solid"></line><line x1="456" y1="152" x2="464" y2="152" class="solid"></line><line x1="472" y1="152" x2="480" y2="152" class="solid"></line><line x1="24" y1="184" x2="32" y2="184" class="solid"></line><line x1="40" y1="184" x2="48" y2="184" class="solid"></line><line x1="56" y1="184" x2="64" y2="184" class="solid"></line><line x1="72" y1="184" x2="80" y2="184" class="solid"></line><line x1="88" y1="184" x2="96" y2="184" class="solid"></line><line x1="104" y1="184" x2="112" y2="184" class="solid"></line><line x1="120" y1="184" x2="128" y2="184" class="solid"></line><line x1="136" y1="184" x2="144" y2="184" class="solid"></line><line x1="152" y1="184" x2="160" y2="184" class="solid"></line><line x1="168" y1="184" x2="176" y2="184" class="solid"></line><line x1="184" y1="184" x2="192" y2="184" class="solid"></line><line x1="200" y1="184" x2="208" y2="184" class="solid"></line><g><path d="M 8,24 A 4,4 0,0,0 4,28" class="nofill"></path><line x1="4" y1="28" x2="4" y2="180" class="broken"></line><line x1="8" y1="24" x2="16" y2="24" class="solid"></line><path d="M 4,180 A 4,4 0,0,0 8,184" class="nofill"></path><line x1="8" y1="184" x2="16" y2="184" class="solid"></line></g><g><line x1="216" y1="24" x2="224" y2="24" class="solid"></line><path d="M 224,24 A 4,4 0,0,1 228,28" class="nofill"></path><line x1="228" y1="28" x2="228" y2="180" class="broken"></line><line x1="216" y1="184" x2="224" y2="184" class="solid"></line><path d="M 228,180 A 4,4 0,0,1 224,184" class="nofill"></path></g><g><path d="M 280,24 A 4,4 0,0,0 276,28" class="nofill"></path><line x1="276" y1="28" x2="276" y2="148" class="broken"></line><line x1="280" y1="24" x2="288" y2="24" class="solid"></line><path d="M 276,148 A 4,4 0,0,0 280,152" class="nofill"></path><line x1="280" y1="152" x2="288" y2="152" class="solid"></line></g><g><line x1="36" y1="72" x2="196" y2="72" class="solid"></line><line x1="36" y1="72" x2="36" y2="136" class="solid"></line><line x1="132" y1="72" x2="132" y2="136" class="solid"></line><line x1="196" y1="72" x2="196" y2="136" class="solid"></line><line x1="36" y1="136" x2="196" y2="136" class="solid"></line></g><g><line x1="308" y1="72" x2="468" y2="72" class="solid"></line><line x1="308" y1="72" x2="308" y2="104" class="solid"></line><line x1="348" y1="72" x2="348" y2="104" class="solid"></line><line x1="388" y1="72" x2="388" y2="104" class="solid"></line><line x1="428" y1="72" x2="428" y2="104" class="solid"></line><line x1="468" y1="72" x2="468" y2="104" class="solid"></line><line x1="308" y1="104" x2="468" y2="104" class="solid"></line></g><g><line x1="488" y1="24" x2="496" y2="24" class="solid"></line><path d="M 496,24 A 4,4 0,0,1 500,28" class="nofill"></path><line x1="500" y1="28" x2="500" y2="148" class="broken"></line><line x1="488" y1="152" x2="496" y2="152" class="solid"></line><path d="M 500,148 A 4,4 0,0,1 496,152" class="nofill"></path></g></svg></div>
<p>After move to <code>s2</code>:</p>
<div style='width:100%; height:304px;'><style type="text/css">svg { width: 100% !important; }</style><svg xmlns="http://www.w3.org/2000/svg" width="512" height="304" class="svgbob"><style>.svgbob line, .svgbob path, .svgbob circle, .svgbob rect, .svgbob polygon {  stroke: var(--fg);  stroke-width: 2;  stroke-opacity: 1;  fill-opacity: 1;  stroke-linecap: round;  stroke-linejoin: miter;}.svgbob text {  white-space: pre;  fill: var(--fg);  font-family: Iosevka Fixed, monospace;  font-size: 14px;}.svgbob rect.backdrop {  stroke: none;  fill: transparent;}.svgbob .broken {  stroke-dasharray: 8;}.svgbob .filled {  fill: black;}.svgbob .bg_filled {  fill: transparent;  stroke-width: 1;}.svgbob .nofill {  fill: transparent;}.svgbob .end_marked_arrow {  marker-end: url(#arrow);}.svgbob .start_marked_arrow {  marker-start: url(#arrow);}.svgbob .end_marked_diamond {  marker-end: url(#diamond);}.svgbob .start_marked_diamond {  marker-start: url(#diamond);}.svgbob .end_marked_circle {  marker-end: url(#circle);}.svgbob .start_marked_circle {  marker-start: url(#circle);}.svgbob .end_marked_open_circle {  marker-end: url(#open_circle);}.svgbob .start_marked_open_circle {  marker-start: url(#open_circle);}.svgbob .end_marked_big_open_circle {  marker-end: url(#big_open_circle);}.svgbob .start_marked_big_open_circle {  marker-start: url(#big_open_circle);}</style><defs><marker id="arrow" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,0 0,4 4,2 0,0"></polygon></marker><marker id="diamond" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,2 2,0 4,2 2,4 0,2"></polygon></marker><marker id="circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2" class="filled"></circle></marker><marker id="open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2" class="bg_filled"></circle></marker><marker id="big_open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="3" class="bg_filled"></circle></marker></defs><rect class="backdrop" x="0" y="0" width="512" height="304"></rect><text x="10" y="12" >Stack</text><line x1="24" y1="24" x2="32" y2="24" class="solid"></line><line x1="40" y1="24" x2="48" y2="24" class="solid"></line><text x="282" y="12" >Heap</text><line x1="296" y1="24" x2="304" y2="24" class="solid"></line><line x1="312" y1="24" x2="320" y2="24" class="solid"></line><text x="42" y="60" >s1</text><text x="50" y="92" >ptr</text><line x1="176" y1="88" x2="164" y2="88" class="solid end_marked_open_circle"></line><polygon points="296,84 304,88 296,92" class="filled"></polygon><text x="322" y="92" >R</text><text x="362" y="92" >u</text><text x="402" y="92" >s</text><text x="442" y="92" >t</text><text x="50" y="108" >len</text><text x="178" y="108" >4</text><text x="50" y="124" >capacity</text><text x="178" y="124" >4</text><text x="42" y="172" >s2</text><text x="50" y="204" >ptr</text><line x1="176" y1="200" x2="164" y2="200" class="solid end_marked_open_circle"></line><text x="50" y="220" >len</text><text x="178" y="220" >4</text><text x="50" y="236" >capacity</text><text x="178" y="236" >4</text><line x1="56" y1="24" x2="64" y2="24" class="solid"></line><line x1="72" y1="24" x2="80" y2="24" class="solid"></line><line x1="88" y1="24" x2="96" y2="24" class="solid"></line><line x1="104" y1="24" x2="112" y2="24" class="solid"></line><line x1="120" y1="24" x2="128" y2="24" class="solid"></line><line x1="136" y1="24" x2="144" y2="24" class="solid"></line><line x1="152" y1="24" x2="160" y2="24" class="solid"></line><line x1="168" y1="24" x2="176" y2="24" class="solid"></line><line x1="184" y1="24" x2="192" y2="24" class="solid"></line><line x1="200" y1="24" x2="208" y2="24" class="solid"></line><line x1="328" y1="24" x2="336" y2="24" class="solid"></line><line x1="344" y1="24" x2="352" y2="24" class="solid"></line><line x1="360" y1="24" x2="368" y2="24" class="solid"></line><line x1="376" y1="24" x2="384" y2="24" class="solid"></line><line x1="392" y1="24" x2="400" y2="24" class="solid"></line><line x1="408" y1="24" x2="416" y2="24" class="solid"></line><line x1="424" y1="24" x2="432" y2="24" class="solid"></line><line x1="440" y1="24" x2="448" y2="24" class="solid"></line><line x1="456" y1="24" x2="464" y2="24" class="solid"></line><line x1="472" y1="24" x2="480" y2="24" class="solid"></line><line x1="296" y1="152" x2="304" y2="152" class="solid"></line><line x1="312" y1="152" x2="320" y2="152" class="solid"></line><line x1="328" y1="152" x2="336" y2="152" class="solid"></line><line x1="344" y1="152" x2="352" y2="152" class="solid"></line><line x1="360" y1="152" x2="368" y2="152" class="solid"></line><line x1="376" y1="152" x2="384" y2="152" class="solid"></line><line x1="392" y1="152" x2="400" y2="152" class="solid"></line><line x1="408" y1="152" x2="416" y2="152" class="solid"></line><line x1="424" y1="152" x2="432" y2="152" class="solid"></line><line x1="440" y1="152" x2="448" y2="152" class="solid"></line><line x1="456" y1="152" x2="464" y2="152" class="solid"></line><line x1="472" y1="152" x2="480" y2="152" class="solid"></line><line x1="24" y1="280" x2="32" y2="280" class="solid"></line><line x1="40" y1="280" x2="48" y2="280" class="solid"></line><line x1="56" y1="280" x2="64" y2="280" class="solid"></line><line x1="72" y1="280" x2="80" y2="280" class="solid"></line><line x1="88" y1="280" x2="96" y2="280" class="solid"></line><line x1="104" y1="280" x2="112" y2="280" class="solid"></line><line x1="120" y1="280" x2="128" y2="280" class="solid"></line><line x1="136" y1="280" x2="144" y2="280" class="solid"></line><line x1="152" y1="280" x2="160" y2="280" class="solid"></line><line x1="168" y1="280" x2="176" y2="280" class="solid"></line><line x1="184" y1="280" x2="192" y2="280" class="solid"></line><line x1="200" y1="280" x2="208" y2="280" class="solid"></line><text x="66" y="60" >(inaccessible)</text><g><path d="M 8,24 A 4,4 0,0,0 4,28" class="nofill"></path><line x1="4" y1="28" x2="4" y2="276" class="broken"></line><line x1="8" y1="24" x2="16" y2="24" class="solid"></line><path d="M 4,276 A 4,4 0,0,0 8,280" class="nofill"></path><line x1="8" y1="280" x2="16" y2="280" class="solid"></line></g><g><line x1="216" y1="24" x2="224" y2="24" class="solid"></line><path d="M 224,24 A 4,4 0,0,1 228,28" class="nofill"></path><line x1="228" y1="28" x2="228" y2="276" class="broken"></line><line x1="216" y1="280" x2="224" y2="280" class="solid"></line><path d="M 228,276 A 4,4 0,0,1 224,280" class="nofill"></path></g><g><path d="M 280,24 A 4,4 0,0,0 276,28" class="nofill"></path><line x1="276" y1="28" x2="276" y2="148" class="broken"></line><line x1="280" y1="24" x2="288" y2="24" class="solid"></line><path d="M 276,148 A 4,4 0,0,0 280,152" class="nofill"></path><line x1="280" y1="152" x2="288" y2="152" class="solid"></line></g><g><line x1="36" y1="72" x2="196" y2="72" class="solid"></line><line x1="36" y1="72" x2="36" y2="136" class="solid"></line><line x1="132" y1="72" x2="132" y2="136" class="solid"></line><line x1="196" y1="72" x2="196" y2="136" class="solid"></line><line x1="36" y1="136" x2="196" y2="136" class="solid"></line></g><g><line x1="308" y1="72" x2="468" y2="72" class="solid"></line><line x1="308" y1="72" x2="308" y2="104" class="solid"></line><line x1="348" y1="72" x2="348" y2="104" class="solid"></line><line x1="388" y1="72" x2="388" y2="104" class="solid"></line><line x1="428" y1="72" x2="428" y2="104" class="solid"></line><line x1="468" y1="72" x2="468" y2="104" class="solid"></line><line x1="308" y1="104" x2="468" y2="104" class="solid"></line></g><g><line x1="176" y1="88" x2="296" y2="88" class="solid"></line><line x1="252" y1="88" x2="252" y2="196" class="solid"></line><line x1="176" y1="200" x2="248" y2="200" class="solid"></line><path d="M 252,196 A 4,4 0,0,1 248,200" class="nofill"></path></g><g><line x1="36" y1="184" x2="196" y2="184" class="solid"></line><line x1="36" y1="184" x2="36" y2="248" class="solid"></line><line x1="132" y1="184" x2="132" y2="248" class="solid"></line><line x1="196" y1="184" x2="196" y2="248" class="solid"></line><line x1="36" y1="248" x2="196" y2="248" class="solid"></line></g><g><line x1="488" y1="24" x2="496" y2="24" class="solid"></line><path d="M 496,24 A 4,4 0,0,1 500,28" class="nofill"></path><line x1="500" y1="28" x2="500" y2="148" class="broken"></line><line x1="488" y1="152" x2="496" y2="152" class="solid"></line><path d="M 500,148 A 4,4 0,0,1 496,152" class="nofill"></path></g></svg></div>
<details>
<p><strong>Key points for speakers:</strong></p>
<ul>
<li>This diagram is crucial ‚Äî spend time on it! It shows move semantics visually.</li>
<li>After the move, <code>s1</code> is marked as inaccessible ‚Äî the compiler enforces this.</li>
<li>The heap data is NOT copied ‚Äî just the stack metadata (ptr, len, capacity).</li>
<li>This is &quot;zero-cost&quot; ‚Äî moving is just copying 24 bytes (3 √ó 8 bytes on 64-bit).</li>
</ul>
<p><strong>Common student questions:</strong></p>
<ul>
<li><em>&quot;What happens if I try to use s1 after the move?&quot;</em> - Compile error! Rust prevents use-after-move at compile time.</li>
<li><em>&quot;Why not just copy the data?&quot;</em> - Copying could be expensive for large data. Move is always cheap (fixed size metadata).</li>
<li><em>&quot;Is this like C++ std::move?&quot;</em> - Similar concept, but Rust's move is the default for non-Copy types, and the compiler enforces you can't use the moved-from value.</li>
<li><em>&quot;When would I want to copy instead?&quot;</em> - Use <code>.clone()</code> explicitly when you need independent copies.</li>
</ul>
<p><strong>Teaching tip:</strong>
Walk through what happens at each line: creation, assignment (move), and going out of scope (drop of s2, nothing for s1).</p>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="double-frees-in-modern-c"><a class="header" href="#double-frees-in-modern-c">Double Frees in Modern C++</a></h1>
<p>Modern C++ solves this differently:</p>
<pre><code class="language-c++">std::string s1 = &quot;Cpp&quot;;
std::string s2 = s1;  // Duplicate the data in s1.
</code></pre>
<ul>
<li>The heap data from <code>s1</code> is duplicated and <code>s2</code> gets its own independent copy.</li>
<li>When <code>s1</code> and <code>s2</code> go out of scope, they each free their own memory.</li>
</ul>
<p>Before copy-assignment:</p>
<div style='width:100%; height:192px;'><style type="text/css">svg { width: 100% !important; }</style><svg xmlns="http://www.w3.org/2000/svg" width="480" height="192" class="svgbob"><style>.svgbob line, .svgbob path, .svgbob circle, .svgbob rect, .svgbob polygon {  stroke: var(--fg);  stroke-width: 2;  stroke-opacity: 1;  fill-opacity: 1;  stroke-linecap: round;  stroke-linejoin: miter;}.svgbob text {  white-space: pre;  fill: var(--fg);  font-family: Iosevka Fixed, monospace;  font-size: 14px;}.svgbob rect.backdrop {  stroke: none;  fill: transparent;}.svgbob .broken {  stroke-dasharray: 8;}.svgbob .filled {  fill: black;}.svgbob .bg_filled {  fill: transparent;  stroke-width: 1;}.svgbob .nofill {  fill: transparent;}.svgbob .end_marked_arrow {  marker-end: url(#arrow);}.svgbob .start_marked_arrow {  marker-start: url(#arrow);}.svgbob .end_marked_diamond {  marker-end: url(#diamond);}.svgbob .start_marked_diamond {  marker-start: url(#diamond);}.svgbob .end_marked_circle {  marker-end: url(#circle);}.svgbob .start_marked_circle {  marker-start: url(#circle);}.svgbob .end_marked_open_circle {  marker-end: url(#open_circle);}.svgbob .start_marked_open_circle {  marker-start: url(#open_circle);}.svgbob .end_marked_big_open_circle {  marker-end: url(#big_open_circle);}.svgbob .start_marked_big_open_circle {  marker-start: url(#big_open_circle);}</style><defs><marker id="arrow" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,0 0,4 4,2 0,0"></polygon></marker><marker id="diamond" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,2 2,0 4,2 2,4 0,2"></polygon></marker><marker id="circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2" class="filled"></circle></marker><marker id="open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2" class="bg_filled"></circle></marker><marker id="big_open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="3" class="bg_filled"></circle></marker></defs><rect class="backdrop" x="0" y="0" width="480" height="192"></rect><text x="10" y="12" >Stack</text><line x1="24" y1="24" x2="32" y2="24" class="solid"></line><line x1="40" y1="24" x2="48" y2="24" class="solid"></line><text x="282" y="12" >Heap</text><line x1="296" y1="24" x2="304" y2="24" class="solid"></line><line x1="312" y1="24" x2="320" y2="24" class="solid"></line><text x="42" y="60" >s1</text><text x="50" y="92" >ptr</text><line x1="176" y1="88" x2="164" y2="88" class="solid end_marked_open_circle"></line><line x1="176" y1="88" x2="296" y2="88" class="solid"></line><polygon points="296,84 304,88 296,92" class="filled"></polygon><text x="322" y="92" >C</text><text x="362" y="92" >p</text><text x="402" y="92" >p</text><text x="50" y="108" >len</text><text x="178" y="108" >3</text><text x="50" y="124" >capacity</text><text x="178" y="124" >3</text><line x1="56" y1="24" x2="64" y2="24" class="solid"></line><line x1="72" y1="24" x2="80" y2="24" class="solid"></line><line x1="88" y1="24" x2="96" y2="24" class="solid"></line><line x1="104" y1="24" x2="112" y2="24" class="solid"></line><line x1="120" y1="24" x2="128" y2="24" class="solid"></line><line x1="136" y1="24" x2="144" y2="24" class="solid"></line><line x1="152" y1="24" x2="160" y2="24" class="solid"></line><line x1="168" y1="24" x2="176" y2="24" class="solid"></line><line x1="184" y1="24" x2="192" y2="24" class="solid"></line><line x1="200" y1="24" x2="208" y2="24" class="solid"></line><line x1="328" y1="24" x2="336" y2="24" class="solid"></line><line x1="344" y1="24" x2="352" y2="24" class="solid"></line><line x1="360" y1="24" x2="368" y2="24" class="solid"></line><line x1="376" y1="24" x2="384" y2="24" class="solid"></line><line x1="392" y1="24" x2="400" y2="24" class="solid"></line><line x1="408" y1="24" x2="416" y2="24" class="solid"></line><line x1="424" y1="24" x2="432" y2="24" class="solid"></line><line x1="440" y1="24" x2="448" y2="24" class="solid"></line><line x1="296" y1="152" x2="304" y2="152" class="solid"></line><line x1="312" y1="152" x2="320" y2="152" class="solid"></line><line x1="328" y1="152" x2="336" y2="152" class="solid"></line><line x1="344" y1="152" x2="352" y2="152" class="solid"></line><line x1="360" y1="152" x2="368" y2="152" class="solid"></line><line x1="376" y1="152" x2="384" y2="152" class="solid"></line><line x1="392" y1="152" x2="400" y2="152" class="solid"></line><line x1="408" y1="152" x2="416" y2="152" class="solid"></line><line x1="424" y1="152" x2="432" y2="152" class="solid"></line><line x1="440" y1="152" x2="448" y2="152" class="solid"></line><line x1="24" y1="168" x2="32" y2="168" class="solid"></line><line x1="40" y1="168" x2="48" y2="168" class="solid"></line><line x1="56" y1="168" x2="64" y2="168" class="solid"></line><line x1="72" y1="168" x2="80" y2="168" class="solid"></line><line x1="88" y1="168" x2="96" y2="168" class="solid"></line><line x1="104" y1="168" x2="112" y2="168" class="solid"></line><line x1="120" y1="168" x2="128" y2="168" class="solid"></line><line x1="136" y1="168" x2="144" y2="168" class="solid"></line><line x1="152" y1="168" x2="160" y2="168" class="solid"></line><line x1="168" y1="168" x2="176" y2="168" class="solid"></line><line x1="184" y1="168" x2="192" y2="168" class="solid"></line><line x1="200" y1="168" x2="208" y2="168" class="solid"></line><g><path d="M 8,24 A 4,4 0,0,0 4,28" class="nofill"></path><line x1="4" y1="28" x2="4" y2="164" class="broken"></line><line x1="8" y1="24" x2="16" y2="24" class="solid"></line><path d="M 4,164 A 4,4 0,0,0 8,168" class="nofill"></path><line x1="8" y1="168" x2="16" y2="168" class="solid"></line></g><g><line x1="216" y1="24" x2="224" y2="24" class="solid"></line><path d="M 224,24 A 4,4 0,0,1 228,28" class="nofill"></path><line x1="228" y1="28" x2="228" y2="164" class="broken"></line><line x1="216" y1="168" x2="224" y2="168" class="solid"></line><path d="M 228,164 A 4,4 0,0,1 224,168" class="nofill"></path></g><g><path d="M 280,24 A 4,4 0,0,0 276,28" class="nofill"></path><line x1="276" y1="28" x2="276" y2="148" class="broken"></line><line x1="280" y1="24" x2="288" y2="24" class="solid"></line><path d="M 276,148 A 4,4 0,0,0 280,152" class="nofill"></path><line x1="280" y1="152" x2="288" y2="152" class="solid"></line></g><g><line x1="36" y1="72" x2="196" y2="72" class="solid"></line><line x1="36" y1="72" x2="36" y2="136" class="solid"></line><line x1="132" y1="72" x2="132" y2="136" class="solid"></line><line x1="196" y1="72" x2="196" y2="136" class="solid"></line><line x1="36" y1="136" x2="196" y2="136" class="solid"></line></g><g><line x1="308" y1="72" x2="428" y2="72" class="solid"></line><line x1="308" y1="72" x2="308" y2="104" class="solid"></line><line x1="348" y1="72" x2="348" y2="104" class="solid"></line><line x1="388" y1="72" x2="388" y2="104" class="solid"></line><line x1="428" y1="72" x2="428" y2="104" class="solid"></line><line x1="308" y1="104" x2="428" y2="104" class="solid"></line></g><g><line x1="456" y1="24" x2="464" y2="24" class="solid"></line><path d="M 464,24 A 4,4 0,0,1 468,28" class="nofill"></path><line x1="468" y1="28" x2="468" y2="148" class="broken"></line><line x1="456" y1="152" x2="464" y2="152" class="solid"></line><path d="M 468,148 A 4,4 0,0,1 464,152" class="nofill"></path></g></svg></div>
<p>After copy-assignment:</p>
<div style='width:100%; height:304px;'><style type="text/css">svg { width: 100% !important; }</style><svg xmlns="http://www.w3.org/2000/svg" width="480" height="304" class="svgbob"><style>.svgbob line, .svgbob path, .svgbob circle, .svgbob rect, .svgbob polygon {  stroke: var(--fg);  stroke-width: 2;  stroke-opacity: 1;  fill-opacity: 1;  stroke-linecap: round;  stroke-linejoin: miter;}.svgbob text {  white-space: pre;  fill: var(--fg);  font-family: Iosevka Fixed, monospace;  font-size: 14px;}.svgbob rect.backdrop {  stroke: none;  fill: transparent;}.svgbob .broken {  stroke-dasharray: 8;}.svgbob .filled {  fill: black;}.svgbob .bg_filled {  fill: transparent;  stroke-width: 1;}.svgbob .nofill {  fill: transparent;}.svgbob .end_marked_arrow {  marker-end: url(#arrow);}.svgbob .start_marked_arrow {  marker-start: url(#arrow);}.svgbob .end_marked_diamond {  marker-end: url(#diamond);}.svgbob .start_marked_diamond {  marker-start: url(#diamond);}.svgbob .end_marked_circle {  marker-end: url(#circle);}.svgbob .start_marked_circle {  marker-start: url(#circle);}.svgbob .end_marked_open_circle {  marker-end: url(#open_circle);}.svgbob .start_marked_open_circle {  marker-start: url(#open_circle);}.svgbob .end_marked_big_open_circle {  marker-end: url(#big_open_circle);}.svgbob .start_marked_big_open_circle {  marker-start: url(#big_open_circle);}</style><defs><marker id="arrow" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,0 0,4 4,2 0,0"></polygon></marker><marker id="diamond" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,2 2,0 4,2 2,4 0,2"></polygon></marker><marker id="circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2" class="filled"></circle></marker><marker id="open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2" class="bg_filled"></circle></marker><marker id="big_open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="3" class="bg_filled"></circle></marker></defs><rect class="backdrop" x="0" y="0" width="480" height="304"></rect><text x="10" y="12" >Stack</text><line x1="24" y1="24" x2="32" y2="24" class="solid"></line><line x1="40" y1="24" x2="48" y2="24" class="solid"></line><text x="282" y="12" >Heap</text><line x1="296" y1="24" x2="304" y2="24" class="solid"></line><line x1="312" y1="24" x2="320" y2="24" class="solid"></line><text x="42" y="60" >s1</text><text x="50" y="92" >ptr</text><line x1="176" y1="88" x2="164" y2="88" class="solid end_marked_open_circle"></line><line x1="176" y1="88" x2="296" y2="88" class="solid"></line><polygon points="296,84 304,88 296,92" class="filled"></polygon><text x="322" y="92" >C</text><text x="362" y="92" >p</text><text x="402" y="92" >p</text><text x="50" y="108" >len</text><text x="178" y="108" >3</text><text x="50" y="124" >capacity</text><text x="178" y="124" >3</text><text x="42" y="172" >s2</text><text x="50" y="204" >ptr</text><line x1="176" y1="200" x2="164" y2="200" class="solid end_marked_open_circle"></line><line x1="176" y1="200" x2="296" y2="200" class="solid"></line><polygon points="296,196 304,200 296,204" class="filled"></polygon><text x="322" y="204" >C</text><text x="362" y="204" >p</text><text x="402" y="204" >p</text><text x="50" y="220" >len</text><text x="178" y="220" >3</text><text x="50" y="236" >capacity</text><text x="178" y="236" >3</text><line x1="56" y1="24" x2="64" y2="24" class="solid"></line><line x1="72" y1="24" x2="80" y2="24" class="solid"></line><line x1="88" y1="24" x2="96" y2="24" class="solid"></line><line x1="104" y1="24" x2="112" y2="24" class="solid"></line><line x1="120" y1="24" x2="128" y2="24" class="solid"></line><line x1="136" y1="24" x2="144" y2="24" class="solid"></line><line x1="152" y1="24" x2="160" y2="24" class="solid"></line><line x1="168" y1="24" x2="176" y2="24" class="solid"></line><line x1="184" y1="24" x2="192" y2="24" class="solid"></line><line x1="200" y1="24" x2="208" y2="24" class="solid"></line><line x1="328" y1="24" x2="336" y2="24" class="solid"></line><line x1="344" y1="24" x2="352" y2="24" class="solid"></line><line x1="360" y1="24" x2="368" y2="24" class="solid"></line><line x1="376" y1="24" x2="384" y2="24" class="solid"></line><line x1="392" y1="24" x2="400" y2="24" class="solid"></line><line x1="408" y1="24" x2="416" y2="24" class="solid"></line><line x1="424" y1="24" x2="432" y2="24" class="solid"></line><line x1="440" y1="24" x2="448" y2="24" class="solid"></line><line x1="296" y1="264" x2="304" y2="264" class="solid"></line><line x1="312" y1="264" x2="320" y2="264" class="solid"></line><line x1="328" y1="264" x2="336" y2="264" class="solid"></line><line x1="344" y1="264" x2="352" y2="264" class="solid"></line><line x1="360" y1="264" x2="368" y2="264" class="solid"></line><line x1="376" y1="264" x2="384" y2="264" class="solid"></line><line x1="392" y1="264" x2="400" y2="264" class="solid"></line><line x1="408" y1="264" x2="416" y2="264" class="solid"></line><line x1="424" y1="264" x2="432" y2="264" class="solid"></line><line x1="440" y1="264" x2="448" y2="264" class="solid"></line><line x1="24" y1="280" x2="32" y2="280" class="solid"></line><line x1="40" y1="280" x2="48" y2="280" class="solid"></line><line x1="56" y1="280" x2="64" y2="280" class="solid"></line><line x1="72" y1="280" x2="80" y2="280" class="solid"></line><line x1="88" y1="280" x2="96" y2="280" class="solid"></line><line x1="104" y1="280" x2="112" y2="280" class="solid"></line><line x1="120" y1="280" x2="128" y2="280" class="solid"></line><line x1="136" y1="280" x2="144" y2="280" class="solid"></line><line x1="152" y1="280" x2="160" y2="280" class="solid"></line><line x1="168" y1="280" x2="176" y2="280" class="solid"></line><line x1="184" y1="280" x2="192" y2="280" class="solid"></line><line x1="200" y1="280" x2="208" y2="280" class="solid"></line><g><path d="M 8,24 A 4,4 0,0,0 4,28" class="nofill"></path><line x1="4" y1="28" x2="4" y2="276" class="broken"></line><line x1="8" y1="24" x2="16" y2="24" class="solid"></line><path d="M 4,276 A 4,4 0,0,0 8,280" class="nofill"></path><line x1="8" y1="280" x2="16" y2="280" class="solid"></line></g><g><line x1="216" y1="24" x2="224" y2="24" class="solid"></line><path d="M 224,24 A 4,4 0,0,1 228,28" class="nofill"></path><line x1="228" y1="28" x2="228" y2="276" class="broken"></line><line x1="216" y1="280" x2="224" y2="280" class="solid"></line><path d="M 228,276 A 4,4 0,0,1 224,280" class="nofill"></path></g><g><path d="M 280,24 A 4,4 0,0,0 276,28" class="nofill"></path><line x1="276" y1="28" x2="276" y2="260" class="broken"></line><line x1="280" y1="24" x2="288" y2="24" class="solid"></line><path d="M 276,260 A 4,4 0,0,0 280,264" class="nofill"></path><line x1="280" y1="264" x2="288" y2="264" class="solid"></line></g><g><line x1="36" y1="72" x2="196" y2="72" class="solid"></line><line x1="36" y1="72" x2="36" y2="136" class="solid"></line><line x1="132" y1="72" x2="132" y2="136" class="solid"></line><line x1="196" y1="72" x2="196" y2="136" class="solid"></line><line x1="36" y1="136" x2="196" y2="136" class="solid"></line></g><g><line x1="308" y1="72" x2="428" y2="72" class="solid"></line><line x1="308" y1="72" x2="308" y2="104" class="solid"></line><line x1="348" y1="72" x2="348" y2="104" class="solid"></line><line x1="388" y1="72" x2="388" y2="104" class="solid"></line><line x1="428" y1="72" x2="428" y2="104" class="solid"></line><line x1="308" y1="104" x2="428" y2="104" class="solid"></line></g><g><line x1="36" y1="184" x2="196" y2="184" class="solid"></line><line x1="36" y1="184" x2="36" y2="248" class="solid"></line><line x1="132" y1="184" x2="132" y2="248" class="solid"></line><line x1="196" y1="184" x2="196" y2="248" class="solid"></line><line x1="36" y1="248" x2="196" y2="248" class="solid"></line></g><g><line x1="308" y1="184" x2="428" y2="184" class="solid"></line><line x1="308" y1="184" x2="308" y2="216" class="solid"></line><line x1="348" y1="184" x2="348" y2="216" class="solid"></line><line x1="388" y1="184" x2="388" y2="216" class="solid"></line><line x1="428" y1="184" x2="428" y2="216" class="solid"></line><line x1="308" y1="216" x2="428" y2="216" class="solid"></line></g><g><line x1="456" y1="24" x2="464" y2="24" class="solid"></line><path d="M 464,24 A 4,4 0,0,1 468,28" class="nofill"></path><line x1="468" y1="28" x2="468" y2="260" class="broken"></line><line x1="456" y1="264" x2="464" y2="264" class="solid"></line><path d="M 468,260 A 4,4 0,0,1 464,264" class="nofill"></path></g></svg></div>
<details>
<p><strong>Key points for speakers:</strong></p>
<ul>
<li>C++ copies by default ‚Äî this is safe but can be expensive.</li>
<li>After assignment, <code>s1</code> and <code>s2</code> are completely independent.</li>
<li>This diagram contrasts with Rust's move semantics shown in the previous slide.</li>
<li>C++ requires explicit <code>std::move</code> to get move semantics.</li>
</ul>
<p><strong>Common student questions:</strong></p>
<ul>
<li><em>&quot;Isn't copying safer?&quot;</em> - It avoids some bugs but introduces overhead. For large data, implicit copying is a performance trap.</li>
<li><em>&quot;How does Rust avoid the copy?&quot;</em> - By moving instead. If you need a copy, you explicitly call <code>.clone()</code>.</li>
<li><em>&quot;Can C++ do moves like Rust?&quot;</em> - Yes, with <code>std::move</code>, but C++ doesn't prevent use-after-move. The compiler won't stop you from accessing the moved-from object.</li>
<li><em>&quot;Which is better?&quot;</em> - Rust's approach: safe by default, explicit when you want copies. C++ copies by default, which can be surprising and expensive.</li>
</ul>
<p><strong>Comparison point:</strong>
In Rust, <code>let s2 = s1;</code> moves. In C++, <code>std::string s2 = s1;</code> copies. Different defaults!</p>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="moves-in-function-calls"><a class="header" href="#moves-in-function-calls">Moves in Function Calls</a></h1>
<p>When you pass a value to a function, the value is assigned to the function
parameter. This transfers ownership:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn say_hello(name: String) {
    println!(&quot;Hello {name}&quot;)
}

fn main() {
    let name = String::from(&quot;Alice&quot;);
    say_hello(name);
    // say_hello(name);
}
</code></pre></pre>
<details>
<ul>
<li>With the first call to <code>say_hello</code>, <code>main</code> gives up ownership of <code>name</code>. Afterwards, <code>name</code> cannot be used anymore within <code>main</code>.</li>
<li>The heap memory allocated for <code>name</code> will be freed at the end of the <code>say_hello</code> function.</li>
<li><code>main</code> can retain ownership if it passes <code>name</code> as a reference (<code>&amp;name</code>) and if <code>say_hello</code> accepts a reference as a parameter.</li>
</ul>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn say_hello(name: &amp;String) {
    println!(&quot;Hello {name}&quot;)
}

fn main() {
    let name = String::from(&quot;Alice&quot;);
    say_hello(&amp;name);
    say_hello(&amp;name);
}
</code></pre></pre>
<ul>
<li>Alternatively, <code>main</code> can pass a clone of <code>name</code> in the first call (<code>name.clone()</code>).</li>
</ul>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn say_hello(name: String) {
    println!(&quot;Hello {name}&quot;)
}

fn main() {
    let name = String::from(&quot;Alice&quot;);
    say_hello(name.clone());
    say_hello(name);
}
</code></pre></pre>
<ul>
<li>Rust makes it harder than C++ to inadvertently create copies by making move semantics the default, and by forcing programmers to make clones explicit.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="copying-and-cloning"><a class="header" href="#copying-and-cloning">Copying and Cloning</a></h1>
<p>While move semantics are the default, certain types are copied by default:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let x = 42;
    let y = x;
    println!(&quot;x: {x}&quot;);
    println!(&quot;y: {y}&quot;);
}
</code></pre></pre>
<p>These types implement the <code>Copy</code> trait.</p>
<p>You can opt-in your own types to use copy semantics:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">#[derive(Copy, Clone, Debug)]
struct Point(i32, i32);

fn main() {
    let p1 = Point(3, 4);
    let p2 = p1;
    println!(&quot;p1: {p1:?}&quot;);
    println!(&quot;p2: {p2:?}&quot;);
}
</code></pre></pre>
<ul>
<li>After the assignment, both <code>p1</code> and <code>p2</code> own their own data.</li>
<li>We can also use <code>p1.clone()</code> to explicitly copy the data.</li>
</ul>
<details>
<p>Copying and cloning are not the same thing:</p>
<ul>
<li>Copying refers to bitwise copies of memory regions and does not work on arbitrary objects.</li>
<li>Copying does not allow for custom logic (unlike copy constructors in C++).</li>
<li>Cloning is a more general operation and also allows for custom behavior by implementing the <code>Clone</code> trait.</li>
<li>Copying does not work on types that implement the <code>Drop</code> trait.</li>
</ul>
<p>In the above example, try the following:</p>
<ul>
<li>Add a <code>String</code> field to <code>struct Point</code>. It will not compile because <code>String</code> is not a <code>Copy</code> type.</li>
</ul>
<pre><pre class="playground"><code class="language-rust editable edition2021">#[derive(Copy, Clone, Debug)]
struct Point(i32, i32, String);

fn main() {
    let p1 = Point(3, 4, &quot;Pokemon&quot;);
    let p2 = p1;
    println!(&quot;p1: {p1:?}&quot;);
    println!(&quot;p2: {p2:?}&quot;);
}
</code></pre></pre>
<ul>
<li>Remove <code>Copy</code> from the <code>derive</code> attribute. The compiler error is now in the <code>println!</code> for  <code>p1</code>.</li>
</ul>
<pre><pre class="playground"><code class="language-rust editable edition2021">#[derive(Clone, Debug)]
struct Point(i32, i32, String);

fn main() {
    let p1 = Point(3, 4, String::from(&quot;Pokemon&quot;));
    let p2 = p1;
    println!(&quot;p1: {p1:?}&quot;);
    println!(&quot;p2: {p2:?}&quot;);
}
</code></pre></pre>
<ul>
<li>Show that it works if you clone <code>p1</code> instead.</li>
</ul>
<pre><pre class="playground"><code class="language-rust editable edition2021">#[derive(Clone, Debug)]
struct Point(i32, i32, String);

fn main() {
    let p1 = Point(3, 4, String::from(&quot;Pokemon&quot;));
    let p2 = p1.clone();
    println!(&quot;p1: {p1:?}&quot;);
    println!(&quot;p2: {p2:?}&quot;);
}
</code></pre></pre>
<p>If students ask about <code>derive</code>, it is sufficient to say that this is a way to generate code in Rust
at compile time. In this case the default implementations of <code>Copy</code> and <code>Clone</code> traits are generated.</p>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="borrowing"><a class="header" href="#borrowing">Borrowing</a></h1>
<p>Instead of transferring ownership when calling a function, you can let a
function <em>borrow</em> the value:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">#[derive(Debug)]
struct Point(i32, i32);

fn add(p1: &amp;Point, p2: &amp;Point) -&gt; Point {
    Point(p1.0 + p2.0, p1.1 + p2.1)
}

fn main() {
    let p1 = Point(3, 4);
    let p2 = Point(10, 20);
    let p3 = add(&amp;p1, &amp;p2);
    println!(&quot;{p1:?} + {p2:?} = {p3:?}&quot;);
}
</code></pre></pre>
<ul>
<li>The <code>add</code> function <em>borrows</em> two points and returns a new point.</li>
<li>The caller retains ownership of the inputs.</li>
</ul>
<details>
<p>Notes on stack returns:</p>
<ul>
<li>
<p>Demonstrate that the return from <code>add</code> is cheap because the compiler can eliminate the copy operation. Change the above code to print stack addresses and run it on the <a href="https://play.rust-lang.org/">Playground</a>. In the &quot;DEBUG&quot; optimization level, the addresses should change, while they stay the same when changing to the &quot;RELEASE&quot; setting:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">#[derive(Debug)]
struct Point(i32, i32);

fn add(p1: &amp;Point, p2: &amp;Point) -&gt; Point {
    let p = Point(p1.0 + p2.0, p1.1 + p2.1);
    println!(&quot;&amp;p.0: {:p}&quot;, &amp;p.0);
    p
}

fn main() {
    let p1 = Point(3, 4);
    let p2 = Point(10, 20);
    let p3 = add(&amp;p1, &amp;p2);
    println!(&quot;&amp;p3.0: {:p}&quot;, &amp;p3.0);
    println!(&quot;{p1:?} + {p2:?} = {p3:?}&quot;);
}
</code></pre></pre>
</li>
<li>
<p>The Rust compiler can do return value optimization (RVO).</p>
</li>
</ul>
<p>See <a href="https://darkcoding.net/software/return-value-optimization-in-rust/">Grapham King's &quot;Return Value Optimization in Rust&quot; post</a></p>
<ul>
<li>In C++, copy elision has to be defined in the language specification because constructors can have side effects. In Rust, this is not an issue at all. If RVO did not happen, Rust will always performs a simple and efficient <code>memcpy</code> copy.</li>
</ul>
<p>Elision means dropping, omitting, cutting. It is used for a sound that is not pronounced in a work, for example.</p>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="shared-and-unique-borrows"><a class="header" href="#shared-and-unique-borrows">Shared and Unique Borrows</a></h1>
<p>Rust puts constraints on the ways you can borrow values:</p>
<ul>
<li>You can have one or more <code>&amp;T</code> values at any given time, <em>or</em></li>
<li>You can have exactly one <code>&amp;mut T</code> value.</li>
</ul>
<pre><pre class="playground"><code class="language-rust editable compile_fail edition2021">fn main() {
    let mut a: i32 = 10;
    let b: &amp;i32 = &amp;a;

    {
        let c: &amp;mut i32 = &amp;mut a;
        *c = 20;
    }

    println!(&quot;a: {a}&quot;);
    println!(&quot;b: {b}&quot;);
}
</code></pre></pre>
<details>
<ul>
<li>The above code does not compile because <code>a</code> is borrowed as mutable (through <code>c</code>) and as immutable (through <code>b</code>) at the same time.</li>
<li>Move the <code>println!</code> statement for <code>b</code> before the scope that introduces <code>c</code> to make the code compile.</li>
</ul>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let mut a: i32 = 10;
    let b: &amp;i32 = &amp;a;
    println!(&quot;b: {b}&quot;);
    {
        let c: &amp;mut i32 = &amp;mut a;
        *c = 20;
    }

    println!(&quot;a: {a}&quot;);

}
</code></pre></pre>
<ul>
<li>After that change, the compiler realizes that <code>b</code> is only ever used before the new mutable borrow of <code>a</code> through <code>c</code>. This is a feature of the borrow checker called &quot;non-lexical lifetimes&quot;.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lifetimes"><a class="header" href="#lifetimes">Lifetimes</a></h1>
<p>A borrowed value has a <em>lifetime</em>:</p>
<ul>
<li>The lifetime can be elided: <code>add(p1: &amp;Point, p2: &amp;Point) -&gt; Point</code>.</li>
<li>Lifetimes can also be explicit: <code>&amp;'a Point</code>, <code>&amp;'document str</code>.</li>
<li>Read <code>&amp;'a Point</code> as &quot;a borrowed <code>Point</code> which is valid for at least the
lifetime <code>a</code>&quot;.</li>
<li>Lifetimes are always inferred by the compiler: you cannot assign a lifetime
yourself.
<ul>
<li>Lifetime annotations create constraints; the compiler verifies that there is
a valid solution.</li>
</ul>
</li>
</ul>
<details>
<ul>
<li>Lifetimes help the compiler ensure references don't outlive the data they
refer to.</li>
<li>Most of the time, lifetimes are elided (inferred) and you don't need to write
them.</li>
<li>When the compiler can't infer lifetimes, you must annotate them explicitly.</li>
<li>Lifetime names like <code>'a</code> are arbitrary; <code>'_</code> means &quot;infer this lifetime&quot;.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lifetimes-in-function-calls"><a class="header" href="#lifetimes-in-function-calls">Lifetimes in Function Calls</a></h1>
<p>In addition to borrowing its arguments, a function can return a borrowed value:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">#[derive(Debug)]
struct Point(i32, i32);

fn left_most&lt;'a&gt;(p1: &amp;'a Point, p2: &amp;'a Point) -&gt; &amp;'a Point {
    if p1.0 &lt; p2.0 { p1 } else { p2 }
}

fn main() {
    let p1: Point = Point(10, 10);
    let p2: Point = Point(20, 20);
    let p3: &amp;Point = left_most(&amp;p1, &amp;p2);
    println!(&quot;left-most point: {:?}&quot;, p3);
}
</code></pre></pre>
<ul>
<li><code>'a</code> is a generic parameter, it is inferred by the compiler.</li>
<li>Lifetimes start with <code>'</code> and <code>'a</code> is a typical default name.</li>
<li>Read <code>&amp;'a Point</code> as &quot;a borrowed <code>Point</code> which is valid for at least the
lifetime <code>a</code>&quot;.
<ul>
<li>The <em>at least</em> part is important when parameters are in different scopes.</li>
</ul>
</li>
</ul>
<details>
<p>In the above example, try the following:</p>
<ul>
<li>
<p>Move the declaration of <code>p2</code> and <code>p3</code> into a a new scope (<code>{ ... }</code>), resulting in the following code:</p>
<pre><code class="language-rust ignore">#[derive(Debug)]
struct Point(i32, i32);

fn left_most&lt;'a&gt;(p1: &amp;'a Point, p2: &amp;'a Point) -&gt; &amp;'a Point {
    if p1.0 &lt; p2.0 { p1 } else { p2 }
}

fn main() {
    let p1: Point = Point(10, 10);
    let p3: &amp;Point;
    {
        let p2: Point = Point(20, 20);
        p3 = left_most(&amp;p1, &amp;p2);
    }
    println!(&quot;left-most point: {:?}&quot;, p3);
}
</code></pre>
<p>Note how this does not compile since <code>p3</code> outlives <code>p2</code>.</p>
</li>
<li>
<p>Reset the workspace and change the function signature to <code>fn left_most&lt;'a, 'b&gt;(p1: &amp;'a Point, p2: &amp;'a Point) -&gt; &amp;'b Point</code>. This will not compile because the relationship between the lifetimes <code>'a</code> and <code>'b</code> is unclear.</p>
</li>
<li>
<p>Another way to explain it:</p>
<ul>
<li>Two references to two values are borrowed by a function and the function returns
another reference.</li>
<li>It must have come from one of those two inputs (or from a global variable).</li>
<li>Which one is it? The compiler needs to know, so at the call site the returned reference is not used
for longer than a variable from where the reference came from.</li>
</ul>
</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lifetimes-in-data-structures"><a class="header" href="#lifetimes-in-data-structures">Lifetimes in Data Structures</a></h1>
<p>If a data type stores borrowed data, it must be annotated with a lifetime:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">#[derive(Debug)]
struct Highlight&lt;'doc&gt;(&amp;'doc str);

fn erase(text: String) {
    println!(&quot;Bye {text}!&quot;);
}

fn main() {
    let text = String::from(&quot;The quick brown fox jumps over the lazy dog.&quot;);
    let fox = Highlight(&amp;text[4..19]);
    let dog = Highlight(&amp;text[35..43]);
    // erase(text);
    println!(&quot;{fox:?}&quot;);
    println!(&quot;{dog:?}&quot;);
}
</code></pre></pre>
<details>
<ul>
<li>In the above example, the annotation on <code>Highlight</code> enforces that the data underlying the contained <code>&amp;str</code> lives at least as long as any instance of <code>Highlight</code> that uses that data.</li>
<li>If <code>text</code> is consumed before the end of the lifetime of <code>fox</code> (or <code>dog</code>), the borrow checker throws an error.</li>
<li>Types with borrowed data force users to hold on to the original data. This can be useful for creating lightweight views, but it generally makes them somewhat harder to use.</li>
<li>When possible, make data structures own their data directly.</li>
<li>Some structs with multiple references inside can have more than one lifetime annotation. This can be necessary if there is a need to describe lifetime relationships between the references themselves, in addition to the lifetime of the struct itself. Those are very advanced use cases.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="course-2-exercises"><a class="header" href="#course-2-exercises">Course 2: Exercises</a></h1>
<p>We will look at two things:</p>
<ul>
<li>
<p>A small book library,</p>
</li>
<li>
<p>Iterators and ownership (hard).</p>
</li>
</ul>
<!-- <details>

After looking at the exercises, you can look at the [solutions] provided.

[solutions]: solutions-afternoon.md

</details>
 --><div style="break-before: page; page-break-before: always;"></div><h1 id="designing-a-library"><a class="header" href="#designing-a-library">Designing a Library</a></h1>
<p>We will learn much more about structs and the <code>Vec&lt;T&gt;</code> type later. For now,
you just need to know part of its API:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let mut vec = vec![10, 20];
    vec.push(30);
    println!(&quot;middle value: {}&quot;, vec[vec.len() / 2]);
    for item in vec.iter() {
        println!(&quot;item: {item}&quot;);
    }
}
</code></pre></pre>
<p>Use this to create a library application. Copy the code below to
<a href="https://play.rust-lang.org/">https://play.rust-lang.org/</a> and update the types to make it compile:</p>
<pre><pre class="playground"><code class="language-rust should_panic edition2021">// TODO: remove this when you're done with your implementation.
#![allow(unused_variables, dead_code)]

struct Library {
    books: Vec&lt;Book&gt;,
}

struct Book {
    title: String,
    year: u16,
}

impl Book {
    // This is a constructor, used below.
    fn new(title: &amp;str, year: u16) -&gt; Book {
        Book {
            title: String::from(title),
            year,
        }
    }
}

// This makes it possible to print Book values with {}.
impl std::fmt::Display for Book {
    fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;'_&gt;) -&gt; std::fmt::Result {
        write!(f, &quot;{} ({})&quot;, self.title, self.year)
    }
}

impl Library {
    fn new() -&gt; Library {
        unimplemented!()
    }

    //fn len(self) -&gt; usize {
    //    unimplemented!()
    //}

    //fn is_empty(self) -&gt; bool {
    //    unimplemented!()
    //}

    //fn add_book(self, book: Book) {
    //    unimplemented!()
    //}

    //fn print_books(self) {
    //    unimplemented!()
    //}

    //fn oldest_book(self) -&gt; Option&lt;&amp;Book&gt; {
    //    unimplemented!()
    //}
}

// This shows the desired behavior. Uncomment the code below and
// implement the missing methods. You will need to update the
// method signatures, including the &quot;self&quot; parameter! You may
// also need to update the variable bindings within main.
fn main() {
    let library = Library::new();

    //println!(&quot;Our library is empty: {}&quot;, library.is_empty());
    //
    //library.add_book(Book::new(&quot;Lord of the Rings&quot;, 1954));
    //library.add_book(Book::new(&quot;Alice's Adventures in Wonderland&quot;, 1865));
    //
    //library.print_books();
    //
    //match library.oldest_book() {
    //    Some(book) =&gt; println!(&quot;My oldest book is {book}&quot;),
    //    None =&gt; println!(&quot;My library is empty!&quot;),
    //}
    //
    //println!(&quot;Our library has {} books&quot;, library.len());
}
</code></pre></pre>
<!-- <details>
    
[Solution](solutions-afternoon.md#designing-a-library)

</details>
 --><div style="break-before: page; page-break-before: always;"></div><h1 id="iterators-and-ownership"><a class="header" href="#iterators-and-ownership">Iterators and Ownership</a></h1>
<p>The ownership model of Rust affects many APIs. An example of this is the
<a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html"><code>Iterator</code></a> and
<a href="https://doc.rust-lang.org/std/iter/trait.IntoIterator.html"><code>IntoIterator</code></a>
traits.</p>
<h2 id="iterator"><a class="header" href="#iterator"><code>Iterator</code></a></h2>
<p>Traits are like interfaces: they describe behavior (methods) for a type. The
<code>Iterator</code> trait simply says that you can call <code>next</code> until you get <code>None</code> back:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Iterator {
    type Item;
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;
}
<span class="boring">}
</span></code></pre></pre>
<p>You use this trait like this:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let v: Vec&lt;i8&gt; = vec![10, 20, 30];
    let mut iter = v.iter();

    println!(&quot;v[0]: {:?}&quot;, iter.next());
    println!(&quot;v[1]: {:?}&quot;, iter.next());
    println!(&quot;v[2]: {:?}&quot;, iter.next());
    println!(&quot;No more items: {:?}&quot;, iter.next());
}
</code></pre></pre>
<p>What is the type returned by the iterator? Test your answer here:</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail edition2021">fn main() {
    let v: Vec&lt;i8&gt; = vec![10, 20, 30];
    let mut iter = v.iter();

    let v0: Option&lt;..&gt; = iter.next();
    println!(&quot;v0: {v0:?}&quot;);
}
</code></pre></pre>
<p>Why is this type used?</p>
<h2 id="intoiterator"><a class="header" href="#intoiterator"><code>IntoIterator</code></a></h2>
<p>The <code>Iterator</code> trait tells you how to <em>iterate</em> once you have created an
iterator. The related trait <code>IntoIterator</code> tells you how to create the iterator:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait IntoIterator {
    type Item;
    type IntoIter: Iterator&lt;Item = Self::Item&gt;;

    fn into_iter(self) -&gt; Self::IntoIter;
}
<span class="boring">}
</span></code></pre></pre>
<p>The syntax here means that every implementation of <code>IntoIterator</code> must
declare two types:</p>
<ul>
<li><code>Item</code>: the type we iterate over, such as <code>i8</code>,</li>
<li><code>IntoIter</code>: the <code>Iterator</code> type returned by the <code>into_iter</code> method.</li>
</ul>
<p>Note that <code>IntoIter</code> and <code>Item</code> are linked: the iterator must have the same
<code>Item</code> type, which means that it returns <code>Option&lt;Item&gt;</code></p>
<p>Like before, what  is the type returned by the iterator?</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail edition2021">fn main() {
    let v: Vec&lt;String&gt; = vec![String::from(&quot;foo&quot;), String::from(&quot;bar&quot;)];
    let mut iter = v.into_iter();

    let v0: Option&lt;..&gt; = iter.next();
    println!(&quot;v0: {v0:?}&quot;);
}
</code></pre></pre>
<h2 id="for-loops"><a class="header" href="#for-loops"><code>for</code> Loops</a></h2>
<p>Now that we know both <code>Iterator</code> and <code>IntoIterator</code>, we can build <code>for</code> loops.
They call <code>into_iter()</code> on an expression and iterates over the resulting
iterator:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let v: Vec&lt;String&gt; = vec![String::from(&quot;foo&quot;), String::from(&quot;bar&quot;)];

    for word in &amp;v {
        println!(&quot;word: {word}&quot;);
    }

    for word in v {
        println!(&quot;word: {word}&quot;);
    }
}
</code></pre></pre>
<p>What is the type of <code>word</code> in each loop?</p>
<p>Experiment with the code above and then consult the documentation for <a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#impl-IntoIterator-for-%26%27a%20Vec%3CT%2C%20A%3E"><code>impl IntoIterator for &amp;Vec&lt;T&gt;</code></a>
and <a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#impl-IntoIterator-for-Vec%3CT%2C%20A%3E"><code>impl IntoIterator for Vec&lt;T&gt;</code></a>
to check your answers.</p>
<details>
<p><strong>Exercise guidance for speakers:</strong></p>
<ul>
<li>This exercise builds understanding of ownership in iteration.</li>
<li>Key insight: <code>v.iter()</code> vs <code>v.into_iter()</code> vs <code>&amp;v</code> in for loops.</li>
<li>Students should predict types before running code.</li>
</ul>
<p><strong>Answers to the questions:</strong></p>
<ol>
<li><code>v.iter()</code> returns <code>Option&lt;&amp;i8&gt;</code> ‚Äî borrows elements.</li>
<li><code>v.into_iter()</code> returns <code>Option&lt;String&gt;</code> ‚Äî moves elements (consumes Vec).</li>
<li>First loop: <code>word</code> is <code>&amp;String</code> (borrowed).</li>
<li>Second loop: <code>word</code> is <code>String</code> (moved).</li>
</ol>
<p><strong>Key concepts practiced:</strong></p>
<ol>
<li>The relationship between <code>Iterator</code> and <code>IntoIterator</code>.</li>
<li>How <code>for</code> loops desugar to <code>into_iter()</code> calls.</li>
<li>Borrowing vs moving in iteration.</li>
<li>Associated types in traits.</li>
</ol>
<p><strong>Common student questions:</strong></p>
<ul>
<li><em>&quot;Why can't I use v after the second loop?&quot;</em> ‚Äî <code>into_iter()</code> consumes ownership.</li>
<li><em>&quot;Why use &amp;v instead of v.iter()?&quot;</em> ‚Äî Same result, but <code>&amp;v</code> in <code>for</code> is more idiomatic.</li>
<li><em>&quot;What about iter_mut()?&quot;</em> ‚Äî Gives <code>&amp;mut T</code>, for modifying elements in place.</li>
</ul>
<p><strong>Teaching tip:</strong>
Have students predict the types BEFORE running the code. The &quot;aha moment&quot; comes from seeing the difference between <code>&amp;T</code> and <code>T</code>.</p>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="exercise-builder-type"><a class="header" href="#exercise-builder-type">Exercise: Builder Type</a></h1>
<p>In this example, we will implement a complex data type that owns all of its
data. We will use the &quot;builder pattern&quot; to support building a new value
piece-by-piece, using convenience functions.</p>
<p>Fill in the missing pieces.</p>
<pre><pre class="playground"><code class="language-rust should_panic editable edition2021">#[derive(Debug)]
enum Language {
    Rust,
    Java,
    Perl,
}

#[derive(Clone, Debug)]
struct Dependency {
    name: String,
    version_expression: String,
}

/// A representation of a software package.
#[derive(Debug)]
struct Package {
    name: String,
    version: String,
    authors: Vec&lt;String&gt;,
    dependencies: Vec&lt;Dependency&gt;,
    language: Option&lt;Language&gt;,
}

impl Package {
    /// Return a representation of this package as a dependency, for use in
    /// building other packages.
    fn as_dependency(&amp;self) -&gt; Dependency {
        todo!(&quot;1&quot;)
    }
}

/// A builder for a Package. Use `build()` to create the `Package` itself.
struct PackageBuilder(Package);

impl PackageBuilder {
    fn new(name: impl Into&lt;String&gt;) -&gt; Self {
        todo!(&quot;2&quot;)
    }

    /// Set the package version.
    fn version(mut self, version: impl Into&lt;String&gt;) -&gt; Self {
        self.0.version = version.into();
        self
    }

    /// Set the package authors.
    fn authors(mut self, authors: Vec&lt;String&gt;) -&gt; Self {
        todo!(&quot;3&quot;)
    }

    /// Add an additional dependency.
    fn dependency(mut self, dependency: Dependency) -&gt; Self {
        todo!(&quot;4&quot;)
    }

    /// Set the language. If not set, language defaults to None.
    fn language(mut self, language: Language) -&gt; Self {
        todo!(&quot;5&quot;)
    }

    fn build(self) -&gt; Package {
        self.0
    }
}

fn main() {
    let base64 = PackageBuilder::new(&quot;base64&quot;).version(&quot;0.13&quot;).build();
    dbg!(&amp;base64);
    let log =
        PackageBuilder::new(&quot;log&quot;).version(&quot;0.4&quot;).language(Language::Rust).build();
    dbg!(&amp;log);
    let serde = PackageBuilder::new(&quot;serde&quot;)
        .authors(vec![&quot;djmitche&quot;.into()])
        .version(String::from(&quot;4.0&quot;))
        .dependency(base64.as_dependency())
        .dependency(log.as_dependency())
        .build();
    dbg!(serde);
}
</code></pre></pre>
<details>
<summary>Hints</summary>
<ul>
<li>The builder pattern allows for fluent API design where methods return <code>Self</code>.</li>
<li>Use <code>clone()</code> to create owned copies of String data.</li>
<li>Remember that <code>Option&lt;Language&gt;</code> can be <code>None</code> by default.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="welcome-to-course-3"><a class="header" href="#welcome-to-course-3">Welcome to course 3</a></h1>
<p>Now that we have seen a fair amount of Rust, we will continue with:</p>
<ul>
<li>
<p>Structs, enums, methods.</p>
</li>
<li>
<p>Pattern matching: destructuring enums, structs, and arrays.</p>
</li>
</ul>
<!-- * Control flow constructs: `if`, `if let`, `while`, `while let`, `break`, and
  `continue`.

* The Standard Library: `String`, `Option` and `Result`, `Vec`, `HashMap`, `Rc`
  and `Arc`.

* Modules: visibility, paths, and filesystem hierarchy. -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="structs"><a class="header" href="#structs">Structs</a></h1>
<p>Like C and C++, Rust has support for custom structs:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">struct Person {
    name: String,
    age: u8,
}

fn main() {
    let mut peter = Person {
        name: String::from(&quot;Peter&quot;),
        age: 27,
    };
    println!(&quot;{} is {} years old&quot;, peter.name, peter.age);
    
    peter.age = 28;
    println!(&quot;{} is {} years old&quot;, peter.name, peter.age);
    
    let jackie = Person {
        name: String::from(&quot;Jackie&quot;),
        ..peter
    };
    println!(&quot;{} is {} years old&quot;, jackie.name, jackie.age);
}
</code></pre></pre>
<details>
Key Points: 
<ul>
<li>Structs work like in C or C++.
<ul>
<li>Like in C++, and unlike in C, no typedef is needed to define a type.</li>
<li>Unlike in C++, there is no inheritance between structs.</li>
</ul>
</li>
<li>Methods are defined in an <code>impl</code> block, which we will see in following slides.</li>
<li>There are different types of structs.
<ul>
<li>Zero-sized structs <code>e.g., struct Foo;</code> `is a structure that does not require any memore. It might be used when implementing a trait on some type but don‚Äôt have any data that you want to store in the value itself.</li>
<li>The next slide will introduce Tuple structs.</li>
</ul>
</li>
<li>.. is an operator that is used for pattern binding here. It performs a &quot;and the rest&quot; pattern binding.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tuple-structs"><a class="header" href="#tuple-structs">Tuple Structs</a></h1>
<p>If the field names are unimportant, you can use a tuple struct:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">struct Point(i32, i32);

fn main() {
    let p = Point(17, 23);
    println!(&quot;({}, {})&quot;, p.0, p.1);
}
</code></pre></pre>
<p>This is often used for single-field wrappers (called newtypes):</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail edition2021">struct PoundOfForce(f64);
struct Newtons(f64);

fn compute_thruster_force() -&gt; PoundOfForce {
    todo!(&quot;Ask a rocket scientist at NASA&quot;)
}

fn set_thruster_force(force: Newtons) {
    // ...
}

fn main() {
    let force = compute_thruster_force();
    set_thruster_force(force);
}

</code></pre></pre>
<details>
<p>Newtypes are a great way to encode additional information about the value in a primitive type, for example:</p>
<ul>
<li>The number is measured in some units: <code>Newtons</code> in the example above.</li>
<li>The value passed some validation when it was created, so you no longer have to validate it again at every use: 'PhoneNumber(String)<code>or</code>OddNumber(u32)`.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="field-shorthand-syntax"><a class="header" href="#field-shorthand-syntax">Field Shorthand Syntax</a></h1>
<p>If you already have variables with the right names, then you can create the
struct using a shorthand:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">#[derive(Debug)]
struct Person {
    name: String,
    age: u8,
}

impl Person {
    fn new(name: String, age: u8) -&gt; Person {
        Person { name, age }
    }
}

fn main() {
    let peter = Person::new(String::from(&quot;Peter&quot;), 27);
    println!(&quot;{peter:?}&quot;);
}
</code></pre></pre>
<details>
<p><code>name</code> and <code>age</code> are field names of the structure and variable names.</p>
<p>The <code>new</code> function could be written using <code>Self</code> as a type, as it is interchangeable with the struct type name</p>
<pre><code class="language-rust ignore">impl Person {
    fn new(name: String, age: u8) -&gt; Self {
        Self { name, age }
    }
}
</code></pre>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="enums"><a class="header" href="#enums">Enums</a></h1>
<p>The <code>enum</code> keyword allows the creation of a type which has a few
different variants:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn generate_random_number() -&gt; i32 {
    4  // Chosen by fair dice roll. Guaranteed to be random.
}

#[derive(Debug)]
enum CoinFlip {
    Heads,
    Tails,
}

fn flip_coin() -&gt; CoinFlip {
    let random_number = generate_random_number();
    if random_number % 2 == 0 {
        return CoinFlip::Heads;
    } else {
        return CoinFlip::Tails;
    }
}

fn main() {
    println!(&quot;You got: {:?}&quot;, flip_coin());
}
</code></pre></pre>
<details>
<p>Key Points:</p>
<ul>
<li>Enumerations allow you to collect a set of values under one type</li>
<li>This page offers an enum type <code>CoinFlip</code> with two variants <code>Heads</code> and <code>Tail</code>. You might note the namespace when using variants.</li>
<li>This might be a good time to compare Structs and Enums:
<ul>
<li>In both, you can have a simple version without fields (unit struct) or one with different types of fields (variant payloads).</li>
<li>In both, associated functions are defined within an <code>impl</code> block.</li>
<li>You could even implement the different variants of an enum with separate structs but then they wouldn‚Äôt be the same type as they would if they were all defined in an enum.</li>
</ul>
</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="variant-payloads"><a class="header" href="#variant-payloads">Variant Payloads</a></h1>
<p>You can define richer enums where the variants carry data. You can then use the
<code>match</code> statement to extract the data from each variant:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">enum WebEvent {
    PageLoad,                 // Variant without payload
    KeyPress(char),           // Tuple struct variant
    Click { x: i64, y: i64 }, // Full struct variant
}

#[rustfmt::skip]
fn inspect(event: WebEvent) {
    match event {
        WebEvent::PageLoad       =&gt; println!(&quot;page loaded&quot;),
        WebEvent::KeyPress(c)    =&gt; println!(&quot;pressed '{c}'&quot;),
        WebEvent::Click { x, y } =&gt; println!(&quot;clicked at x={x}, y={y}&quot;),
    }
}

fn main() {
    let load = WebEvent::PageLoad;
    let press = WebEvent::KeyPress('x');
    let click = WebEvent::Click { x: 20, y: 80 };

    inspect(load);
    inspect(press);
    inspect(click);
}
</code></pre></pre>
<details>
<ul>
<li>In the above example, accessing the <code>char</code> in <code>KeyPress</code>, or <code>x</code> and <code>y</code> in <code>Click</code> only works within a <code>match</code> statement.</li>
<li><code>match</code> inspects a hidden discriminant field in the <code>enum</code>.</li>
</ul>
<!-- * `WebEvent::Click { ... }` is not exactly the same as `WebEvent::Click(Click)` with a top level `struct Click { ... }`. The inlined version cannot implement traits, for example. -->
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="enum-sizes"><a class="header" href="#enum-sizes">Enum Sizes</a></h1>
<p>Rust enums are packed tightly, taking constraints due to alignment into account:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::mem::{align_of, size_of};

macro_rules! dbg_size {
    ($t:ty) =&gt; {
        println!(&quot;{}: size {} bytes, align: {} bytes&quot;,
                 stringify!($t), size_of::&lt;$t&gt;(), align_of::&lt;$t&gt;());
    };
}

enum Foo {
    A,
    B,
}

#[repr(u32)]
enum Bar {
    A,  // 0
    B = 10000,
    C,  // 10001
}

fn main() {
    dbg_size!(Foo);
    dbg_size!(Bar);
    dbg_size!(bool);
    dbg_size!(Option&lt;bool&gt;);
    dbg_size!(&amp;i32);
    dbg_size!(Option&lt;&amp;i32&gt;);
    // dbg_size!(Option&lt;&amp;Foo&gt;);
    // dbg_size!(&amp;Foo);
}
</code></pre></pre>
<ul>
<li>See the <a href="https://doc.rust-lang.org/reference/type-layout.html">Rust Reference</a>.</li>
</ul>
<details>
<p>Key Points:</p>
<ul>
<li>Internally Rust is using a field (discriminant) to keep track of the enum variant.</li>
<li><code>Bar</code> enum demonstrates that there is a way to control the discriminant value and type. If <code>repr</code> is removed, the discriminant type takes 2 bytes, becuase 10001 fits 2 bytes.</li>
<li>As a niche optimization an enum discriminant is merged with the pointer so that <code>Option&lt;&amp;Foo&gt;</code> is the same size as <code>&amp;Foo</code>.</li>
<li><code>Option&lt;bool&gt;</code> is another example of tight packing.</li>
<li>For <a href="https://doc.rust-lang.org/std/option/#representation">some types</a>, Rust guarantees that <code>size_of::&lt;T&gt;()</code> equals <code>size_of::&lt;Option&lt;T&gt;&gt;()</code>.</li>
<li>Zero-sized types allow for efficient implementation of <code>HashSet</code> using <code>HashMap</code> with <code>()</code> as the value.</li>
<li>The ty module defines how rustc represents types internally. https://rustc-dev-guide.rust-lang.org/ty.html</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="methods-1"><a class="header" href="#methods-1">Methods</a></h1>
<p>Rust allows you to associate functions with your new types. You do this with an
<code>impl</code> block:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">#[derive(Debug)]
struct Person {
    name: String,
    age: u8,
}

impl Person {
    fn say_hello(&amp;self) {
        println!(&quot;Hello, my name is {}&quot;, self.name);
    }
}

fn main() {
    let peter = Person {
        name: String::from(&quot;Peter&quot;),
        age: 27,
    };
    peter.say_hello();
}
</code></pre></pre>
<details>
<p>Key Points:</p>
<ul>
<li>Methods versus functions.
<ul>
<li>Methods are called on an instance of a type (such as a struct or enum), the first parameter represents the instance as <code>self</code>.</li>
<li>Developers may choose to use methods to take advantage of method receiver syntax and to help keep them more organized. By using methods we can keep all the implementation code in one predictable place.</li>
</ul>
</li>
<li>Point out the use of the keyword <code>self</code>, a method receiver.<!-- * Show that it is an abbreviated term for `self:&Self` and perhaps show how the struct name could also be used. 
  * Explain that Self is a type alias for the type the `impl` block is in and can be used elsewhere in the block. -->
<ul>
<li>
<p>Explain that Self is a type alias for the type the <code>impl</code> block is in and can be used elsewhere in the block. --&gt;</p>
</li>
<li>
<p>Note how self is used like other structs and dot notation can be used to refer to individual fields.</p>
</li>
<li>
<p>This might be a good time to demonstrate how the <code>&amp;self</code> differs from <code>self</code> by modifying the code and trying to run say_hello twice.</p>
</li>
</ul>
</li>
<li>We describe the distinction between method receivers next.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="method-receiver"><a class="header" href="#method-receiver">Method Receiver</a></h1>
<p>The <code>&amp;self</code> above indicates that the method borrows the object immutably. There
are other possible receivers for a method:</p>
<ul>
<li><code>&amp;self</code>: borrows the object from the caller using a shared and immutable
reference. The object can be used again afterwards.</li>
<li><code>&amp;mut self</code>: borrows the object from the caller using a unique and mutable
reference. The object can be used again afterwards.</li>
<li><code>self</code>: takes ownership of the object and moves it away from the caller. The
method becomes the owner of the object. The object will be dropped (deallocated)
when the method returns, unless its ownership is explicitly
transmitted.</li>
<li><code>mut self</code>: same as above, but while the method owns the object, it can
mutate it too. Complete ownership does not automatically mean mutability.</li>
<li>No receiver: this becomes a static method on the struct. Typically used to
create constructors which are called <code>new</code> by convention.</li>
</ul>
<p>Beyond variants on <code>self</code>, there are also
<a href="https://doc.rust-lang.org/reference/special-types-and-traits.html">special wrapper types</a>
allowed to be receiver types, such as <code>Box&lt;Self&gt;</code>.</p>
<details>
<p>Consider emphasizing on &quot;shared and immutable&quot; and &quot;unique and mutable&quot;. These constraints always come
together in Rust due to borrow checker rules, and <code>self</code> is no exception. It won't be possible to
reference a struct from multiple locations and call a mutating (<code>&amp;mut self</code>) method on it.</p>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="example"><a class="header" href="#example">Example</a></h1>
<pre><pre class="playground"><code class="language-rust editable edition2021">#[derive(Debug)]
struct Race {
    name: String,
    laps: Vec&lt;i32&gt;,
}

impl Race {
    fn new(name: &amp;str) -&gt; Race {  // No receiver, a static method
        Race { name: String::from(name), laps: Vec::new() }
    }

    fn add_lap(&amp;mut self, lap: i32) {  // Exclusive borrowed read-write access to self
        self.laps.push(lap);
    }

    fn print_laps(&amp;self) {  // Shared and read-only borrowed access to self
        println!(&quot;Recorded {} laps for {}:&quot;, self.laps.len(), self.name);
        for (idx, lap) in self.laps.iter().enumerate() {
            println!(&quot;Lap {idx}: {lap} sec&quot;);
        }
    }

    fn finish(self) {  // Exclusive ownership of self
        let total = self.laps.iter().sum::&lt;i32&gt;();
        println!(&quot;Race {} is finished, total lap time: {}&quot;, self.name, total);
    }
}

fn main() {
    let mut race = Race::new(&quot;Monaco Grand Prix&quot;);
    race.add_lap(70);
    race.add_lap(68);
    race.print_laps();
    race.add_lap(71);
    race.print_laps();
    race.finish();
    // race.add_lap(42);
}
</code></pre></pre>
<details>
<p>Key Points:</p>
<ul>
<li>All four methods here use a different method receiver.
<ul>
<li>You can point out how that changes what the function can do with the variable values and if/how it can be used again in <code>main</code>.</li>
<li>You can showcase the error that appears when trying to call <code>finish</code> twice.</li>
</ul>
</li>
<li>Note, that although the method receivers are different, the non-static functions are called the same way in the main body. Rust enables automatic referencing and dereferencing when calling methods. Rust automatically adds in the <code>&amp;</code>, <code>*</code>, <code>muts</code> so that that object matches the method signature.</li>
<li>You might point out that <code>print_laps</code> is using a vector that is iterated over. We describe vectors in more detail in course 4.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pattern-matching"><a class="header" href="#pattern-matching">Pattern Matching</a></h1>
<p>The <code>match</code> keyword let you match a value against one or more <em>patterns</em>. The
comparisons are done from top to bottom and the first match wins.</p>
<p>The patterns can be simple values, similarly to <code>switch</code> in C and C++:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let input = 'x';

    match input {
        'q'                   =&gt; println!(&quot;Quitting&quot;),
        'a' | 's' | 'w' | 'd' =&gt; println!(&quot;Moving around&quot;),
        '0'..='9'             =&gt; println!(&quot;Number input&quot;),
        _                     =&gt; println!(&quot;Something else&quot;),
    }
}
</code></pre></pre>
<p>The <code>_</code> pattern is a wildcard pattern which matches any value.</p>
<details>
<p>Key Points:</p>
<ul>
<li>You might point out how some specific characters are being used when in a patten
<ul>
<li><code>|</code> as an <code>or</code></li>
<li><code>..</code> can expand as much as it needs to be</li>
<li><code>1..=5</code> represents an inclusive range</li>
<li><code>_</code> is a wild card</li>
</ul>
</li>
<li>It can be useful to show how binding works, by for instance replacing a wildcard character with a variable, or removing the quotes around <code>q</code>.</li>
<li>You can demonstrate matching on a reference.</li>
<li>This might be a good time to bring up the concept of irrefutable patterns, as the term can show up in error messages.</li>
</ul>
<p>From <a href="https://doc.rust-lang.org/book/ch18-02-refutability.html">Rust Book</a></p>
<p>&quot;Patterns that will match for any possible value passed are irrefutable. An example would be x in the statement let x = 5; because x matches anything and therefore cannot fail to match. Patterns that can fail to match for some possible value are refutable. An example would be Some(x) in the expression if let Some(x) = a_value because if the value in the a_value variable is None rather than Some, the Some(x) pattern will not match.&quot;</p>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="destructuring-enums"><a class="header" href="#destructuring-enums">Destructuring Enums</a></h1>
<p>Patterns can also be used to bind variables to parts of your values. This is how
you inspect the structure of your types. Let us start with a simple <code>enum</code> type:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">enum Result {
    Ok(i32),
    Err(String),
}

fn divide_in_two(n: i32) -&gt; Result {
    if n % 2 == 0 {
        Result::Ok(n / 2)
    } else {
        Result::Err(format!(&quot;cannot divide {n} into two equal parts&quot;))
    }
}

fn main() {
    let n = 100;
    match divide_in_two(n) {
        Result::Ok(half) =&gt; println!(&quot;{n} divided in two is {half}&quot;),
        Result::Err(msg) =&gt; println!(&quot;sorry, an error happened: {msg}&quot;),
    }
}
</code></pre></pre>
<p>Here we have used the arms to <em>destructure</em> the <code>Result</code> value. In the first
arm, <code>half</code> is bound to the value inside the <code>Ok</code> variant. In the second arm,
<code>msg</code> is bound to the error message.</p>
<details>
<p>Key points:</p>
<ul>
<li>The <code>if</code>/<code>else</code> expression is returning an enum that is later unpacked with a <code>match</code>.</li>
<li>You can try adding a third variant to the enum definition and displaying the errors when running the code. Point out the places where your code is now inexhaustive and how the compiler tries to give you hints.</li>
</ul>
<pre><pre class="playground"><code class="language-rust editable edition2021">enum Result {
    Ok(i32),
    Err(String),
    Add(i32),
}

fn divide_in_two(n: i32) -&gt; Result {
    if n % 2 == 0 {
        Result::Ok(n / 2)
    } else {
        Result::Err(format!(&quot;cannot divide {n} into two equal parts&quot;))
    }
}

fn main() {
    let n = 99;
    match divide_in_two(n) {
        Result::Ok(half) =&gt; println!(&quot;{n} divided in two is {half}&quot;),
        Result::Err(msg) =&gt; println!(&quot;sorry, an error happened: {msg}&quot;),
        Result::Add(a) =&gt; println!(&quot;{}&quot;,a)
    }
}
</code></pre></pre>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="destructuring-structs"><a class="header" href="#destructuring-structs">Destructuring Structs</a></h1>
<p>You can also destructure <code>structs</code>:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">struct Foo {
    x: (u32, u32),
    y: u32,
}

#[rustfmt::skip]
fn main() {
    let foo = Foo { x: (1, 2), y: 3 };
    match foo {
        Foo { x: (1, b), y } =&gt; println!(&quot;x.0 = 1, b = {b}, y = {y}&quot;),
        Foo { y: 2, x: i }   =&gt; println!(&quot;y = 2, i = {i:?}&quot;),
        Foo { y, .. }        =&gt; println!(&quot;y = {y}, other fields were ignored&quot;),
    }
}
</code></pre></pre>
<details>
<ul>
<li><code>#[rustfmt::skip]</code> disables rust formatting for the following block of code</li>
</ul>
</details><div style="break-before: page; page-break-before: always;"></div><h1 id="destructuring-arrays"><a class="header" href="#destructuring-arrays">Destructuring Arrays</a></h1>
<p>You can destructure arrays, tuples, and slices by matching on their elements:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">#[rustfmt::skip]
fn main() {
    let triple = [0, -2, 3];
    println!(&quot;Tell me about {triple:?}&quot;);
    match triple {
        [0, y, z] =&gt; println!(&quot;First is 0, y = {y}, and z = {z}&quot;),
        [1, ..]   =&gt; println!(&quot;First is 1 and the rest were ignored&quot;),
        _         =&gt; println!(&quot;All elements were ignored&quot;),
    }
}
</code></pre></pre>
<details>
<p><strong>Key points for speakers:</strong></p>
<ul>
<li>Array destructuring works with fixed-size arrays and slices.</li>
<li>Use <code>..</code> to ignore remaining elements (like rest patterns in other languages).</li>
<li>Use <code>_</code> to ignore specific elements you don't need.</li>
<li>Slice patterns can match variable-length data.</li>
</ul>
<p><strong>Common student questions:</strong></p>
<ul>
<li><em>&quot;What's the difference between <code>..</code> and <code>_</code>?&quot;</em> - <code>_</code> ignores exactly one element, <code>..</code> ignores any number (including zero).</li>
<li><em>&quot;Can I bind the rest to a variable?&quot;</em> - Yes! <code>[first, rest @ ..]</code> captures remaining elements in <code>rest</code>.</li>
<li><em>&quot;Does this work with Vec?&quot;</em> - Only via slices. Convert with <code>&amp;vec[..]</code> or <code>vec.as_slice()</code>.</li>
<li><em>&quot;What if the array is too short?&quot;</em> - For fixed patterns, it's a compile error. For slice patterns, the match fails (no panic).</li>
</ul>
<p><strong>Demo extension:</strong></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let arr = [1, 2, 3, 4, 5];
if let [first, middle @ .., last] = arr {
    println!(&quot;first: {first}, middle: {middle:?}, last: {last}&quot;);
}
<span class="boring">}
</span></code></pre></pre>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="match-guards"><a class="header" href="#match-guards">Match Guards</a></h1>
<p>When matching, you can add a <em>guard</em> to a pattern. This is an arbitrary Boolean
expression which will be executed if the pattern matches:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">#[rustfmt::skip]
fn main() {
    let pair = (2, -2);
    println!(&quot;Tell me about {pair:?}&quot;);
    match pair {
        (x, y) if x == y     =&gt; println!(&quot;These are twins&quot;),
        (x, y) if x + y == 0 =&gt; println!(&quot;Antimatter, kaboom!&quot;),
        (x, _) if x % 2 == 1 =&gt; println!(&quot;The first one is odd&quot;),
        _                    =&gt; println!(&quot;No correlation...&quot;),
    }
}
</code></pre></pre>
<details>
<p>Key Points:</p>
<ul>
<li>Match guards as a separate syntax feature are important and necessary.</li>
<li>They are not the same as separate <code>if</code> expression inside of the match arm. An <code>if</code> expression inside of the branch block (after <code>=&gt;</code>) happens after the match arm is selected. Failing the <code>if</code> condition inside of that block won't result in other arms
of the original <code>match</code> expression being considered.</li>
<li>You can use the variables defined in the pattern in your if expression.</li>
<li>The condition defined in the guard applies to every expression in a pattern with an <code>|</code>.</li>
</ul>
<pre><pre class="playground"><code class="language-rust editable edition2021">#[rustfmt::skip]
fn main() {
    let pair = (1, -2);
    println!(&quot;Tell me about {pair:?}&quot;);
    match pair {
        (x, y) if x == y     =&gt; println!(&quot;These are twins&quot;),
        (x, y) if x + y == 0 =&gt; println!(&quot;Antimatter, kaboom!&quot;),
        (x, _) | (x, -2) if x % 2 == 1 =&gt; println!(&quot;The first one is odd&quot;),
        _                    =&gt; println!(&quot;No correlation...&quot;),
    }
}
</code></pre></pre>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="course-3-exercises"><a class="header" href="#course-3-exercises">Course 3: Exercises</a></h1>
<p>We will look at implementing methods in two contexts:</p>
<ul>
<li>
<p>Simple struct which tracks health statistics.</p>
</li>
<li>
<p>Multiple structs and enums for a drawing library.</p>
</li>
</ul>
<!-- <details>

After looking at the exercises, you can look at the [solutions] provided.

[solutions]: solutions-morning.md

</details> -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="health-statistics"><a class="header" href="#health-statistics">Health Statistics</a></h1>
<p>You're working on implementing a health-monitoring system. As part of that, you
need to keep track of users' health statistics.</p>
<p>You'll start with some stubbed functions in an <code>impl</code> block as well as a <code>User</code>
struct definition. Your goal is to implement the stubbed out methods on the
<code>User</code> <code>struct</code> defined in the <code>impl</code> block.</p>
<p>Copy the code below to <a href="https://play.rust-lang.org/">https://play.rust-lang.org/</a> and fill in the missing
methods:</p>
<pre><pre class="playground"><code class="language-rust should_panic edition2021">// TODO: remove this when you're done with your implementation.
#![allow(unused_variables, dead_code)]

struct User {
    name: String,
    age: u32,
    weight: f32,
}

impl User {
    pub fn new(name: String, age: u32, weight: f32) -&gt; Self {
        unimplemented!()
    }

    pub fn name(&amp;self) -&gt; &amp;str {
        unimplemented!()
    }

    pub fn age(&amp;self) -&gt; u32 {
        unimplemented!()
    }

    pub fn weight(&amp;self) -&gt; f32 {
        unimplemented!()
    }

    pub fn set_age(&amp;mut self, new_age: u32) {
        unimplemented!()
    }

    pub fn set_weight(&amp;mut self, new_weight: f32) {
        unimplemented!()
    }
}

fn main() {
    let bob = User::new(String::from(&quot;Bob&quot;), 32, 155.2);
    println!(&quot;I'm {} and my age is {}&quot;, bob.name(), bob.age());
}

#[test]
fn test_weight() {
    let bob = User::new(String::from(&quot;Bob&quot;), 32, 155.2);
    assert_eq!(bob.weight(), 155.2);
}

#[test]
fn test_set_age() {
    let mut bob = User::new(String::from(&quot;Bob&quot;), 32, 155.2);
    assert_eq!(bob.age(), 32);
    bob.set_age(33);
    assert_eq!(bob.age(), 33);
}
</code></pre></pre>
<details>
<p><strong>Exercise guidance for speakers:</strong></p>
<ul>
<li>This exercise practices basic struct definitions and methods.</li>
<li>Students implement getters, setters, and a constructor.</li>
<li>Focus on <code>&amp;self</code> vs <code>&amp;mut self</code> for method receivers.</li>
</ul>
<p><strong>Key concepts practiced:</strong></p>
<ol>
<li>Struct definition with named fields.</li>
<li>Constructor pattern (<code>fn new(...) -&gt; Self</code>).</li>
<li>Getter methods (<code>&amp;self</code>) that borrow.</li>
<li>Setter methods (<code>&amp;mut self</code>) that mutate.</li>
<li>Basic lifetime of references returned from getters.</li>
</ol>
<p><strong>Hints to give if stuck:</strong></p>
<ul>
<li><code>name()</code> should return <code>&amp;str</code>, not <code>&amp;String</code> ‚Äî use <code>&amp;self.name</code> or <code>self.name.as_str()</code>.</li>
<li><code>set_age</code> takes <code>&amp;mut self</code> to modify the struct.</li>
<li>The constructor creates a new <code>User</code> with the given values.</li>
</ul>
<p><strong>Discussion points:</strong></p>
<ul>
<li>Why return <code>&amp;str</code> from <code>name()</code> instead of <code>String</code>?</li>
<li>What happens if we try to call <code>set_age</code> on an immutable <code>User</code>?</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="polygon-struct"><a class="header" href="#polygon-struct">Polygon Struct</a></h1>
<p>We will create a <code>Polygon</code> struct which contain some points. Copy the code below
to <a href="https://play.rust-lang.org/">https://play.rust-lang.org/</a> and fill in the missing methods to make the
tests pass:</p>
<pre><pre class="playground"><code class="language-rust edition2021">// TODO: remove this when you're done with your implementation.
#![allow(unused_variables, dead_code)]

pub struct Point {
    // add fields
}

impl Point {
    // add methods
}

pub struct Polygon {
    // add fields
}

impl Polygon {
    // add methods
}

pub struct Circle {
    // add fields
}

impl Circle {
    // add methods
}

pub enum Shape {
    Polygon(Polygon),
    Circle(Circle),
}

#[cfg(test)]
mod tests {
    use super::*;

    fn round_two_digits(x: f64) -&gt; f64 {
        (x * 100.0).round() / 100.0
    }

    #[test]
    fn test_point_magnitude() {
        let p1 = Point::new(12, 13);
        assert_eq!(round_two_digits(p1.magnitude()), 17.69);
    }

    #[test]
    fn test_point_dist() {
        let p1 = Point::new(10, 10);
        let p2 = Point::new(14, 13);
        assert_eq!(round_two_digits(p1.dist(p2)), 5.00);
    }

    #[test]
    fn test_point_add() {
        let p1 = Point::new(16, 16);
        let p2 = p1 + Point::new(-4, 3);
        assert_eq!(p2, Point::new(12, 19));
    }

    #[test]
    fn test_polygon_left_most_point() {
        let p1 = Point::new(12, 13);
        let p2 = Point::new(16, 16);

        let mut poly = Polygon::new();
        poly.add_point(p1);
        poly.add_point(p2);
        assert_eq!(poly.left_most_point(), Some(p1));
    }

    #[test]
    fn test_polygon_iter() {
        let p1 = Point::new(12, 13);
        let p2 = Point::new(16, 16);

        let mut poly = Polygon::new();
        poly.add_point(p1);
        poly.add_point(p2);

        let points = poly.iter().cloned().collect::&lt;Vec&lt;_&gt;&gt;();
        assert_eq!(points, vec![Point::new(12, 13), Point::new(16, 16)]);
    }

    #[test]
    fn test_shape_perimeters() {
        let mut poly = Polygon::new();
        poly.add_point(Point::new(12, 13));
        poly.add_point(Point::new(17, 11));
        poly.add_point(Point::new(16, 16));
        let shapes = vec![
            Shape::from(poly),
            Shape::from(Circle::new(Point::new(10, 20), 5)),
        ];
        let perimeters = shapes
            .iter()
            .map(Shape::perimeter)
            .map(round_two_digits)
            .collect::&lt;Vec&lt;_&gt;&gt;();
        assert_eq!(perimeters, vec![15.48, 31.42]);
    }
}

#[allow(dead_code)]
fn main() {}
</code></pre></pre>
<details>
<p>Since the method signatures are missing from the problem statements, the key part
of the exercise is to specify those correctly.</p>
<p>Other interesting parts of the exercise:</p>
<ul>
<li>Derive a <code>Copy</code> trait for some structs, as in tests the methods sometimes don't borrow their arguments.</li>
<li>Discover that <code>Add</code> trait must be implemented for two objects to be addable via &quot;+&quot;.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="exercise-expression-evaluation"><a class="header" href="#exercise-expression-evaluation">Exercise: Expression Evaluation</a></h1>
<p>Let's write a simple recursive evaluator for arithmetic expressions.</p>
<p>An example of a small arithmetic expression could be <code>10 + 20</code>, which evaluates
to <code>30</code>. We can represent the expression as a tree:</p>
<pre><code>        +
       / \
      10  20
</code></pre>
<p>A bigger and more complex expression would be <code>(10 * 9) + ((3 - 4) * 5)</code>, which
evaluates to <code>85</code>.</p>
<p>In code, we will represent the tree with two types:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">/// An operation to perform on two subexpressions.
#[derive(Debug)]
enum Operation {
    Add,
    Sub,
    Mul,
    Div,
}

/// An expression, in tree form.
#[derive(Debug)]
enum Expression {
    /// An operation on two subexpressions.
    Op { op: Operation, left: Box&lt;Expression&gt;, right: Box&lt;Expression&gt; },

    /// A literal value
    Value(i64),
}
</code></pre></pre>
<p>The <code>Box</code> type here is a smart pointer. An expression can be &quot;boxed&quot; with
<code>Box::new</code> as seen in the tests. To evaluate a boxed expression, use the deref
operator (<code>*</code>) to &quot;unbox&quot; it: <code>eval(*boxed_expr)</code>.</p>
<p>Implement <code>eval</code>. The final product should pass the tests.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">/// An operation to perform on two subexpressions.
#[derive(Debug)]
enum Operation {
    Add,
    Sub,
    Mul,
    Div,
}

/// An expression, in tree form.
#[derive(Debug)]
enum Expression {
    /// An operation on two subexpressions.
    Op { op: Operation, left: Box&lt;Expression&gt;, right: Box&lt;Expression&gt; },

    /// A literal value
    Value(i64),
}

fn eval(e: Expression) -&gt; i64 {
    todo!()
}

#[test]
fn test_value() {
    assert_eq!(eval(Expression::Value(19)), 19);
}

#[test]
fn test_sum() {
    assert_eq!(
        eval(Expression::Op {
            op: Operation::Add,
            left: Box::new(Expression::Value(10)),
            right: Box::new(Expression::Value(20)),
        }),
        30
    );
}

#[test]
fn test_recursion() {
    let term1 = Expression::Op {
        op: Operation::Mul,
        left: Box::new(Expression::Value(10)),
        right: Box::new(Expression::Value(9)),
    };
    let term2 = Expression::Op {
        op: Operation::Mul,
        left: Box::new(Expression::Op {
            op: Operation::Sub,
            left: Box::new(Expression::Value(3)),
            right: Box::new(Expression::Value(4)),
        }),
        right: Box::new(Expression::Value(5)),
    };
    assert_eq!(
        eval(Expression::Op {
            op: Operation::Add,
            left: Box::new(term1),
            right: Box::new(term2),
        }),
        85
    );
}

fn main() {
    let expr = Expression::Op {
        op: Operation::Add,
        left: Box::new(Expression::Value(10)),
        right: Box::new(Expression::Value(20)),
    };
    println!(&quot;{expr:?} = {}&quot;, eval(expr));
}
</code></pre></pre>
<details>
<summary>Hints</summary>
<ul>
<li>Use <code>match</code> to destructure the <code>Expression</code> enum.</li>
<li>For <code>Expression::Value(v)</code>, simply return <code>v</code>.</li>
<li>For <code>Expression::Op</code>, recursively evaluate both sides and apply the operation.</li>
<li>Remember to dereference the boxed expressions with <code>*</code>.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="welcome-to-course-4"><a class="header" href="#welcome-to-course-4">Welcome to course 4</a></h1>
<p>Now that we have seen a fair amount of Rust, we will continue with:</p>
<!-- * Structs, enums, methods.

* Pattern matching: destructuring enums, structs, and arrays. -->
<ul>
<li>
<p>Control flow constructs: <code>if</code>, <code>if let</code>, <code>while</code>, <code>while let</code>, <code>break</code>, and
<code>continue</code>.</p>
</li>
<li>
<p>The Standard Library: <code>String</code>, <code>Option</code> and <code>Result</code>, <code>Vec</code>, <code>HashMap</code>, <code>Rc</code>
and <code>Arc</code>.</p>
</li>
<li>
<p>Modules: visibility, paths, and filesystem hierarchy.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="control-flow"><a class="header" href="#control-flow">Control Flow</a></h1>
<p>As we have seen, <code>if</code> is an expression in Rust. It is used to conditionally
evaluate one of two blocks, but the blocks can have a value which then becomes
the value of the <code>if</code> expression. Other control flow expressions work similarly
in Rust.</p>
<details>
<p><strong>Key points for speakers:</strong></p>
<ul>
<li>In Rust, most control flow constructs are <em>expressions</em>, not just statements.</li>
<li>This means <code>if</code>, <code>match</code>, <code>loop</code> can all return values.</li>
<li>This enables a more functional programming style without sacrificing readability.</li>
</ul>
<p><strong>Common student questions:</strong></p>
<ul>
<li><em>&quot;Why are these expressions instead of statements?&quot;</em> - It reduces the need for mutable variables and makes code more concise.</li>
<li><em>&quot;Do I have to use the return value?&quot;</em> - No, you can ignore it. If branches return <code>()</code> (unit), it works like a traditional statement.</li>
</ul>
<p><strong>Example to show:</strong></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = if condition { 5 } else { 10 };  // No need for ternary operator
<span class="boring">}
</span></code></pre></pre>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="if-let-expressions"><a class="header" href="#if-let-expressions"><code>if let</code> expressions</a></h1>
<p>If you want to match a value against a pattern, you can use <code>if let</code>:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let arg = std::env::args().next();
    if let Some(value) = arg {
        println!(&quot;Program name: {value}&quot;);
    } else {
        println!(&quot;Missing name?&quot;);
    }
}
</code></pre></pre>
<p>See <a href="control-flow/../pattern-matching.html">pattern matching</a> for more details on patterns in
Rust.</p>
<details>
<p><strong>Key points for speakers:</strong></p>
<ul>
<li><code>if let</code> is syntactic sugar for a <code>match</code> with one interesting arm and a wildcard.</li>
<li>Use it when you only care about one pattern and want to ignore the rest.</li>
<li>Can be chained with <code>else if let</code> for multiple patterns.</li>
<li>Unlike <code>match</code>, <code>if let</code> is not exhaustive ‚Äî you don't need to handle all cases.</li>
</ul>
<p><strong>Common student questions:</strong></p>
<ul>
<li><em>&quot;When should I use if let vs match?&quot;</em> - <code>if let</code> for one or two patterns, <code>match</code> for many patterns or when you need exhaustiveness checking.</li>
<li><em>&quot;What about let-else?&quot;</em> - <code>let Some(x) = opt else { return; }</code> is useful for early returns. Available since Rust 1.65.</li>
<li><em>&quot;Can I use if let with Result?&quot;</em> - Yes! <code>if let Ok(value) = result { ... }</code> is common.</li>
<li><em>&quot;Why no guard clauses?&quot;</em> - Design choice for simplicity. Use <code>match</code> if you need guards like <code>Some(x) if x &gt; 5</code>.</li>
</ul>
<p><strong>Demo extension:</strong></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// let-else for early returns
let Some(value) = arg else {
    println!(&quot;Missing name?&quot;);
    return;
};
println!(&quot;Program name: {value}&quot;);
<span class="boring">}
</span></code></pre></pre>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="while-expressions"><a class="header" href="#while-expressions"><code>while</code> expressions</a></h1>
<p>The <code>while</code> keyword works very similar to other languages:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let mut x = 10;
    while x != 1 {
        x = if x % 2 == 0 {
            x / 2
        } else {
            3 * x + 1
        };
    }
    println!(&quot;Final x: {x}&quot;);
}
</code></pre></pre>
<details>
<p><strong>Key points for speakers:</strong></p>
<ul>
<li><code>while</code> works like in most languages ‚Äî nothing surprising here.</li>
<li>The condition must be a <code>bool</code> ‚Äî no truthy/falsy values like in JavaScript.</li>
<li>Rust also has <code>while let</code> for pattern matching in loop conditions.</li>
<li>Notice <code>if</code> is used as an expression inside the loop to assign to <code>x</code>.</li>
</ul>
<p><strong>Common student questions:</strong></p>
<ul>
<li><em>&quot;Can I use integers as conditions like in C?&quot;</em> - No, Rust requires explicit boolean conditions. Use <code>x != 0</code> instead of just <code>x</code>.</li>
<li><em>&quot;What's <code>while let</code>?&quot;</em> - It's like <code>if let</code> but loops: <code>while let Some(x) = iter.next() { ... }</code>. Very useful with iterators and Options.</li>
<li><em>&quot;When should I use <code>while</code> vs <code>loop</code>?&quot;</em> - Use <code>while</code> when you have a clear termination condition. Use <code>loop</code> when you need <code>break</code> with a value or when the exit logic is complex.</li>
</ul>
<p><strong>Demo extension:</strong></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// while let example
let mut stack = vec![1, 2, 3];
while let Some(top) = stack.pop() {
    println!(&quot;{top}&quot;);
}
<span class="boring">}
</span></code></pre></pre>
</details>
```
<div style="break-before: page; page-break-before: always;"></div><h1 id="while-let-expressions"><a class="header" href="#while-let-expressions"><code>while let</code> expressions</a></h1>
<p>Like with <code>if</code>, there is a <code>while let</code> variant which repeatedly tests a value
against a pattern:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let v = vec![10, 20, 30];
    let mut iter = v.into_iter();

    while let Some(x) = iter.next() {
        println!(&quot;x: {x}&quot;);
    }
}
</code></pre></pre>
<p>Here the iterator returned by <code>v.iter()</code> will return a <code>Option&lt;i32&gt;</code> on every
call to <code>next()</code>. It returns <code>Some(x)</code> until it is done, after which it will
return <code>None</code>. The <code>while let</code> lets us keep iterating through all items.</p>
<p>See <a href="control-flow/../pattern-matching.html">pattern matching</a> for more details on patterns in
Rust.</p>
<details>
<ul>
<li>Point out that the <code>while let</code> loop will keep going as long as the value matches the pattern.</li>
<li>You could rewrite the <code>while let</code> loop as an infinite loop with an if statement that breaks when there is no value to unwrap for <code>iter.next()</code>. The <code>while let</code> provides syntactic sugar for the above scenario.</li>
</ul>
<!-- ```rust,editable
fn main() {
    let v = vec![10, 20, 30];
    let mut iter = v.into_iter();

    loop { if let Some(x) = iter.next() {
        println!("x: {x}");
        } else {
            break;
        }
    }
}
``` -->
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="for-expressions"><a class="header" href="#for-expressions"><code>for</code> expressions</a></h1>
<p>The <code>for</code> expression is closely related to the <code>while let</code> expression. It will
automatically call <code>into_iter()</code> on the expression and then iterate over it:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let v = vec![10, 20, 30];

    for x in v {
        println!(&quot;x: {x}&quot;);
    }
    
    for i in (0..10).step_by(2) {
        println!(&quot;i: {i}&quot;);
    }
}
</code></pre></pre>
<p>You can use <code>break</code> and <code>continue</code> here as usual.</p>
<details>
<p><strong>Key points for speakers:</strong></p>
<ul>
<li><code>for x in collection</code> calls <code>into_iter()</code> automatically ‚Äî consumes the collection.</li>
<li>Use <code>&amp;collection</code> or <code>&amp;mut collection</code> to iterate by reference instead.</li>
<li>Ranges like <code>0..10</code> are iterators, not special syntax.</li>
<li>Iterator adapters like <code>step_by</code> chain together.</li>
</ul>
<p><strong>Common student questions:</strong></p>
<ul>
<li><em>&quot;What's the difference between for and while let?&quot;</em> - <code>for</code> is syntactic sugar for <code>while let Some(x) = iter.next()</code>. Use <code>for</code> for clarity.</li>
<li><em>&quot;How do I iterate without consuming?&quot;</em> - Use <code>for x in &amp;v</code> (immutable refs) or <code>for x in &amp;mut v</code> (mutable refs).</li>
<li><em>&quot;Can I get the index?&quot;</em> - Use <code>.enumerate()</code>: <code>for (i, x) in v.iter().enumerate()</code>.</li>
<li><em>&quot;What's <code>0..10</code>?&quot;</em> - A <code>Range&lt;i32&gt;</code> that implements <code>Iterator</code>. <code>0..=10</code> includes the endpoint.</li>
</ul>
<p><strong>Demo variations:</strong></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// By reference (doesn't consume)
for x in &amp;v { println!(&quot;{x}&quot;); }

// With index
for (i, x) in v.iter().enumerate() {
    println!(&quot;{i}: {x}&quot;);
}

// Inclusive range
for i in 0..=10 { /* includes 10 */ }
<span class="boring">}
</span></code></pre></pre>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="loop-expressions"><a class="header" href="#loop-expressions"><code>loop</code> expressions</a></h1>
<p>Finally, there is a <code>loop</code> keyword which creates an endless loop. Here you must
either <code>break</code> or <code>return</code> to stop the loop:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let mut x = 10;
    loop {
        x = if x % 2 == 0 {
            x / 2
        } else {
            3 * x + 1
        };
        if x == 1 {
            break;
        }
    }
    println!(&quot;Final x: {x}&quot;);
}
</code></pre></pre>
<details>
<p><strong>Key points for speakers:</strong></p>
<ul>
<li><code>loop</code> is Rust's infinite loop ‚Äî clearer intent than <code>while true</code>.</li>
<li>The example shows the Collatz conjecture (3n+1 problem) ‚Äî a fun mathematical puzzle.</li>
<li><code>loop</code> can return a value via <code>break value;</code> ‚Äî this is unique to Rust.</li>
<li>The compiler knows <code>loop</code> without <code>break</code> never terminates, enabling special optimizations.</li>
</ul>
<p><strong>Common student questions:</strong></p>
<ul>
<li><em>&quot;Why not just use <code>while true</code>?&quot;</em> - <code>loop</code> has clearer intent and the compiler treats it specially. With <code>while true</code>, the compiler can't always prove the loop runs at least once.</li>
<li><em>&quot;Can loop return a value?&quot;</em> - Yes! Use <code>break value;</code> to return from a loop. All <code>break</code> statements must return the same type.</li>
<li><em>&quot;What's the Collatz conjecture?&quot;</em> - Starting from any positive integer, if even divide by 2, if odd multiply by 3 and add 1. The conjecture says you always reach 1. Unproven!</li>
</ul>
<p><strong>Demo extension:</strong></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let result = loop {
    x = x / 2;
    if x &lt; 10 {
        break x * 2;  // Returns a value!
    }
};
<span class="boring">}
</span></code></pre></pre>
</details>
```
<div style="break-before: page; page-break-before: always;"></div><h1 id="match-expressions"><a class="header" href="#match-expressions"><code>match</code> expressions</a></h1>
<p>The <code>match</code> keyword is used to match a value against one or more patterns. In
that sense, it works like a series of <code>if let</code> expressions:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    match std::env::args().next().as_deref() {
        Some(&quot;cat&quot;) =&gt; println!(&quot;Will do cat things&quot;),
        Some(&quot;ls&quot;)  =&gt; println!(&quot;Will ls some files&quot;),
        Some(&quot;mv&quot;)  =&gt; println!(&quot;Let's move some files&quot;),
        Some(&quot;rm&quot;)  =&gt; println!(&quot;Uh, dangerous!&quot;),
        None        =&gt; println!(&quot;Hmm, no program name?&quot;),
        _           =&gt; println!(&quot;Unknown program name!&quot;),
    }
}
</code></pre></pre>
<p>Like <code>if let</code>, each match arm must have the same type. The type is the last
expression of the block, if any. In the example above, the type is <code>()</code>.</p>
<p>See <a href="control-flow/../pattern-matching.html">pattern matching</a> for more details on patterns in
Rust.</p>
<details>
<p><strong>Key points for speakers:</strong></p>
<ul>
<li><code>match</code> must be exhaustive ‚Äî all possible values must be covered.</li>
<li>The <code>_</code> pattern is a catch-all that matches anything (like <code>default</code> in switch).</li>
<li><code>match</code> is an expression ‚Äî all arms must return the same type.</li>
<li>Pattern matching is one of Rust's most powerful features.</li>
</ul>
<p><strong>Common student questions:</strong></p>
<ul>
<li><em>&quot;How is this different from switch in C/Java?&quot;</em> - No fallthrough (each arm is independent), must be exhaustive, can destructure values, and it's an expression that returns a value.</li>
<li><em>&quot;What does <code>as_deref()</code> do?&quot;</em> - It converts <code>Option&lt;String&gt;</code> to <code>Option&lt;&amp;str&gt;</code>, allowing us to match against string literals.</li>
<li><em>&quot;Why underscore instead of <code>else</code>?&quot;</em> - <code>_</code> is a pattern that matches any value. It's more consistent with Rust's pattern matching system.</li>
<li><em>&quot;What if I forget a case?&quot;</em> - The compiler will error! This is a huge advantage over switch statements.</li>
</ul>
<p><strong>Demo suggestion:</strong>
Show what happens when you remove the <code>_</code> arm ‚Äî the compiler lists all unhandled cases (infinite in this case since it's <code>&amp;str</code>).</p>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="break-and-continue"><a class="header" href="#break-and-continue"><code>break</code> and <code>continue</code></a></h1>
<p>If you want to exit a loop early, use <code>break</code>, if you want to immediately start
the next iteration use <code>continue</code>. Both <code>continue</code> and <code>break</code> can optionally
take a label argument which is used to break out of nested loops:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let v = vec![10, 20, 30];
    let mut iter = v.into_iter();
    'outer: while let Some(x) = iter.next() {
        println!(&quot;x: {x}&quot;);
        let mut i = 0;
        while i &lt; x {
            println!(&quot;x: {x}, i: {i}&quot;);
            i += 1;
            if i == 3 {
                break 'outer;
            }
        }
    }
}
</code></pre></pre>
<p>In this case we break the outer loop after 3 iterations of the inner loop.</p>
<details>
<p><strong>Key points for speakers:</strong></p>
<ul>
<li>Labels start with a single quote (<code>'outer:</code>) ‚Äî don't confuse with lifetime syntax (same notation, different context).</li>
<li>Without labels, <code>break</code> and <code>continue</code> only affect the innermost loop.</li>
<li>Labels are optional but essential for nested loop control.</li>
<li><code>break</code> can also return a value from a <code>loop</code> (covered in loop expressions).</li>
</ul>
<p><strong>Common student questions:</strong></p>
<ul>
<li><em>&quot;Is <code>'outer</code> a lifetime?&quot;</em> - No, it's a loop label. Same syntax, different meaning. Lifetimes appear in type signatures; loop labels appear before loops.</li>
<li><em>&quot;Can I use any name for labels?&quot;</em> - Yes, any valid identifier prefixed with <code>'</code>. Convention is lowercase like <code>'outer</code>, <code>'inner</code>, <code>'main_loop</code>.</li>
<li><em>&quot;Does this exist in other languages?&quot;</em> - Java has labeled break/continue. C doesn't (you'd use <code>goto</code>). Python doesn't have it.</li>
</ul>
<p><strong>Demo suggestion:</strong>
Ask students: &quot;What would happen if we used <code>break</code> without <code>'outer</code>?&quot; (Answer: only the inner loop would exit, and the outer loop would continue with the next value)</p>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="standard-library"><a class="header" href="#standard-library">Standard Library</a></h1>
<p>Rust comes with a standard library which helps establish a set of common types
used by Rust library and programs. This way, two libraries can work together
smoothly because they both use the same <code>String</code> type.</p>
<p>The common vocabulary types include:</p>
<ul>
<li>
<p><a href="std/option-result.html"><code>Option</code> and <code>Result</code></a> types: used for optional values
and <a href="error-handling.html">error handling</a>.</p>
</li>
<li>
<p><a href="std/string.html"><code>String</code></a>: the default string type used for owned data.</p>
</li>
<li>
<p><a href="std/vec.html"><code>Vec</code></a>: a standard extensible vector.</p>
</li>
<li>
<p><a href="std/hashmap.html"><code>HashMap</code></a>: a hash map type with a configurable hashing
algorithm.</p>
</li>
<li>
<p><a href="std/box.html"><code>Box</code></a>: an owned pointer for heap-allocated data.</p>
</li>
<li>
<p><a href="std/rc.html"><code>Rc</code></a>: a shared reference-counted pointer for heap-allocated data.</p>
</li>
</ul>
<details>
<ul>
<li>In fact, Rust contains several layers of the Standard Library: <code>core</code>, <code>alloc</code> and <code>std</code>.</li>
<li><code>core</code> includes the most basic types and functions that don't depend on <code>libc</code>, allocator or
even the presence of an operating system.</li>
<li><code>alloc</code> includes types which require a global heap allocator, such as <code>Vec</code>, <code>Box</code> and <code>Arc</code>.</li>
<li>Embedded Rust applications often only use <code>core</code>, and sometimes <code>alloc</code>.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="option-and-result"><a class="header" href="#option-and-result"><code>Option</code> and <code>Result</code></a></h1>
<p>The types represent optional data:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let numbers = vec![10, 20, 30];
    let first: Option&lt;&amp;i8&gt; = numbers.first();
    println!(&quot;first: {first:?}&quot;);

    let idx: Result&lt;usize, usize&gt; = numbers.binary_search(&amp;10);
    println!(&quot;idx: {idx:?}&quot;);
}
</code></pre></pre>
<details>
<ul>
<li><code>Option</code> and <code>Result</code> are widely used not just in the standard library.</li>
<li><code>Option&lt;&amp;T&gt;</code> has zero space overhead compared to <code>&amp;T</code>.</li>
<li><code>Result</code> is the standard type to implement error handling as we will see in a later course.</li>
<li><code>binary_search</code> returns <code>Result&lt;usize, usize&gt;</code>.
<ul>
<li>If found, <code>Result::Ok</code> holds the index where the element is found.</li>
<li>Otherwise, <code>Result::Err</code> contains the index where such an element should be inserted.</li>
</ul>
</li>
</ul>
<p>The Result enum is defined as follows:</p>
<pre><code>enum Result&lt;T, E&gt; {
    Ok(T),
    Err(E),
}
</code></pre>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="string"><a class="header" href="#string">String</a></h1>
<p><a href="https://doc.rust-lang.org/std/string/struct.String.html"><code>String</code></a> is the standard heap-allocated growable UTF-8 string buffer:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let mut s1 = String::new();
    s1.push_str(&quot;Hello&quot;);
    println!(&quot;s1: len = {}, capacity = {}&quot;, s1.len(), s1.capacity());

    let mut s2 = String::with_capacity(s1.len() + 1);
    s2.push_str(&amp;s1);
    s2.push('!');
    println!(&quot;s2: len = {}, capacity = {}&quot;, s2.len(), s2.capacity());

    let s3 = String::from(&quot;üá®üá≠&quot;);
    println!(&quot;s3: len = {}, number of chars = {}&quot;, s3.len(),
             s3.chars().count());
}
</code></pre></pre>
<p><code>String</code> implements <a href="https://doc.rust-lang.org/std/string/struct.String.html#deref-methods-str"><code>Deref&lt;Target = str&gt;</code></a>, which means that you can call all
<code>str</code> methods on a <code>String</code>.</p>
<details>
<ul>
<li><code>len</code> returns the size of the <code>String</code> in bytes, not its length in characters.</li>
<li><code>chars</code> returns an iterator over the actual characters.</li>
<li><code>String</code> implements <code>Deref&lt;Target = str&gt;</code> which transparently gives it access to <code>str</code>'s methods.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vec"><a class="header" href="#vec"><code>Vec</code></a></h1>
<p><a href="https://doc.rust-lang.org/std/vec/struct.Vec.html"><code>Vec</code></a> is the standard resizable heap-allocated buffer:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let mut v1 = Vec::new();
    v1.push(42);
    println!(&quot;v1: len = {}, capacity = {}&quot;, v1.len(), v1.capacity());

    let mut v2 = Vec::with_capacity(v1.len() + 1);
    v2.extend(v1.iter());
    v2.push(9999);
    println!(&quot;v2: len = {}, capacity = {}&quot;, v2.len(), v2.capacity());
}
</code></pre></pre>
<p><code>Vec</code> implements <a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#deref-methods-%5BT%5D"><code>Deref&lt;Target = [T]&gt;</code></a>, which means that you can call slice
methods on a <code>Vec</code>.</p>
<details>
<ul>
<li>
<p><code>Vec</code> is a type of collection, along with <code>String</code> and <code>HashMap</code>. The data it contains is stored
on the heap. This means the amount of data doesn't need to be  known at compile time. It can grow
or shrink at runtime.</p>
</li>
<li>
<p>Notice how <code>Vec&lt;T&gt;</code> is a generic type too, but you don't have to specify <code>T</code> explicitly. As always
with Rust type inference, the <code>T</code> was established during the first <code>push</code> call.</p>
</li>
<li>
<p><code>vec![...]</code> is a canonical macro to use instead of <code>Vec::new()</code> and it supports adding initial
elements to the vector.</p>
</li>
<li>
<p>To index the vector you use <code>[</code> <code>]</code>, but they will panic if out of bounds. Alternatively, using
<code>get</code> will return an <code>Option</code>. The <code>pop</code> function will remove the last element.</p>
<p><code>println!(&quot;v2: len = {}, capacity = {}, {:?}&quot;, v2.len(), v2.capacity(), v2.get(0));</code>
<code>println!(&quot;{:?}&quot;,v2.pop());</code></p>
</li>
<li>
<p>Show iterating over a vector and mutating the value:
<code>for e in &amp;mut v { *e += 50; }</code></p>
</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hashmap"><a class="header" href="#hashmap"><code>HashMap</code></a></h1>
<p>Standard hash map with protection against HashDoS attacks:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::collections::HashMap;

fn main() {
    let mut page_counts = HashMap::new();
    page_counts.insert(&quot;Adventures of Huckleberry Finn&quot;.to_string(), 207);
    page_counts.insert(&quot;Grimms' Fairy Tales&quot;.to_string(), 751);
    page_counts.insert(&quot;Pride and Prejudice&quot;.to_string(), 303);

    if !page_counts.contains_key(&quot;Les Mis√©rables&quot;) {
        println!(&quot;We've know about {} books, but not Les Mis√©rables.&quot;,
                 page_counts.len());
    }

    for book in [&quot;Pride and Prejudice&quot;, &quot;Alice's Adventure in Wonderland&quot;] {
        match page_counts.get(book) {
            Some(count) =&gt; println!(&quot;{book}: {count} pages&quot;),
            None =&gt; println!(&quot;{book} is unknown.&quot;)
        }
    }
}
</code></pre></pre>
<details>
<ul>
<li>
<p><code>HashMap</code> is not defined in the prelude and needs to be brought into scope.</p>
</li>
<li>
<p>Try using <code>entry()</code> to insert a value if nothing is found:</p>
<pre><code class="language-rust ignore">let pc = page_counts.entry(&quot;The Hunger Games&quot;.to_string()).or_insert(374);
</code></pre>
</li>
<li>
<p>Unlike <code>vec!</code>, there is no standard <code>hashmap!</code> macro, but since Rust 1.56,
HashMap implements <code>From&lt;[(K, V); N]&gt;</code>:</p>
<pre><code class="language-rust ignore">let page_counts = HashMap::from([
    (&quot;Harry Potter&quot;.to_string(), 336),
    (&quot;The Hunger Games&quot;.to_string(), 374),
]);
</code></pre>
</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="box"><a class="header" href="#box"><code>Box</code></a></h1>
<p><a href="https://doc.rust-lang.org/std/boxed/struct.Box.html"><code>Box</code></a> is an owned pointer to data on the heap:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let five = Box::new(5);
    println!(&quot;five: {}&quot;, *five);
}
</code></pre></pre>
<div style='width:100%; height:176px;'><style type="text/css">svg { width: 100% !important; }</style><svg xmlns="http://www.w3.org/2000/svg" width="288" height="176" class="svgbob"><style>.svgbob line, .svgbob path, .svgbob circle, .svgbob rect, .svgbob polygon {  stroke: var(--fg);  stroke-width: 2;  stroke-opacity: 1;  fill-opacity: 1;  stroke-linecap: round;  stroke-linejoin: miter;}.svgbob text {  white-space: pre;  fill: var(--fg);  font-family: Iosevka Fixed, monospace;  font-size: 14px;}.svgbob rect.backdrop {  stroke: none;  fill: transparent;}.svgbob .broken {  stroke-dasharray: 8;}.svgbob .filled {  fill: black;}.svgbob .bg_filled {  fill: transparent;  stroke-width: 1;}.svgbob .nofill {  fill: transparent;}.svgbob .end_marked_arrow {  marker-end: url(#arrow);}.svgbob .start_marked_arrow {  marker-start: url(#arrow);}.svgbob .end_marked_diamond {  marker-end: url(#diamond);}.svgbob .start_marked_diamond {  marker-start: url(#diamond);}.svgbob .end_marked_circle {  marker-end: url(#circle);}.svgbob .start_marked_circle {  marker-start: url(#circle);}.svgbob .end_marked_open_circle {  marker-end: url(#open_circle);}.svgbob .start_marked_open_circle {  marker-start: url(#open_circle);}.svgbob .end_marked_big_open_circle {  marker-end: url(#big_open_circle);}.svgbob .start_marked_big_open_circle {  marker-start: url(#big_open_circle);}</style><defs><marker id="arrow" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,0 0,4 4,2 0,0"></polygon></marker><marker id="diamond" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,2 2,0 4,2 2,4 0,2"></polygon></marker><marker id="circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2" class="filled"></circle></marker><marker id="open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2" class="bg_filled"></circle></marker><marker id="big_open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="3" class="bg_filled"></circle></marker></defs><rect class="backdrop" x="0" y="0" width="288" height="176"></rect><rect x="36" y="72" width="48" height="32" class="solid nofill" rx="0"></rect><line x1="64" y1="88" x2="52" y2="88" class="solid end_marked_open_circle"></line><line x1="84" y1="80" x2="84" y2="96" class="solid"></line><rect x="196" y="72" width="48" height="32" class="solid nofill" rx="0"></rect><text x="218" y="92" >5</text><text x="10" y="12" >Stack</text><line x1="24" y1="24" x2="32" y2="24" class="solid"></line><line x1="40" y1="24" x2="48" y2="24" class="solid"></line><text x="218" y="12" >Heap</text><line x1="216" y1="24" x2="224" y2="24" class="solid"></line><line x1="232" y1="24" x2="240" y2="24" class="solid"></line><line x1="248" y1="24" x2="256" y2="24" class="solid"></line><line x1="56" y1="24" x2="64" y2="24" class="solid"></line><line x1="72" y1="24" x2="80" y2="24" class="solid"></line><line x1="88" y1="24" x2="96" y2="24" class="solid"></line><line x1="64" y1="88" x2="184" y2="88" class="solid"></line><polygon points="184,84 192,88 184,92" class="filled"></polygon><text x="42" y="60" >five</text><line x1="184" y1="24" x2="192" y2="24" class="solid"></line><line x1="200" y1="24" x2="208" y2="24" class="solid"></line><line x1="24" y1="152" x2="32" y2="152" class="solid"></line><line x1="40" y1="152" x2="48" y2="152" class="solid"></line><line x1="56" y1="152" x2="64" y2="152" class="solid"></line><line x1="72" y1="152" x2="80" y2="152" class="solid"></line><line x1="88" y1="152" x2="96" y2="152" class="solid"></line><line x1="184" y1="152" x2="192" y2="152" class="solid"></line><line x1="200" y1="152" x2="208" y2="152" class="solid"></line><line x1="216" y1="152" x2="224" y2="152" class="solid"></line><line x1="232" y1="152" x2="240" y2="152" class="solid"></line><line x1="248" y1="152" x2="256" y2="152" class="solid"></line><g><path d="M 8,24 A 4,4 0,0,0 4,28" class="nofill"></path><line x1="4" y1="28" x2="4" y2="148" class="broken"></line><line x1="8" y1="24" x2="16" y2="24" class="solid"></line><path d="M 4,148 A 4,4 0,0,0 8,152" class="nofill"></path><line x1="8" y1="152" x2="16" y2="152" class="solid"></line></g><g><line x1="104" y1="24" x2="112" y2="24" class="solid"></line><path d="M 112,24 A 4,4 0,0,1 116,28" class="nofill"></path><line x1="116" y1="28" x2="116" y2="148" class="broken"></line><line x1="104" y1="152" x2="112" y2="152" class="solid"></line><path d="M 116,148 A 4,4 0,0,1 112,152" class="nofill"></path></g><g><path d="M 168,24 A 4,4 0,0,0 164,28" class="nofill"></path><line x1="164" y1="28" x2="164" y2="148" class="broken"></line><line x1="168" y1="24" x2="176" y2="24" class="solid"></line><path d="M 164,148 A 4,4 0,0,0 168,152" class="nofill"></path><line x1="168" y1="152" x2="176" y2="152" class="solid"></line></g><g><line x1="264" y1="24" x2="272" y2="24" class="solid"></line><path d="M 272,24 A 4,4 0,0,1 276,28" class="nofill"></path><line x1="276" y1="28" x2="276" y2="148" class="broken"></line><line x1="264" y1="152" x2="272" y2="152" class="solid"></line><path d="M 276,148 A 4,4 0,0,1 272,152" class="nofill"></path></g></svg></div>
<p><code>Box&lt;T&gt;</code> implements <code>Deref&lt;Target = T&gt;</code>, which means that you can <a href="https://doc.rust-lang.org/std/ops/trait.Deref.html#more-on-deref-coercion">call methods
from <code>T</code> directly on a <code>Box&lt;T&gt;</code></a>.</p>
<details>
<ul>
<li><code>Box</code> is like <code>std::unique_ptr</code> in C++.</li>
<li>In the above example, you can even leave out the <code>*</code> in the <code>println!</code> statement thanks to <code>Deref</code>.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="box-with-recursive-data-structures"><a class="header" href="#box-with-recursive-data-structures">Box with Recursive Data Structures</a></h1>
<p>Recursive data types or data types with dynamic sizes need to use a <code>Box</code>:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">#[derive(Debug)]
enum List&lt;T&gt; {
    Cons(T, Box&lt;List&lt;T&gt;&gt;),
    Nil,
}

fn main() {
    let list: List&lt;i32&gt; = List::Cons(1, Box::new(List::Cons(2, Box::new(List::Nil))));
    println!(&quot;{list:?}&quot;);
}
</code></pre></pre>
<div style='width:100%; height:208px;'><style type="text/css">svg { width: 100% !important; }</style><svg xmlns="http://www.w3.org/2000/svg" width="656" height="208" class="svgbob"><style>.svgbob line, .svgbob path, .svgbob circle, .svgbob rect, .svgbob polygon {  stroke: var(--fg);  stroke-width: 2;  stroke-opacity: 1;  fill-opacity: 1;  stroke-linecap: round;  stroke-linejoin: miter;}.svgbob text {  white-space: pre;  fill: var(--fg);  font-family: Iosevka Fixed, monospace;  font-size: 14px;}.svgbob rect.backdrop {  stroke: none;  fill: transparent;}.svgbob .broken {  stroke-dasharray: 8;}.svgbob .filled {  fill: black;}.svgbob .bg_filled {  fill: transparent;  stroke-width: 1;}.svgbob .nofill {  fill: transparent;}.svgbob .end_marked_arrow {  marker-end: url(#arrow);}.svgbob .start_marked_arrow {  marker-start: url(#arrow);}.svgbob .end_marked_diamond {  marker-end: url(#diamond);}.svgbob .start_marked_diamond {  marker-start: url(#diamond);}.svgbob .end_marked_circle {  marker-end: url(#circle);}.svgbob .start_marked_circle {  marker-start: url(#circle);}.svgbob .end_marked_open_circle {  marker-end: url(#open_circle);}.svgbob .start_marked_open_circle {  marker-start: url(#open_circle);}.svgbob .end_marked_big_open_circle {  marker-end: url(#big_open_circle);}.svgbob .start_marked_big_open_circle {  marker-start: url(#big_open_circle);}</style><defs><marker id="arrow" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,0 0,4 4,2 0,0"></polygon></marker><marker id="diamond" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,2 2,0 4,2 2,4 0,2"></polygon></marker><marker id="circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2" class="filled"></circle></marker><marker id="open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2" class="bg_filled"></circle></marker><marker id="big_open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="3" class="bg_filled"></circle></marker></defs><rect class="backdrop" x="0" y="0" width="656" height="208"></rect><text x="10" y="12" >Stack</text><line x1="24" y1="24" x2="32" y2="24" class="solid"></line><line x1="40" y1="24" x2="48" y2="24" class="solid"></line><text x="266" y="12" >Heap</text><line x1="280" y1="24" x2="288" y2="24" class="solid"></line><line x1="296" y1="24" x2="304" y2="24" class="solid"></line><text x="42" y="60" >list</text><text x="50" y="92" >Tag</text><text x="122" y="92" >Cons</text><polygon points="288,84 296,88 288,92" class="filled"></polygon><text x="314" y="92" >Tag</text><text x="386" y="92" >Cons</text><polygon points="472,84 480,88 472,92" class="filled"></polygon><text x="498" y="92" >Tag</text><text x="570" y="92" >Nil</text><text x="50" y="108" >0</text><text x="122" y="108" >1</text><text x="314" y="108" >0</text><text x="386" y="108" >2</text><line x1="504" y1="96" x2="496" y2="112" class="solid"></line><line x1="512" y1="96" x2="496" y2="128" class="solid"></line><line x1="520" y1="96" x2="504" y2="128" class="solid"></line><line x1="528" y1="96" x2="512" y2="128" class="solid"></line><line x1="536" y1="96" x2="520" y2="128" class="solid"></line><line x1="544" y1="96" x2="528" y2="128" class="solid"></line><line x1="544" y1="112" x2="536" y2="128" class="solid"></line><line x1="576" y1="96" x2="568" y2="112" class="solid"></line><line x1="584" y1="96" x2="568" y2="128" class="solid"></line><line x1="592" y1="96" x2="576" y2="128" class="solid"></line><line x1="600" y1="96" x2="584" y2="128" class="solid"></line><line x1="600" y1="112" x2="592" y2="128" class="solid"></line><text x="50" y="124" >1</text><line x1="136" y1="120" x2="124" y2="120" class="solid end_marked_open_circle"></line><text x="314" y="124" >1</text><line x1="400" y1="120" x2="388" y2="120" class="solid end_marked_open_circle"></line><line x1="56" y1="24" x2="64" y2="24" class="solid"></line><line x1="72" y1="24" x2="80" y2="24" class="solid"></line><line x1="88" y1="24" x2="96" y2="24" class="solid"></line><line x1="104" y1="24" x2="112" y2="24" class="solid"></line><line x1="120" y1="24" x2="128" y2="24" class="solid"></line><line x1="136" y1="24" x2="144" y2="24" class="solid"></line><line x1="152" y1="24" x2="160" y2="24" class="solid"></line><line x1="168" y1="24" x2="176" y2="24" class="solid"></line><line x1="184" y1="24" x2="192" y2="24" class="solid"></line><line x1="312" y1="24" x2="320" y2="24" class="solid"></line><line x1="328" y1="24" x2="336" y2="24" class="solid"></line><line x1="344" y1="24" x2="352" y2="24" class="solid"></line><line x1="360" y1="24" x2="368" y2="24" class="solid"></line><line x1="376" y1="24" x2="384" y2="24" class="solid"></line><line x1="392" y1="24" x2="400" y2="24" class="solid"></line><line x1="408" y1="24" x2="416" y2="24" class="solid"></line><line x1="424" y1="24" x2="432" y2="24" class="solid"></line><line x1="440" y1="24" x2="448" y2="24" class="solid"></line><line x1="456" y1="24" x2="464" y2="24" class="solid"></line><line x1="472" y1="24" x2="480" y2="24" class="solid"></line><line x1="488" y1="24" x2="496" y2="24" class="solid"></line><line x1="504" y1="24" x2="512" y2="24" class="solid"></line><line x1="520" y1="24" x2="528" y2="24" class="solid"></line><line x1="536" y1="24" x2="544" y2="24" class="solid"></line><line x1="552" y1="24" x2="560" y2="24" class="solid"></line><line x1="568" y1="24" x2="576" y2="24" class="solid"></line><line x1="584" y1="24" x2="592" y2="24" class="solid"></line><line x1="600" y1="24" x2="608" y2="24" class="solid"></line><line x1="616" y1="24" x2="624" y2="24" class="solid"></line><line x1="24" y1="184" x2="32" y2="184" class="solid"></line><line x1="40" y1="184" x2="48" y2="184" class="solid"></line><line x1="56" y1="184" x2="64" y2="184" class="solid"></line><line x1="72" y1="184" x2="80" y2="184" class="solid"></line><line x1="88" y1="184" x2="96" y2="184" class="solid"></line><line x1="104" y1="184" x2="112" y2="184" class="solid"></line><line x1="120" y1="184" x2="128" y2="184" class="solid"></line><line x1="136" y1="184" x2="144" y2="184" class="solid"></line><line x1="152" y1="184" x2="160" y2="184" class="solid"></line><line x1="168" y1="184" x2="176" y2="184" class="solid"></line><line x1="184" y1="184" x2="192" y2="184" class="solid"></line><line x1="280" y1="184" x2="288" y2="184" class="solid"></line><line x1="296" y1="184" x2="304" y2="184" class="solid"></line><line x1="312" y1="184" x2="320" y2="184" class="solid"></line><line x1="328" y1="184" x2="336" y2="184" class="solid"></line><line x1="344" y1="184" x2="352" y2="184" class="solid"></line><line x1="360" y1="184" x2="368" y2="184" class="solid"></line><line x1="376" y1="184" x2="384" y2="184" class="solid"></line><line x1="392" y1="184" x2="400" y2="184" class="solid"></line><line x1="408" y1="184" x2="416" y2="184" class="solid"></line><line x1="424" y1="184" x2="432" y2="184" class="solid"></line><line x1="440" y1="184" x2="448" y2="184" class="solid"></line><line x1="456" y1="184" x2="464" y2="184" class="solid"></line><line x1="472" y1="184" x2="480" y2="184" class="solid"></line><line x1="488" y1="184" x2="496" y2="184" class="solid"></line><line x1="504" y1="184" x2="512" y2="184" class="solid"></line><line x1="520" y1="184" x2="528" y2="184" class="solid"></line><line x1="536" y1="184" x2="544" y2="184" class="solid"></line><line x1="552" y1="184" x2="560" y2="184" class="solid"></line><line x1="568" y1="184" x2="576" y2="184" class="solid"></line><line x1="584" y1="184" x2="592" y2="184" class="solid"></line><line x1="600" y1="184" x2="608" y2="184" class="solid"></line><line x1="616" y1="184" x2="624" y2="184" class="solid"></line><g><path d="M 8,24 A 4,4 0,0,0 4,28" class="nofill"></path><line x1="4" y1="28" x2="4" y2="180" class="broken"></line><line x1="8" y1="24" x2="16" y2="24" class="solid"></line><path d="M 4,180 A 4,4 0,0,0 8,184" class="nofill"></path><line x1="8" y1="184" x2="16" y2="184" class="solid"></line></g><g><line x1="200" y1="24" x2="208" y2="24" class="solid"></line><path d="M 208,24 A 4,4 0,0,1 212,28" class="nofill"></path><line x1="212" y1="28" x2="212" y2="180" class="broken"></line><line x1="200" y1="184" x2="208" y2="184" class="solid"></line><path d="M 212,180 A 4,4 0,0,1 208,184" class="nofill"></path></g><g><path d="M 264,24 A 4,4 0,0,0 260,28" class="nofill"></path><line x1="260" y1="28" x2="260" y2="180" class="broken"></line><line x1="264" y1="24" x2="272" y2="24" class="solid"></line><path d="M 260,180 A 4,4 0,0,0 264,184" class="nofill"></path><line x1="264" y1="184" x2="272" y2="184" class="solid"></line></g><g><line x1="36" y1="72" x2="172" y2="72" class="solid"></line><line x1="36" y1="72" x2="36" y2="136" class="solid"></line><line x1="108" y1="72" x2="108" y2="136" class="solid"></line><line x1="172" y1="72" x2="172" y2="136" class="solid"></line><line x1="36" y1="136" x2="172" y2="136" class="solid"></line></g><g><line x1="300" y1="72" x2="444" y2="72" class="solid"></line><line x1="300" y1="72" x2="300" y2="136" class="solid"></line><line x1="372" y1="72" x2="372" y2="136" class="solid"></line><line x1="444" y1="72" x2="444" y2="136" class="solid"></line><line x1="300" y1="136" x2="444" y2="136" class="solid"></line></g><g><line x1="484" y1="72" x2="612" y2="72" class="solid"></line><line x1="484" y1="72" x2="484" y2="136" class="solid"></line><line x1="556" y1="72" x2="556" y2="136" class="solid"></line><line x1="612" y1="72" x2="612" y2="136" class="solid"></line><line x1="484" y1="136" x2="612" y2="136" class="solid"></line></g><g><path d="M 280,88 A 4,4 0,0,0 276,92" class="nofill"></path><line x1="276" y1="92" x2="276" y2="116" class="solid"></line><line x1="280" y1="88" x2="288" y2="88" class="solid"></line><line x1="136" y1="120" x2="272" y2="120" class="solid"></line><path d="M 276,116 A 4,4 0,0,1 272,120" class="nofill"></path></g><g><path d="M 464,88 A 4,4 0,0,0 460,92" class="nofill"></path><line x1="460" y1="92" x2="460" y2="116" class="solid"></line><line x1="464" y1="88" x2="472" y2="88" class="solid"></line><line x1="400" y1="120" x2="456" y2="120" class="solid"></line><path d="M 460,116 A 4,4 0,0,1 456,120" class="nofill"></path></g><g><line x1="632" y1="24" x2="640" y2="24" class="solid"></line><path d="M 640,24 A 4,4 0,0,1 644,28" class="nofill"></path><line x1="644" y1="28" x2="644" y2="180" class="broken"></line><line x1="632" y1="184" x2="640" y2="184" class="solid"></line><path d="M 644,180 A 4,4 0,0,1 640,184" class="nofill"></path></g></svg></div>
<details>
<p>If the <code>Box</code> was not used here and we attempted to embed a <code>List</code> directly into the <code>List</code>,
the compiler would not compute a fixed size of the struct in memory, it would look infinite.</p>
<p><code>Box</code> solves this problem as it has the same size as a regular pointer and just points at the next
element of the <code>List</code> in the heap.</p>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="niche-optimization"><a class="header" href="#niche-optimization">Niche Optimization</a></h1>
<pre><pre class="playground"><code class="language-rust editable edition2021">#[derive(Debug)]
enum List&lt;T&gt; {
    Cons(T, Box&lt;List&lt;T&gt;&gt;),
    Nil,
}

fn main() {
    let list: List&lt;i32&gt; = List::Cons(1, Box::new(List::Cons(2, Box::new(List::Nil))));
    println!(&quot;{list:?}&quot;);
}
</code></pre></pre>
<p>A <code>Box</code> cannot be empty, so the pointer is always valid and non-<code>null</code>. This
allows the compiler to optimize the memory layout:</p>
<div style='width:100%; height:192px;'><style type="text/css">svg { width: 100% !important; }</style><svg xmlns="http://www.w3.org/2000/svg" width="656" height="192" class="svgbob"><style>.svgbob line, .svgbob path, .svgbob circle, .svgbob rect, .svgbob polygon {  stroke: var(--fg);  stroke-width: 2;  stroke-opacity: 1;  fill-opacity: 1;  stroke-linecap: round;  stroke-linejoin: miter;}.svgbob text {  white-space: pre;  fill: var(--fg);  font-family: Iosevka Fixed, monospace;  font-size: 14px;}.svgbob rect.backdrop {  stroke: none;  fill: transparent;}.svgbob .broken {  stroke-dasharray: 8;}.svgbob .filled {  fill: black;}.svgbob .bg_filled {  fill: transparent;  stroke-width: 1;}.svgbob .nofill {  fill: transparent;}.svgbob .end_marked_arrow {  marker-end: url(#arrow);}.svgbob .start_marked_arrow {  marker-start: url(#arrow);}.svgbob .end_marked_diamond {  marker-end: url(#diamond);}.svgbob .start_marked_diamond {  marker-start: url(#diamond);}.svgbob .end_marked_circle {  marker-end: url(#circle);}.svgbob .start_marked_circle {  marker-start: url(#circle);}.svgbob .end_marked_open_circle {  marker-end: url(#open_circle);}.svgbob .start_marked_open_circle {  marker-start: url(#open_circle);}.svgbob .end_marked_big_open_circle {  marker-end: url(#big_open_circle);}.svgbob .start_marked_big_open_circle {  marker-start: url(#big_open_circle);}</style><defs><marker id="arrow" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,0 0,4 4,2 0,0"></polygon></marker><marker id="diamond" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,2 2,0 4,2 2,4 0,2"></polygon></marker><marker id="circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2" class="filled"></circle></marker><marker id="open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2" class="bg_filled"></circle></marker><marker id="big_open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="3" class="bg_filled"></circle></marker></defs><rect class="backdrop" x="0" y="0" width="656" height="192"></rect><text x="10" y="12" >Stack</text><line x1="24" y1="24" x2="32" y2="24" class="solid"></line><line x1="40" y1="24" x2="48" y2="24" class="solid"></line><text x="266" y="12" >Heap</text><line x1="280" y1="24" x2="288" y2="24" class="solid"></line><line x1="296" y1="24" x2="304" y2="24" class="solid"></line><text x="42" y="60" >list</text><text x="50" y="92" >0</text><text x="122" y="92" >1</text><polygon points="288,84 296,88 288,92" class="filled"></polygon><text x="314" y="92" >0</text><text x="394" y="92" >2</text><polygon points="472,84 480,88 472,92" class="filled"></polygon><line x1="504" y1="80" x2="496" y2="96" class="solid"></line><line x1="512" y1="80" x2="504" y2="96" class="solid"></line><line x1="520" y1="80" x2="512" y2="96" class="solid"></line><line x1="528" y1="80" x2="520" y2="96" class="solid"></line><line x1="536" y1="80" x2="528" y2="96" class="solid"></line><line x1="544" y1="80" x2="536" y2="96" class="solid"></line><line x1="576" y1="80" x2="568" y2="96" class="solid"></line><line x1="584" y1="80" x2="576" y2="96" class="solid"></line><line x1="592" y1="80" x2="584" y2="96" class="solid"></line><line x1="600" y1="80" x2="592" y2="96" class="solid"></line><line x1="136" y1="104" x2="124" y2="104" class="solid end_marked_open_circle"></line><line x1="408" y1="104" x2="396" y2="104" class="solid end_marked_open_circle"></line><text x="570" y="108" >null</text><line x1="56" y1="24" x2="64" y2="24" class="solid"></line><line x1="72" y1="24" x2="80" y2="24" class="solid"></line><line x1="88" y1="24" x2="96" y2="24" class="solid"></line><line x1="104" y1="24" x2="112" y2="24" class="solid"></line><line x1="120" y1="24" x2="128" y2="24" class="solid"></line><line x1="136" y1="24" x2="144" y2="24" class="solid"></line><line x1="152" y1="24" x2="160" y2="24" class="solid"></line><line x1="168" y1="24" x2="176" y2="24" class="solid"></line><line x1="184" y1="24" x2="192" y2="24" class="solid"></line><line x1="312" y1="24" x2="320" y2="24" class="solid"></line><line x1="328" y1="24" x2="336" y2="24" class="solid"></line><line x1="344" y1="24" x2="352" y2="24" class="solid"></line><line x1="360" y1="24" x2="368" y2="24" class="solid"></line><line x1="376" y1="24" x2="384" y2="24" class="solid"></line><line x1="392" y1="24" x2="400" y2="24" class="solid"></line><line x1="408" y1="24" x2="416" y2="24" class="solid"></line><line x1="424" y1="24" x2="432" y2="24" class="solid"></line><line x1="440" y1="24" x2="448" y2="24" class="solid"></line><line x1="456" y1="24" x2="464" y2="24" class="solid"></line><line x1="472" y1="24" x2="480" y2="24" class="solid"></line><line x1="488" y1="24" x2="496" y2="24" class="solid"></line><line x1="504" y1="24" x2="512" y2="24" class="solid"></line><line x1="520" y1="24" x2="528" y2="24" class="solid"></line><line x1="536" y1="24" x2="544" y2="24" class="solid"></line><line x1="552" y1="24" x2="560" y2="24" class="solid"></line><line x1="568" y1="24" x2="576" y2="24" class="solid"></line><line x1="584" y1="24" x2="592" y2="24" class="solid"></line><line x1="600" y1="24" x2="608" y2="24" class="solid"></line><line x1="616" y1="24" x2="624" y2="24" class="solid"></line><line x1="24" y1="168" x2="32" y2="168" class="solid"></line><line x1="40" y1="168" x2="48" y2="168" class="solid"></line><line x1="56" y1="168" x2="64" y2="168" class="solid"></line><line x1="72" y1="168" x2="80" y2="168" class="solid"></line><line x1="88" y1="168" x2="96" y2="168" class="solid"></line><line x1="104" y1="168" x2="112" y2="168" class="solid"></line><line x1="120" y1="168" x2="128" y2="168" class="solid"></line><line x1="136" y1="168" x2="144" y2="168" class="solid"></line><line x1="152" y1="168" x2="160" y2="168" class="solid"></line><line x1="168" y1="168" x2="176" y2="168" class="solid"></line><line x1="184" y1="168" x2="192" y2="168" class="solid"></line><line x1="280" y1="168" x2="288" y2="168" class="solid"></line><line x1="296" y1="168" x2="304" y2="168" class="solid"></line><line x1="312" y1="168" x2="320" y2="168" class="solid"></line><line x1="328" y1="168" x2="336" y2="168" class="solid"></line><line x1="344" y1="168" x2="352" y2="168" class="solid"></line><line x1="360" y1="168" x2="368" y2="168" class="solid"></line><line x1="376" y1="168" x2="384" y2="168" class="solid"></line><line x1="392" y1="168" x2="400" y2="168" class="solid"></line><line x1="408" y1="168" x2="416" y2="168" class="solid"></line><line x1="424" y1="168" x2="432" y2="168" class="solid"></line><line x1="440" y1="168" x2="448" y2="168" class="solid"></line><line x1="456" y1="168" x2="464" y2="168" class="solid"></line><line x1="472" y1="168" x2="480" y2="168" class="solid"></line><line x1="488" y1="168" x2="496" y2="168" class="solid"></line><line x1="504" y1="168" x2="512" y2="168" class="solid"></line><line x1="520" y1="168" x2="528" y2="168" class="solid"></line><line x1="536" y1="168" x2="544" y2="168" class="solid"></line><line x1="552" y1="168" x2="560" y2="168" class="solid"></line><line x1="568" y1="168" x2="576" y2="168" class="solid"></line><line x1="584" y1="168" x2="592" y2="168" class="solid"></line><line x1="600" y1="168" x2="608" y2="168" class="solid"></line><line x1="616" y1="168" x2="624" y2="168" class="solid"></line><text x="50" y="108" >1/Tag</text><text x="314" y="108" >1/Tag</text><text x="498" y="108" >1/Tag</text><g><path d="M 8,24 A 4,4 0,0,0 4,28" class="nofill"></path><line x1="4" y1="28" x2="4" y2="164" class="broken"></line><line x1="8" y1="24" x2="16" y2="24" class="solid"></line><path d="M 4,164 A 4,4 0,0,0 8,168" class="nofill"></path><line x1="8" y1="168" x2="16" y2="168" class="solid"></line></g><g><line x1="200" y1="24" x2="208" y2="24" class="solid"></line><path d="M 208,24 A 4,4 0,0,1 212,28" class="nofill"></path><line x1="212" y1="28" x2="212" y2="164" class="broken"></line><line x1="200" y1="168" x2="208" y2="168" class="solid"></line><path d="M 212,164 A 4,4 0,0,1 208,168" class="nofill"></path></g><g><path d="M 264,24 A 4,4 0,0,0 260,28" class="nofill"></path><line x1="260" y1="28" x2="260" y2="164" class="broken"></line><line x1="264" y1="24" x2="272" y2="24" class="solid"></line><path d="M 260,164 A 4,4 0,0,0 264,168" class="nofill"></path><line x1="264" y1="168" x2="272" y2="168" class="solid"></line></g><g><line x1="36" y1="72" x2="172" y2="72" class="solid"></line><line x1="36" y1="72" x2="36" y2="120" class="solid"></line><line x1="108" y1="72" x2="108" y2="120" class="solid"></line><line x1="172" y1="72" x2="172" y2="120" class="solid"></line><line x1="36" y1="120" x2="172" y2="120" class="solid"></line></g><g><line x1="300" y1="72" x2="444" y2="72" class="solid"></line><line x1="300" y1="72" x2="300" y2="120" class="solid"></line><line x1="372" y1="72" x2="372" y2="120" class="solid"></line><line x1="444" y1="72" x2="444" y2="120" class="solid"></line><line x1="300" y1="120" x2="444" y2="120" class="solid"></line></g><g><line x1="484" y1="72" x2="612" y2="72" class="solid"></line><line x1="484" y1="72" x2="484" y2="120" class="solid"></line><line x1="556" y1="72" x2="556" y2="120" class="solid"></line><line x1="612" y1="72" x2="612" y2="120" class="solid"></line><line x1="484" y1="120" x2="612" y2="120" class="solid"></line></g><g><path d="M 280,88 A 4,4 0,0,0 276,92" class="nofill"></path><line x1="276" y1="92" x2="276" y2="100" class="solid"></line><line x1="280" y1="88" x2="288" y2="88" class="solid"></line><line x1="136" y1="104" x2="272" y2="104" class="solid"></line><path d="M 276,100 A 4,4 0,0,1 272,104" class="nofill"></path></g><g><path d="M 464,88 A 4,4 0,0,0 460,92" class="nofill"></path><line x1="460" y1="92" x2="460" y2="100" class="solid"></line><line x1="464" y1="88" x2="472" y2="88" class="solid"></line><line x1="408" y1="104" x2="456" y2="104" class="solid"></line><path d="M 460,100 A 4,4 0,0,1 456,104" class="nofill"></path></g><g><line x1="632" y1="24" x2="640" y2="24" class="solid"></line><path d="M 640,24 A 4,4 0,0,1 644,28" class="nofill"></path><line x1="644" y1="28" x2="644" y2="164" class="broken"></line><line x1="632" y1="168" x2="640" y2="168" class="solid"></line><path d="M 644,164 A 4,4 0,0,1 640,168" class="nofill"></path></g></svg></div>
<details>
<p><strong>Key points for speakers:</strong></p>
<ul>
<li>&quot;Niche optimization&quot; uses invalid bit patterns to store enum discriminants.</li>
<li><code>Box&lt;T&gt;</code> is never null, so the null pointer value represents <code>None</code> in <code>Option&lt;Box&lt;T&gt;&gt;</code>.</li>
<li>This means <code>Option&lt;Box&lt;T&gt;&gt;</code> is the same size as <code>Box&lt;T&gt;</code> ‚Äî zero overhead!</li>
<li>The <code>Nil</code> variant uses null pointer instead of a separate tag byte.</li>
</ul>
<p><strong>Common student questions:</strong></p>
<ul>
<li><em>&quot;What's a niche?&quot;</em> - A bit pattern that's guaranteed to never occur in valid data. Null for pointers, for example.</li>
<li><em>&quot;Does this work with Option?&quot;</em> - Yes! <code>Option&lt;Box&lt;T&gt;&gt;</code>, <code>Option&lt;&amp;T&gt;</code>, <code>Option&lt;NonZeroU32&gt;</code> all benefit.</li>
<li><em>&quot;What's the performance impact?&quot;</em> - None for runtime! It's purely a memory layout optimization.</li>
<li><em>&quot;Do I need to do anything special?&quot;</em> - No, the compiler does this automatically.</li>
</ul>
<p><strong>Example to show:</strong></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>println!(&quot;Size of Box&lt;i32&gt;: {}&quot;, std::mem::size_of::&lt;Box&lt;i32&gt;&gt;());
println!(&quot;Size of Option&lt;Box&lt;i32&gt;&gt;: {}&quot;, std::mem::size_of::&lt;Option&lt;Box&lt;i32&gt;&gt;&gt;());
// Both print 8 on 64-bit!
<span class="boring">}
</span></code></pre></pre>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rc"><a class="header" href="#rc"><code>Rc</code></a></h1>
<p><a href="https://doc.rust-lang.org/std/rc/struct.Rc.html"><code>Rc</code></a> is a reference-counted shared pointer. Use this when you need to refer
to the same data from multiple places:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::rc::Rc;

fn main() {
    let mut a = Rc::new(10);
    let mut b = a.clone();

    println!(&quot;a: {a}&quot;);
    println!(&quot;b: {b}&quot;);
}
</code></pre></pre>
<p>Shared references in Rust disallow mutation by default.
If you need to mutate the data inside an <code>Rc</code>, you will need to wrap the data in
a type such as <a href="https://doc.rust-lang.org/std/cell/index.html"><code>Cell</code> or <code>RefCell</code></a>, in single-threaded cases. See <a href="https://doc.rust-lang.org/std/sync/struct.Arc.html"><code>Arc</code></a> if you are in a multi-threaded
context. Arc stands for &quot;Atomically Reference counted&quot;. If you need to mutate through Arc use <a href="https://doc.rust-lang.org/std/sync/struct.Mutex.html"><code>Mutex</code></a>, <a href="https://doc.rust-lang.org/std/sync/struct.RwLock.html"><code>RwLock</code></a>, or one of the <a href="https://doc.rust-lang.org/std/sync/atomic/index.html"><code>Atomic</code></a> types.</p>
<details>
<ul>
<li>Like C++'s <code>std::shared_ptr</code>.</li>
<li><code>clone</code> is cheap: creates a pointer to the same allocation and increases the reference count.</li>
<li><code>make_mut</code> actually clones the inner value if necessary (&quot;clone-on-write&quot;) and returns a mutable reference.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="iterators"><a class="header" href="#iterators">Iterators</a></h1>
<p>Iterators are a powerful Rust pattern for processing sequences of values.
They are lazy, composable, and highly optimized by the compiler.</p>
<details>
<ul>
<li>Iterators abstract the logic of traversing a collection.</li>
<li>Lazy evaluation: no work is done until you consume the iterator.</li>
<li>Iterator adapters (like <code>map</code>, <code>filter</code>) are zero-cost abstractions.</li>
<li>The compiler can often optimize iterator chains as well as hand-written loops.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="motivating-iterators"><a class="header" href="#motivating-iterators">Motivating Iterators</a></h1>
<p>If you want to iterate over the contents of an array, you'll need to define:</p>
<ul>
<li>Some state to keep track of where you are in the iteration process, e.g. an
index.</li>
<li>A condition to determine when iteration is done.</li>
<li>Logic for updating the state of iteration each loop.</li>
<li>Logic for fetching each element using that iteration state.</li>
</ul>
<p>In a C-style for loop you declare these things directly:</p>
<pre><code class="language-c editable">for (int i = 0; i &lt; array_len; i += 1) {
    int elem = array[i];
}
</code></pre>
<p>In Rust we bundle this state and logic together into an object known as an
&quot;iterator&quot;.</p>
<details>
<p><strong>Key points for speakers:</strong></p>
<ul>
<li>C-style loops mix iteration mechanics with business logic.</li>
<li>Iterators separate &quot;how to traverse&quot; from &quot;what to do with elements.&quot;</li>
<li>Rust's <code>for</code> loop works with anything implementing <code>Iterator</code>.</li>
<li>This abstraction enables powerful composition and optimization.</li>
</ul>
<p><strong>Common student questions:</strong></p>
<ul>
<li><em>&quot;Why not just use C-style for loops?&quot;</em> - Error-prone (off-by-one errors), less composable, harder to optimize.</li>
<li><em>&quot;Are iterators slower?&quot;</em> - No! Zero-cost abstractions ‚Äî compiles to the same machine code as hand-written loops.</li>
<li><em>&quot;What's the benefit?&quot;</em> - Cleaner code, fewer bugs, and iterator adapters (<code>map</code>, <code>filter</code>, etc.) compose elegantly.</li>
<li><em>&quot;Can I still access the index?&quot;</em> - Yes, use <code>.enumerate()</code>.</li>
</ul>
<p><strong>Rust equivalent:</strong></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let array = [2, 4, 6, 8];
for elem in array {
    // use elem
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>The abstraction advantage:</strong></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// C-style thinking: manual index manipulation
// Iterator thinking: &quot;for each element, do X&quot;
array.iter()
     .filter(|x| **x &gt; 3)
     .map(|x| x * 2)
     .sum::&lt;i32&gt;()
<span class="boring">}
</span></code></pre></pre>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="iterator-trait"><a class="header" href="#iterator-trait"><code>Iterator</code> Trait</a></h1>
<p>The <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html"><code>Iterator</code></a> trait
defines how an object can be used to produce a sequence of values. For example,
if we wanted to create an iterator that can produce the elements of a slice it
might look something like this:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">struct SliceIter&lt;'s&gt; {
    slice: &amp;'s [i32],
    i: usize,
}

impl&lt;'s&gt; Iterator for SliceIter&lt;'s&gt; {
    type Item = &amp;'s i32;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        if self.i == self.slice.len() {
            None
        } else {
            let next = &amp;self.slice[self.i];
            self.i += 1;
            Some(next)
        }
    }
}

fn main() {
    let slice = &amp;[2, 4, 6, 8];
    let iter = SliceIter { slice, i: 0 };
    for elem in iter {
        dbg!(elem);
    }
}
</code></pre></pre>
<details>
<p><strong>Key points for speakers:</strong></p>
<ul>
<li><code>Iterator</code> has one required method: <code>next()</code> ‚Üí <code>Option&lt;Item&gt;</code>.</li>
<li><code>None</code> signals the end of iteration ‚Äî clean, no sentinel values.</li>
<li>Iterators are lazy: no work until <code>next()</code> is called.</li>
<li>The 70+ helper methods are all implemented in terms of <code>next()</code>.</li>
</ul>
<p><strong>Common student questions:</strong></p>
<ul>
<li><em>&quot;Why return Option instead of throwing?&quot;</em> - Rust doesn't have exceptions. <code>None</code> is explicit end-of-iteration.</li>
<li><em>&quot;What's <code>type Item</code>?&quot;</em> - An associated type; the type of elements produced. Each iterator has exactly one item type.</li>
<li><em>&quot;Can iterators be infinite?&quot;</em> - Yes! <code>0..</code> produces integers forever (until overflow). Use <code>.take(n)</code> to limit.</li>
<li><em>&quot;Do I need to implement all 70 methods?&quot;</em> - No! Only <code>next()</code> is required. All others have default implementations.</li>
</ul>
<p><strong>Demo suggestion:</strong>
Show what happens if you call <code>next()</code> manually:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut iter = [1, 2, 3].into_iter();
println!(&quot;{:?}&quot;, iter.next()); // Some(1)
println!(&quot;{:?}&quot;, iter.next()); // Some(2)
println!(&quot;{:?}&quot;, iter.next()); // Some(3)
println!(&quot;{:?}&quot;, iter.next()); // None
<span class="boring">}
</span></code></pre></pre>
<p><strong>Teaching tip:</strong>
Emphasize the lifetime in <code>SliceIter&lt;'s&gt;</code> ‚Äî the iterator borrows the slice and can't outlive it.</p>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="iterator-helper-methods"><a class="header" href="#iterator-helper-methods"><code>Iterator</code> Helper Methods</a></h1>
<p>In addition to the <code>next</code> method that defines how an iterator behaves, the
<code>Iterator</code> trait provides 70+ helper methods that can be used to build
customized iterators.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let result: i32 = (1..=10) // Create a range from 1 to 10
        .filter(|x| x % 2 == 0) // Keep only even numbers
        .map(|x| x * x) // Square each number
        .sum(); // Sum up all the squared numbers

    println!(&quot;The sum of squares of even numbers from 1 to 10 is: {}&quot;, result);
}
</code></pre></pre>
<details>
<p><strong>Key points for speakers:</strong></p>
<ul>
<li>Adapters (<code>map</code>, <code>filter</code>, <code>take</code>) return new iterators ‚Äî they don't consume.</li>
<li>Consumers (<code>sum</code>, <code>count</code>, <code>collect</code>) drain the iterator and produce a result.</li>
<li>Adapters are lazy: chaining <code>.filter().map()</code> creates no intermediate collections.</li>
<li>The compiler optimizes iterator chains into tight loops (zero-cost abstraction).</li>
</ul>
<p><strong>Common student questions:</strong></p>
<ul>
<li><em>&quot;Does filter create a new Vec?&quot;</em> - No! It returns a lazy iterator that skips elements on demand.</li>
<li><em>&quot;What's the difference between map and for_each?&quot;</em> - <code>map</code> returns an iterator; <code>for_each</code> consumes for side effects.</li>
<li><em>&quot;Are closures in map/filter slow?&quot;</em> - No, they're typically inlined by the compiler.</li>
<li><em>&quot;What if I need the index?&quot;</em> - Use <code>.enumerate()</code> to get <code>(index, value)</code> tuples.</li>
</ul>
<p><strong>Common adapters:</strong></p>
<ul>
<li><code>map(f)</code> ‚Äî transform each element</li>
<li><code>filter(p)</code> ‚Äî keep elements matching predicate</li>
<li><code>take(n)</code> ‚Äî take first n elements</li>
<li><code>skip(n)</code> ‚Äî skip first n elements</li>
<li><code>enumerate()</code> ‚Äî add index to each element</li>
<li><code>zip(other)</code> ‚Äî pair with another iterator</li>
</ul>
<p><strong>Common consumers:</strong></p>
<ul>
<li><code>collect()</code> ‚Äî build a collection</li>
<li><code>sum()</code>, <code>product()</code> ‚Äî arithmetic aggregation</li>
<li><code>count()</code> ‚Äî number of elements</li>
<li><code>find(p)</code> ‚Äî first matching element</li>
<li><code>any(p)</code>, <code>all(p)</code> ‚Äî boolean tests</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="collect"><a class="header" href="#collect"><code>collect</code></a></h1>
<p>The <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.collect"><code>collect</code></a>
method lets you build a collection from an <code>Iterator</code>.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let primes = vec![2, 3, 5, 7];
    let prime_squares = primes.into_iter().map(|p| p * p).collect::&lt;Vec&lt;_&gt;&gt;();
    println!(&quot;prime_squares: {prime_squares:?}&quot;);
}
</code></pre></pre>
<details>
<p><strong>Key points for speakers:</strong></p>
<ul>
<li><code>collect()</code> is generic ‚Äî works with any type implementing <code>FromIterator</code>.</li>
<li>The turbofish (<code>::&lt;&gt;</code>) specifies the collection type explicitly.</li>
<li><code>_</code> lets Rust infer element types when the collection type is specified.</li>
<li>Common targets: <code>Vec</code>, <code>HashSet</code>, <code>HashMap</code>, <code>String</code>.</li>
</ul>
<p><strong>Common student questions:</strong></p>
<ul>
<li><em>&quot;Why do I need the turbofish?&quot;</em> - <code>collect()</code> can return many types. Rust needs to know which one.</li>
<li><em>&quot;Can I collect into a String?&quot;</em> - Yes! <code>chars.collect::&lt;String&gt;()</code> works for char iterators.</li>
<li><em>&quot;What about Result?&quot;</em> - <code>Iterator&lt;Item=Result&lt;T,E&gt;&gt;</code> can collect to <code>Result&lt;Vec&lt;T&gt;,E&gt;</code> ‚Äî stops on first error!</li>
<li><em>&quot;Which is better, turbofish or type annotation?&quot;</em> - Style preference. Turbofish is inline; annotation is separate.</li>
</ul>
<p><strong>Powerful patterns:</strong></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Collecting Results: stops on first error
let results: Result&lt;Vec&lt;_&gt;, _&gt; = strings.iter()
    .map(|s| s.parse::&lt;i32&gt;())
    .collect();

// Collecting into HashMap
let map: HashMap&lt;_, _&gt; = vec![(&quot;a&quot;, 1), (&quot;b&quot;, 2)].into_iter().collect();

// Collecting into String
let s: String = vec!['h', 'i'].into_iter().collect();
<span class="boring">}
</span></code></pre></pre>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="intoiterator-1"><a class="header" href="#intoiterator-1"><code>IntoIterator</code></a></h1>
<p>The <code>Iterator</code> trait tells you how to <em>iterate</em> once you have created an
iterator. The related trait
<a href="https://doc.rust-lang.org/std/iter/trait.IntoIterator.html"><code>IntoIterator</code></a>
defines how to create an iterator for a type. It is used automatically by the
<code>for</code> loop.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">struct Grid {
    x_coords: Vec&lt;u32&gt;,
    y_coords: Vec&lt;u32&gt;,
}

impl IntoIterator for Grid {
    type Item = (u32, u32);
    type IntoIter = GridIter;
    fn into_iter(self) -&gt; GridIter {
        GridIter { grid: self, i: 0, j: 0 }
    }
}

struct GridIter {
    grid: Grid,
    i: usize,
    j: usize,
}

impl Iterator for GridIter {
    type Item = (u32, u32);

    fn next(&amp;mut self) -&gt; Option&lt;(u32, u32)&gt; {
        if self.i &gt;= self.grid.x_coords.len() {
            self.i = 0;
            self.j += 1;
            if self.j &gt;= self.grid.y_coords.len() {
                return None;
            }
        }
        let res = Some((self.grid.x_coords[self.i], self.grid.y_coords[self.j]));
        self.i += 1;
        res
    }
}

fn main() {
    let grid = Grid { x_coords: vec![3, 5, 7, 9], y_coords: vec![10, 20, 30, 40] };
    for (x, y) in grid {
        println!(&quot;point = {x}, {y}&quot;);
    }
}
</code></pre></pre>
<details>
<p><strong>Key points for speakers:</strong></p>
<ul>
<li><code>IntoIterator</code> is what <code>for</code> loops call ‚Äî it creates an iterator from a value.</li>
<li><code>into_iter(self)</code> consumes the collection by default.</li>
<li>Collections also implement <code>IntoIterator</code> for <code>&amp;T</code> and <code>&amp;mut T</code>.</li>
<li>Two associated types: <code>Item</code> (element type) and <code>IntoIter</code> (iterator type).</li>
</ul>
<p><strong>Common student questions:</strong></p>
<ul>
<li><em>&quot;Why can't I iterate twice?&quot;</em> - <code>into_iter(self)</code> consumes ownership. Use <code>&amp;grid</code> or implement <code>IntoIterator</code> for <code>&amp;Grid</code>.</li>
<li><em>&quot;What's the difference between iter() and into_iter()?&quot;</em> - <code>iter()</code> borrows elements, <code>into_iter()</code> may consume or borrow depending on the receiver.</li>
<li><em>&quot;How does for know which to call?&quot;</em> - <code>for x in collection</code> calls <code>collection.into_iter()</code>. <code>for x in &amp;collection</code> calls <code>(&amp;collection).into_iter()</code>.</li>
<li><em>&quot;Do I need to implement both traits?&quot;</em> - Usually yes: <code>IntoIterator</code> on your type, and <code>Iterator</code> on a separate iterator struct.</li>
</ul>
<p><strong>Three ways to iterate:</strong></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v = vec![1, 2, 3];
for x in v { }      // into_iter(), consumes v
for x in &amp;v { }     // iter(), borrows v
for x in &amp;mut v { } // iter_mut(), mutably borrows v
<span class="boring">}
</span></code></pre></pre>
<p><strong>Exercise:</strong>
Try iterating over <code>grid</code> twice. Then implement <code>IntoIterator for &amp;Grid</code> to fix it.</p>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="modules"><a class="header" href="#modules">Modules</a></h1>
<p>We have seen how <code>impl</code> blocks let us namespace functions to a type.</p>
<p>Similarly, <code>mod</code> lets us namespace types and functions:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">mod foo {
    pub fn do_something() {
        println!(&quot;In the foo module&quot;);
    }
}

mod bar {
    pub fn do_something() {
        println!(&quot;In the bar module&quot;);
    }
}

fn main() {
    foo::do_something();
    bar::do_something();
}
</code></pre></pre>
<details>
<ul>
<li>Modules are used to organize code and control visibility (public/private).</li>
<li>By default, items in a module are private to the parent module.</li>
<li>Use <code>pub</code> to make items visible outside their module.</li>
<li>Modules can be nested arbitrarily deep.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="visibility"><a class="header" href="#visibility">Visibility</a></h1>
<p>Modules are a privacy boundary:</p>
<ul>
<li>Module items are private by default (hides implementation details).</li>
<li>Parent and sibling items are always visible.</li>
</ul>
<pre><pre class="playground"><code class="language-rust editable edition2021">mod outer {
    fn private() {
        println!(&quot;outer::private&quot;);
    }

    pub fn public() {
        println!(&quot;outer::public&quot;);
    }

    mod inner {
        fn private() {
            println!(&quot;outer::inner::private&quot;);
        }

        pub fn public() {
            println!(&quot;outer::inner::public&quot;);
            super::private();
        }
    }
}

fn main() {
    outer::public();
}
</code></pre></pre>
<details>
<p><strong>Key points for speakers:</strong></p>
<ul>
<li>Private by default is a security-conscious design choice.</li>
<li><code>pub</code> makes an item visible to parent modules (and their parents, up to <code>pub</code> at crate level).</li>
<li><code>super::</code> accesses the parent module ‚Äî useful for accessing sibling items.</li>
<li>Child modules can see private items in parent modules, but not vice versa.</li>
</ul>
<p><strong>Common student questions:</strong></p>
<ul>
<li><em>&quot;Why can inner call super::private()?&quot;</em> - Child modules can see their parent's private items. Privacy is about external access, not internal.</li>
<li><em>&quot;What about pub(crate), pub(super)?&quot;</em> - These are visibility modifiers: <code>pub(crate)</code> = visible within crate, <code>pub(super)</code> = visible to parent only.</li>
<li><em>&quot;How is this different from Java's package-private?&quot;</em> - Rust's system is more fine-grained. You can specify exactly which scope can see an item.</li>
<li><em>&quot;Can I access outer::inner::public from main?&quot;</em> - No! The <code>inner</code> module itself isn't <code>pub</code>, so you can't reach into it even though <code>public</code> is <code>pub</code>.</li>
</ul>
<p><strong>Demo suggestion:</strong>
Try uncommenting <code>outer::inner::public()</code> in main to show the error message about module visibility.</p>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="paths"><a class="header" href="#paths">Paths</a></h1>
<p>Paths are resolved as follows:</p>
<ol>
<li>
<p>As a relative path:</p>
<ul>
<li><code>foo</code> or <code>self::foo</code> refers to <code>foo</code> in the current module,</li>
<li><code>super::foo</code> refers to <code>foo</code> in the parent module.</li>
</ul>
</li>
<li>
<p>As an absolute path:</p>
<ul>
<li><code>crate::foo</code> refers to <code>foo</code> in the root of the current crate,</li>
<li><code>bar::foo</code> refers to <code>foo</code> in the <code>bar</code> crate.</li>
</ul>
</li>
</ol>
<details>
<p><strong>Key points for speakers:</strong></p>
<ul>
<li><code>crate::</code> is the current crate root ‚Äî like <code>/</code> in filesystem paths.</li>
<li><code>self::</code> is explicitly &quot;current module&quot; ‚Äî often optional but clarifies intent.</li>
<li><code>super::</code> goes up one level ‚Äî like <code>..</code> in filesystem paths.</li>
<li>External crate names are resolved from the extern prelude (dependencies in Cargo.toml).</li>
</ul>
<p><strong>Common student questions:</strong></p>
<ul>
<li><em>&quot;When should I use absolute vs relative paths?&quot;</em> - Use <code>crate::</code> for items far away in the hierarchy. Use relative paths for nearby items. Consistency matters more than the choice.</li>
<li><em>&quot;What's the difference between <code>use</code> and paths?&quot;</em> - <code>use</code> brings items into scope so you don't repeat long paths. Paths are how you reference items.</li>
<li><em>&quot;Can I rename imports?&quot;</em> - Yes! <code>use std::io::Result as IoResult;</code> avoids conflicts.</li>
<li><em>&quot;What if two crates have the same name?&quot;</em> - Use <code>extern crate foo as bar;</code> or rename in Cargo.toml.</li>
</ul>
<p><strong>Demo suggestion:</strong>
Show a <code>use</code> statement with glob imports (<code>use std::collections::*;</code>) and discuss why it's generally discouraged.</p>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="filesystem-hierarchy"><a class="header" href="#filesystem-hierarchy">Filesystem Hierarchy</a></h1>
<p>The module content can be omitted:</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail edition2021">mod garden;
</code></pre></pre>
<p>The <code>garden</code> module content is found at:</p>
<ul>
<li><code>src/garden.rs</code> (modern Rust 2018 style)</li>
<li><code>src/garden/mod.rs</code> (older Rust 2015 style)</li>
</ul>
<p>Similarly, a <code>garden::vegetables</code> module can be found at:</p>
<ul>
<li><code>src/garden/vegetables.rs</code> (modern Rust 2018 style)</li>
<li><code>src/garden/vegetables/mod.rs</code> (older Rust 2015 style)</li>
</ul>
<p>The <code>crate</code> root is in:</p>
<ul>
<li><code>src/lib.rs</code> (for a library crate)</li>
<li><code>src/main.rs</code> (for a binary crate)</li>
</ul>
<details>
<p><strong>Key points for speakers:</strong></p>
<ul>
<li>Rust 2018 style (<code>garden.rs</code>) is preferred ‚Äî it's cleaner and has fewer files.</li>
<li>The old <code>mod.rs</code> style still works but clutters directories.</li>
<li>A crate can have both <code>lib.rs</code> AND <code>main.rs</code> ‚Äî the binary can use the library.</li>
<li><code>mod foo;</code> tells the compiler to look for module content in a file.</li>
</ul>
<p><strong>Common student questions:</strong></p>
<ul>
<li><em>&quot;Which style should I use?&quot;</em> - Use Rust 2018 style (<code>garden.rs</code>). Only use <code>mod.rs</code> if you're maintaining old code.</li>
<li><em>&quot;Can I have both lib.rs and main.rs?&quot;</em> - Yes! The binary (<code>main.rs</code>) can <code>use your_crate::something</code> from the library.</li>
<li><em>&quot;What's the difference between a crate and a module?&quot;</em> - A crate is a compilation unit (one <code>lib.rs</code> or <code>main.rs</code>). Modules organize code within a crate.</li>
<li><em>&quot;How do I create nested modules?&quot;</em> - Create a directory with the module name and put submodule files inside.</li>
</ul>
<p><strong>Demo suggestion:</strong>
Show <code>cargo new --lib mylib</code> and create a nested module structure to demonstrate both styles.</p>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="course-4-exercises"><a class="header" href="#course-4-exercises">Course 4: Exercises</a></h1>
<p>In course 4, the exercices will focus on strings and iterators.</p>
<!-- <details>

After looking at the exercises, you can look at the [solutions] provided.

[solutions]: solutions-afternoon.md

</details>
 --><div style="break-before: page; page-break-before: always;"></div><h1 id="luhn-algorithm"><a class="header" href="#luhn-algorithm">Luhn Algorithm</a></h1>
<p>The <a href="https://en.wikipedia.org/wiki/Luhn_algorithm">Luhn algorithm</a> is used to
validate credit card numbers. The algorithm takes a string as input and does the
following to validate the credit card number:</p>
<ul>
<li>
<p>Ignore all spaces. Reject number with less than two digits.</p>
</li>
<li>
<p>Moving from right to left, double every second digit: for the number <code>1234</code>,
we double <code>3</code> and <code>1</code>.</p>
</li>
<li>
<p>After doubling a digit, sum the digits. So doubling <code>7</code> becomes <code>14</code> which
becomes <code>5</code>.</p>
</li>
<li>
<p>Sum all the undoubled and doubled digits.</p>
</li>
<li>
<p>The credit card number is valid if the sum ends with <code>0</code>.</p>
</li>
</ul>
<p>Copy the following code to <a href="https://play.rust-lang.org/">https://play.rust-lang.org/</a> and implement the
function:</p>
<pre><pre class="playground"><code class="language-rust edition2021">// TODO: remove this when you're done with your implementation.
#![allow(unused_variables, dead_code)]

pub fn luhn(cc_number: &amp;str) -&gt; bool {
    unimplemented!()
}

#[test]
fn test_non_digit_cc_number() {
    assert!(!luhn(&quot;foo&quot;));
}

#[test]
fn test_empty_cc_number() {
    assert!(!luhn(&quot;&quot;));
    assert!(!luhn(&quot; &quot;));
    assert!(!luhn(&quot;  &quot;));
    assert!(!luhn(&quot;    &quot;));
}

#[test]
fn test_single_digit_cc_number() {
    assert!(!luhn(&quot;0&quot;));
}

#[test]
fn test_two_digit_cc_number() {
    assert!(luhn(&quot; 0 0 &quot;));
}

#[test]
fn test_valid_cc_number() {
    assert!(luhn(&quot;4263 9826 4026 9299&quot;));
    assert!(luhn(&quot;4539 3195 0343 6467&quot;));
    assert!(luhn(&quot;7992 7398 713&quot;));
}

#[test]
fn test_invalid_cc_number() {
    assert!(!luhn(&quot;4223 9826 4026 9299&quot;));
    assert!(!luhn(&quot;4539 3195 0343 6476&quot;));
    assert!(!luhn(&quot;8273 1232 7352 0569&quot;));
}

#[allow(dead_code)]
fn main() {}
</code></pre></pre>
<details>
<p><strong>Exercise guidance for speakers:</strong></p>
<ul>
<li>This exercise practices string processing, iteration, and the <code>?</code> operator.</li>
<li>Encourage using iterator methods: <code>chars()</code>, <code>filter()</code>, <code>rev()</code>, <code>enumerate()</code>.</li>
<li>The algorithm works right-to-left, so <code>rev()</code> is useful.</li>
<li>Students often forget edge cases: all spaces, single digit, non-digit characters.</li>
</ul>
<p><strong>Hints to give if stuck:</strong></p>
<ol>
<li>First, filter out spaces and collect to a String or Vec.</li>
<li>Check minimum length (&gt;= 2 digits).</li>
<li>Iterate right-to-left, doubling every other digit.</li>
<li>Sum digits (remember 14 ‚Üí 1 + 4 = 5).</li>
<li>Check if sum % 10 == 0.</li>
</ol>
<p><strong>Common student mistakes:</strong></p>
<ul>
<li>Forgetting to handle spaces.</li>
<li>Doubling from left instead of right.</li>
<li>Not handling the &quot;sum digits of doubled value&quot; step.</li>
<li>Off-by-one errors in which digits to double.</li>
</ul>
<p><strong>Solution approach:</strong></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>cc.chars()
  .filter(|c| !c.is_whitespace())
  .rev()
  .enumerate()
  .map(|(i, c)| { /* transform based on position */ })
  .sum::&lt;u32&gt;() % 10 == 0
<span class="boring">}
</span></code></pre></pre>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="strings-and-iterators"><a class="header" href="#strings-and-iterators">Strings and Iterators</a></h1>
<p>In this exercise, you are implementing a routing component of a web server. The
server is configured with a number of <em>path prefixes</em> which are matched against
<em>request paths</em>. The path prefixes can contain a wildcard character which
matches a full segment. See the unit tests below.</p>
<p>Copy the following code to <a href="https://play.rust-lang.org/">https://play.rust-lang.org/</a> and make the tests
pass. Try avoiding allocating a <code>Vec</code> for your intermediate results:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// TODO: remove this when you're done with your implementation.
#![allow(unused_variables, dead_code)]

pub fn prefix_matches(prefix: &amp;str, request_path: &amp;str) -&gt; bool {
    unimplemented!()
}

#[test]
fn test_matches_without_wildcard() {
    assert!(prefix_matches(&quot;/v1/publishers&quot;, &quot;/v1/publishers&quot;));
    assert!(prefix_matches(&quot;/v1/publishers&quot;, &quot;/v1/publishers/abc-123&quot;));
    assert!(prefix_matches(&quot;/v1/publishers&quot;, &quot;/v1/publishers/abc/books&quot;));

    assert!(!prefix_matches(&quot;/v1/publishers&quot;, &quot;/v1&quot;));
    assert!(!prefix_matches(&quot;/v1/publishers&quot;, &quot;/v1/publishersBooks&quot;));
    assert!(!prefix_matches(&quot;/v1/publishers&quot;, &quot;/v1/parent/publishers&quot;));
}

#[test]
fn test_matches_with_wildcard() {
    assert!(prefix_matches(
        &quot;/v1/publishers/*/books&quot;,
        &quot;/v1/publishers/foo/books&quot;
    ));
    assert!(prefix_matches(
        &quot;/v1/publishers/*/books&quot;,
        &quot;/v1/publishers/bar/books&quot;
    ));
    assert!(prefix_matches(
        &quot;/v1/publishers/*/books&quot;,
        &quot;/v1/publishers/foo/books/book1&quot;
    ));

    assert!(!prefix_matches(&quot;/v1/publishers/*/books&quot;, &quot;/v1/publishers&quot;));
    assert!(!prefix_matches(
        &quot;/v1/publishers/*/books&quot;,
        &quot;/v1/publishers/foo/booksByAuthor&quot;
    ));
}
<span class="boring">}
</span></code></pre></pre>
<details>
<p><strong>Exercise guidance for speakers:</strong></p>
<ul>
<li>This exercise practices iterator combinators and avoiding allocations.</li>
<li>Key insight: use <code>zip</code> to pair prefix segments with path segments.</li>
<li>Wildcards (<code>*</code>) match any single segment.</li>
<li>Challenge: solve without collecting into intermediate Vecs.</li>
</ul>
<p><strong>Key concepts practiced:</strong></p>
<ol>
<li>String splitting and iterating over segments.</li>
<li>Using <code>zip</code> to compare sequences in parallel.</li>
<li>Pattern matching with iterators.</li>
<li>Writing allocation-free solutions with lazy iterators.</li>
</ol>
<p><strong>Hints to give if stuck:</strong></p>
<ul>
<li><code>split('/')</code> gives an iterator over path segments.</li>
<li><code>zip</code> pairs elements from two iterators.</li>
<li>Check: prefix segments must either match exactly OR be <code>*</code>.</li>
<li>Empty segments (from leading <code>/</code>) need handling.</li>
</ul>
<p><strong>Common student mistakes:</strong></p>
<ul>
<li>Not handling trailing slashes correctly.</li>
<li>Forgetting that <code>zip</code> stops at the shorter iterator.</li>
<li>Allocating when iterators would suffice.</li>
</ul>
<p><strong>Elegant solution pattern:</strong></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>prefix.split('/').zip(path.split('/'))
    .all(|(p, s)| p == &quot;*&quot; || p == s)
    &amp;&amp; /* prefix not longer than path */
<span class="boring">}
</span></code></pre></pre>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="exercise-iterator-method-chaining"><a class="header" href="#exercise-iterator-method-chaining">Exercise: Iterator Method Chaining</a></h1>
<p>In this exercise, you will need to find and use some of the provided methods in
the <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html"><code>Iterator</code></a> trait
to implement a complex calculation.</p>
<p>Use an iterator expression and <code>collect</code> the result to construct the return value.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">/// Calculate the differences between elements of `values` offset by `offset`,
/// wrapping around from the end of `values` to the beginning.
///
/// Element `n` of the result is `values[(n+offset)%len] - values[n]`.
fn offset_differences(offset: usize, values: Vec&lt;i32&gt;) -&gt; Vec&lt;i32&gt; {
    todo!()
}

#[test]
fn test_offset_one() {
    assert_eq!(offset_differences(1, vec![1, 3, 5, 7]), vec![2, 2, 2, -6]);
    assert_eq!(offset_differences(1, vec![1, 3, 5]), vec![2, 2, -4]);
    assert_eq!(offset_differences(1, vec![1, 3]), vec![2, -2]);
}

#[test]
fn test_larger_offsets() {
    assert_eq!(offset_differences(2, vec![1, 3, 5, 7]), vec![4, 4, -4, -4]);
    assert_eq!(offset_differences(3, vec![1, 3, 5, 7]), vec![6, -2, -2, -2]);
    assert_eq!(offset_differences(4, vec![1, 3, 5, 7]), vec![0, 0, 0, 0]);
    assert_eq!(offset_differences(5, vec![1, 3, 5, 7]), vec![2, 2, 2, -6]);
}

#[test]
fn test_degenerate_cases() {
    assert_eq!(offset_differences(1, vec![0]), vec![0]);
    assert_eq!(offset_differences(1, vec![1]), vec![0]);
    let empty: Vec&lt;i32&gt; = vec![];
    assert_eq!(offset_differences(1, empty), vec![]);
}

fn main() {
    let result = offset_differences(1, vec![1, 3, 5, 7]);
    println!(&quot;Result: {:?}&quot;, result);
}
</code></pre></pre>
<details>
<summary>Hints</summary>
<ul>
<li>Look at the <code>iter()</code>, <code>cycle()</code>, <code>skip()</code>, <code>zip()</code>, and <code>map()</code> methods.</li>
<li><code>cycle()</code> creates an infinite iterator that repeats the original.</li>
<li><code>zip()</code> combines two iterators into pairs.</li>
<li>Don't forget to <code>collect()</code> at the end!</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="welcome-to-course-5"><a class="header" href="#welcome-to-course-5">Welcome to course 5</a></h1>
<p>In this course, we will cover some more advanced topics of Rust:</p>
<ul>
<li>
<p>Traits: deriving traits, default methods, and important standard library
traits.</p>
</li>
<li>
<p>Generics: generic data types, generic methods, monomorphization, and trait
objects.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="traits"><a class="header" href="#traits">Traits</a></h1>
<p>Rust lets you abstract over types with traits. They're similar to interfaces:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">trait Greet {
    fn say_hello(&amp;self);
}

struct Dog {
    name: String,
}

struct Cat;  // No name, cats won't respond to it anyway.

impl Greet for Dog {
    fn say_hello(&amp;self) {
        println!(&quot;Wuf, my name is {}!&quot;, self.name);
    }
}

impl Greet for Cat {
    fn say_hello(&amp;self) {
        println!(&quot;Miau!&quot;);
    }
}

fn main() {
    let pets: Vec&lt;Box&lt;dyn Greet&gt;&gt; = vec![
        Box::new(Dog { name: String::from(&quot;Fido&quot;) }),
        Box::new(Cat),
    ];
    for pet in pets {
        pet.say_hello();
    }
}
</code></pre></pre>
<details>
<ul>
<li>Traits may specify pre-implemented (default) methods and methods that users are required to implement themselves. Methods with default implementations can rely on required methods.</li>
<li>Types that implement a given trait may be of different sizes. This makes it impossible to have things like <code>Vec&lt;Greet&gt;</code> in the example above.</li>
<li><code>dyn Greet</code> is a way to tell the compiler about a dynamically sized type that implements <code>Greet</code>. The compiler does not know the concrete type that is being passed.</li>
<li>In the example, <code>pets</code> holds Fat Pointers to objects that implement <code>Greet</code>. The Fat Pointer consists of two components, a pointer to the actual object and a pointer to the virtual method table for the <code>Greet</code> implementation of that particular object.</li>
</ul>
<p>From <a href="https://doc.rust-lang.org/std/keyword.dyn.html">rust-lang</a>, &quot;a dyn Trait reference contains two pointers. One pointer goes to the data (e.g., an instance of a struct). Another pointer goes to a map of method call names to function pointers (known as a virtual method table or vtable). At run-time, when a method needs to be called on the dyn Trait, the vtable is consulted to get the function pointer and then that function pointer is called.&quot;</p>
<p>Compare these outputs in the above example:</p>
<pre><code class="language-rust ignore">    println!(&quot;{} {}&quot;, std::mem::size_of::&lt;Dog&gt;(), std::mem::size_of::&lt;Cat&gt;());
    println!(&quot;{} {}&quot;, std::mem::size_of::&lt;&amp;Dog&gt;(), std::mem::size_of::&lt;&amp;Cat&gt;());
    println!(&quot;{}&quot;, std::mem::size_of::&lt;&amp;dyn Greet&gt;());
    println!(&quot;{}&quot;, std::mem::size_of::&lt;Box&lt;dyn Greet&gt;&gt;());
</code></pre>
<p>This gives the output:</p>
<pre><code class="language-rust ignore">24 0
8 8
16
16
</code></pre>
</details>
<!-- p442 in the Rust programming language -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="deriving-traits"><a class="header" href="#deriving-traits">Deriving Traits</a></h1>
<p>You can let the compiler derive a number of traits:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">#[derive(Debug, Clone, PartialEq, Eq, Default)]
struct Player {
    name: String,
    strength: u8,
    hit_points: u8,
}

fn main() {
    let p1 = Player::default();
    let p2 = p1.clone();
    println!(&quot;Is {:?}\nequal to {:?}?\nThe answer is {}!&quot;, &amp;p1, &amp;p2,
             if p1 == p2 { &quot;yes&quot; } else { &quot;no&quot; });
}
</code></pre></pre>
<details>
<ul>
<li>Deriving only works for traits that have standard implementations based on the
struct's fields.</li>
<li>Common derivable traits: <code>Debug</code>, <code>Clone</code>, <code>Copy</code>, <code>PartialEq</code>, <code>Eq</code>,
<code>PartialOrd</code>, <code>Ord</code>, <code>Hash</code>, <code>Default</code>.</li>
<li>You can only derive <code>Copy</code> if all fields implement <code>Copy</code>.</li>
<li>For custom behavior, implement the trait manually instead of deriving.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="default-methods"><a class="header" href="#default-methods">Default Methods</a></h1>
<p>Traits can implement behavior in terms of other trait methods:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">trait Equals {
    fn equal(&amp;self, other: &amp;Self) -&gt; bool;
    fn not_equal(&amp;self, other: &amp;Self) -&gt; bool {
        !self.equal(other)
    }
}

#[derive(Debug)]
struct Centimeter(i16);

impl Equals for Centimeter {
    fn equal(&amp;self, other: &amp;Centimeter) -&gt; bool {
        self.0 == other.0
    }
}

fn main() {
    let a = Centimeter(10);
    let b = Centimeter(20);
    println!(&quot;{a:?} equals {b:?}: {}&quot;, a.equal(&amp;b));
    println!(&quot;{a:?} not_equals {b:?}: {}&quot;, a.not_equal(&amp;b));
}
</code></pre></pre>
<details>
<p>Centimeters reuses the behavior of <code>not_equal</code> from the Equals trait. It overwrites <code>equal</code>, however.</p>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="important-traits"><a class="header" href="#important-traits">Important Traits</a></h1>
<p>We will now look at some of the most common traits of the Rust standard library:</p>
<ul>
<li><code>Iterator</code> and <code>IntoIterator</code> used in <code>for</code> loops,</li>
<li><code>From</code> and <code>Into</code> used to convert values,</li>
<li><code>Read</code> and <code>Write</code> used for IO,</li>
<li><code>Add</code>, <code>Mul</code>, ... used for operator overloading, and</li>
<li><code>Drop</code> used for defining destructors.</li>
</ul>
<details>
<p><strong>Key points for speakers:</strong></p>
<ul>
<li>These traits form the foundation of idiomatic Rust code.</li>
<li>Understanding these traits is essential for reading and writing Rust effectively.</li>
<li>Many of these traits can be derived automatically with <code>#[derive(...)]</code>.</li>
<li>The following sections will cover each in detail.</li>
</ul>
<p><strong>Common student questions:</strong></p>
<ul>
<li><em>&quot;Which traits should I implement for my types?&quot;</em> - At minimum: <code>Debug</code> for debugging. Consider <code>Clone</code>, <code>Default</code>, <code>PartialEq</code>, <code>Eq</code>, <code>Hash</code> based on your needs.</li>
<li><em>&quot;What's the difference between From and Into?&quot;</em> - They're reciprocal. Implement <code>From</code>, get <code>Into</code> for free. Prefer <code>From</code> when implementing.</li>
<li><em>&quot;Are these in the prelude?&quot;</em> - Some are! <code>Drop</code>, <code>From</code>, <code>Into</code>, <code>Iterator</code> are in the prelude. Others need explicit <code>use</code>.</li>
</ul>
<p><strong>Teaching tip:</strong>
This is an overview slide. Don't go deep here ‚Äî save details for the individual sections.</p>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="iterators-1"><a class="header" href="#iterators-1">Iterators</a></h1>
<p>You can implement the <code>Iterator</code> trait on your own types:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">struct Fibonacci {
    curr: u32,
    next: u32,
}

impl Iterator for Fibonacci {
    type Item = u32;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        let new_next = self.curr + self.next;
        self.curr = self.next;
        self.next = new_next;
        Some(self.curr)
    }
}

fn main() {
    let fib = Fibonacci { curr: 0, next: 1 };
    for (i, n) in fib.enumerate().take(5) {
        println!(&quot;fib({i}): {n}&quot;);
    }
}
</code></pre></pre>
<details>
<ul>
<li>
<p><code>IntoIterator</code> is the trait that makes for loops work. It is implemented by collection types such as
<code>Vec&lt;T&gt;</code> and references to them such as <code>&amp;Vec&lt;T&gt;</code> and <code>&amp;[T]</code>. Ranges also implement it. <code>&amp;[T]</code> is the shared slice type.</p>
</li>
<li>
<p>The <code>Iterator</code> trait implements many common functional programming operations over collections
(e.g. <code>map</code>, <code>filter</code>, <code>reduce</code>, etc). This is the trait where you can find all the documentation
about them. In Rust these functions should produce the code as efficient as equivalent imperative
implementations.</p>
</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fromiterator"><a class="header" href="#fromiterator">FromIterator</a></h1>
<p><code>FromIterator</code> lets you build a collection from an <code>Iterator</code>.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let primes = vec![2, 3, 5, 7];
    let prime_squares = primes
        .into_iter()
        .map(|prime| prime * prime)
        .collect::&lt;Vec&lt;_&gt;&gt;();
}
</code></pre></pre>
<details>
<p><code>Iterator</code> implements
<code>fn collect&lt;B&gt;(self) -&gt; B where     B: FromIterator&lt;Self::Item&gt;,     Self: Sized</code>
<code>collect</code> enables to convert an interator into a collection. Here it enables to reconstruct a vector.</p>
<p>There are also implementations which let you do cool things like convert an
<code>Iterator&lt;Item = Result&lt;V, E&gt;&gt;</code> into a <code>Result&lt;Vec&lt;V&gt;, E&gt;</code>.</p>
<p>Add this line to print the computed squares:
<code>println!(&quot;{:?}&quot;, prime_squares)</code></p>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="from-and-into"><a class="header" href="#from-and-into"><code>From</code> and <code>Into</code></a></h1>
<p>Types implement <code>From</code> and <code>Into</code> to facilitate type conversions:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let s = String::from(&quot;hello&quot;);
    let addr = std::net::Ipv4Addr::from([127, 0, 0, 1]);
    let one = i16::from(true);
    let bigger = i32::from(123i16);
    println!(&quot;{s}, {addr}, {one}, {bigger}&quot;);
}
</code></pre></pre>
<p><code>Into</code> is automatically implemented when <code>From</code> is implemented:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let s: String = &quot;hello&quot;.into();
    let addr: std::net::Ipv4Addr = [127, 0, 0, 1].into();
    let one: i16 = true.into();
    let bigger: i32 = 123i16.into();
    println!(&quot;{s}, {addr}, {one}, {bigger}&quot;);
}
</code></pre></pre>
<details>
<ul>
<li>That's why it is common to only implement <code>From</code>, as your type will get <code>Into</code> implementation too.</li>
<li>When declaring a function argument input type like &quot;anything that can be converted into a <code>String</code>&quot;, the rule is opposite, you should use <code>Into</code>.
Your function will accept types that implement <code>From</code> and those that <em>only</em> implement <code>Into</code>.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="read-and-write"><a class="header" href="#read-and-write"><code>Read</code> and <code>Write</code></a></h1>
<p>Using <code>Read</code> and <code>BufRead</code>, you can abstract over <code>u8</code> sources:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::io::{BufRead, BufReader, Read, Result};

fn count_lines&lt;R: Read&gt;(reader: R) -&gt; usize {
    let buf_reader = BufReader::new(reader);
    buf_reader.lines().count()
}

fn main() -&gt; Result&lt;()&gt; {
    let slice: &amp;[u8] = b&quot;foo\nbar\nbaz\n&quot;;
    println!(&quot;lines in slice: {}&quot;, count_lines(slice));

    let file = std::fs::File::open(std::env::current_exe()?)?;
    println!(&quot;lines in file: {}&quot;, count_lines(file));
    Ok(())
}
</code></pre></pre>
<p>Similarly, <code>Write</code> lets you abstract over <code>u8</code> sinks:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::io::{Result, Write};

fn log&lt;W: Write&gt;(writer: &amp;mut W, msg: &amp;str) -&gt; Result&lt;()&gt; {
    writer.write_all(msg.as_bytes())?;
    writer.write_all(&quot;\n&quot;.as_bytes())
}

fn main() -&gt; Result&lt;()&gt; {
    let mut buffer = Vec::new();
    log(&amp;mut buffer, &quot;Hello&quot;)?;
    log(&amp;mut buffer, &quot;World&quot;)?;
    println!(&quot;Logged: {:?}&quot;, buffer);
    Ok(())
}
</code></pre></pre>
<details>
<pre><code>`std::env::current_exe()` Returns the full filesystem path of the current running executable.
</code></pre>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="add-mul-"><a class="header" href="#add-mul-"><code>Add</code>, <code>Mul</code>, ...</a></h1>
<p>Operator overloading is implemented via traits in <code>std::ops</code>:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">#[derive(Debug, Copy, Clone)]
struct Point { x: i32, y: i32 }

impl std::ops::Add for Point {
    type Output = Self;

    fn add(self, other: Self) -&gt; Self {
        Self {x: self.x + other.x, y: self.y + other.y}
    }
}

fn main() {
    let p1 = Point { x: 10, y: 20 };
    let p2 = Point { x: 100, y: 200 };
    println!(&quot;{:?} + {:?} = {:?}&quot;, p1, p2, p1 + p2);
}
</code></pre></pre>
<details>
<p>Discussion points:</p>
<ul>
<li>You could implement <code>Add</code> for <code>&amp;Point</code>. In which situations is that useful?
<ul>
<li>Answer: <code>Add:add</code> consumes <code>self</code>. If type <code>T</code> for which you are
overloading the operator is not <code>Copy</code>, you should consider overloading
the operator for <code>&amp;T</code> as well. This avoids unnecessary cloning on the
call site.</li>
</ul>
</li>
<li>Why is <code>Output</code> an associated type? Could it be made a type parameter?
<ul>
<li>Short answer: Type parameters are controlled by the caller, but
associated types (like <code>Output</code>) are controlled by the implementor of a
trait.</li>
</ul>
</li>
</ul>
</details><div style="break-before: page; page-break-before: always;"></div><h1 id="the-drop-trait"><a class="header" href="#the-drop-trait">The <code>Drop</code> Trait</a></h1>
<p>Values which implement <code>Drop</code> can specify code to run when they go out of scope:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">struct Droppable {
    name: &amp;'static str,
}

impl Drop for Droppable {
    fn drop(&amp;mut self) {
        println!(&quot;Dropping {}&quot;, self.name);
    }
}

fn main() {
    let a = Droppable { name: &quot;a&quot; };
    {
        let b = Droppable { name: &quot;b&quot; };
        {
            let c = Droppable { name: &quot;c&quot; };
            let d = Droppable { name: &quot;d&quot; };
            println!(&quot;Exiting block B&quot;);
        }
        println!(&quot;Exiting block A&quot;);
    }
    drop(a);
    println!(&quot;Exiting main&quot;);
}
</code></pre></pre>
<!-- <details>

Discussion points:

* Why does not `Drop::drop` take `self`?
    * Short-answer: If it did, `std::mem::drop` would be called at the end of
        the block, resulting in another call to `Drop::drop`, and a stack
        overflow!
* Try replacing `drop(a)` with `a.drop()`.

</details> --><div style="break-before: page; page-break-before: always;"></div><h1 id="generics"><a class="header" href="#generics">Generics</a></h1>
<p>Rust support generics, which lets you abstract an algorithm (such as sorting)
over the types used in the algorithm.</p>
<details>
<ul>
<li>Generics allow code reuse while maintaining type safety.</li>
<li>The compiler generates specialized code for each concrete type used
(monomorphization), so there's no runtime cost.</li>
<li>You can constrain generic types with trait bounds to require certain
capabilities.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="generic-data-types"><a class="header" href="#generic-data-types">Generic Data Types</a></h1>
<p>You can use generics to abstract over the concrete field type:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">#[derive(Debug)]
struct Point&lt;T&gt; {
    x: T,
    y: T,
}

fn main() {
    let integer = Point { x: 5, y: 10 };
    let float = Point { x: 1.0, y: 4.0 };
    println!(&quot;{integer:?} and {float:?}&quot;);
}
</code></pre></pre>
<details>
<ul>
<li>Try declaring a new variable <code>let p = Point { x: 5, y: 10.0 };</code>. This won't
compile because <code>x</code> and <code>y</code> must have the same type <code>T</code>.</li>
<li>To allow different types, you would need two type parameters:
<code>struct Point&lt;T, U&gt; { x: T, y: U }</code>.</li>
<li>Rust infers the type <code>T</code> based on the values provided. You can also be
explicit: <code>Point::&lt;i32&gt; { x: 5, y: 10 }</code>.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="generic-methods"><a class="header" href="#generic-methods">Generic Methods</a></h1>
<p>You can declare a generic type on your <code>impl</code> block:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">#[derive(Debug)]
struct Point&lt;T&gt;(T, T);

impl&lt;T&gt; Point&lt;T&gt; {
    fn x(&amp;self) -&gt; &amp;T {
        &amp;self.0  // + 10
    }

    // fn set_x(&amp;mut self, x: T)
}

fn main() {
    let p = Point(5, 10);
    println!(&quot;p.x = {}&quot;, p.x());
}
</code></pre></pre>
<details>
<ul>
<li><em>Q:</em> Why <code>T</code> is specified twice in <code>impl&lt;T&gt; Point&lt;T&gt; {}</code>? Isn't that redundant?
<ul>
<li>This is because it is a generic implementation section for generic type. They are independently generic.</li>
<li>It means these methods are defined for any <code>T</code>.</li>
<li>It is possible to write <code>impl Point&lt;u32&gt; { .. }</code>.
<ul>
<li><code>Point</code> is still generic and you can use <code>Point&lt;f64&gt;</code>, but methods in this block will only be available for <code>Point&lt;u32&gt;</code>.</li>
</ul>
</li>
</ul>
</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="trait-bounds"><a class="header" href="#trait-bounds">Trait Bounds</a></h1>
<p>When working with generics, you often want to limit the types. You can do this
with <code>T: Trait</code> or <code>impl Trait</code>:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn duplicate&lt;T: Clone&gt;(a: T) -&gt; (T, T) {
    (a.clone(), a.clone())
}

// struct NotClonable;

fn main() {
    let foo = String::from(&quot;foo&quot;);
    let pair = duplicate(foo);
    println!(&quot;{pair:?}&quot;);
}
</code></pre></pre>
<p>Here traits are used as bounds to stipulate what functionality a type implements. For example, above, T must implement Clone.</p>
<details>
<p>Show a <code>where</code> clause, students will encounter it when reading code.</p>
<pre><code class="language-rust ignore">fn duplicate&lt;T&gt;(a: T) -&gt; (T, T)
where
    T: Clone,
{
    (a.clone(), a.clone())
}
</code></pre>
<ul>
<li>It declutters the function signature if you have many parameters.</li>
<li>It has additional features making it more powerful.
<ul>
<li>If someone asks, the extra feature is that the type on the left of &quot;:&quot; can be arbitrary, like <code>Option&lt;T&gt;</code>.</li>
</ul>
</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="impl-trait"><a class="header" href="#impl-trait"><code>impl Trait</code></a></h1>
<p>Similar to trait bounds, an <code>impl Trait</code> syntax can be used in function
arguments and return values:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::fmt::Display;

fn get_x(name: impl Display) -&gt; impl Display {
    format!(&quot;Hello {name}&quot;)
}

fn main() {
    let x = get_x(&quot;foo&quot;);
    println!(&quot;{x}&quot;);
}
</code></pre></pre>
<ul>
<li><code>impl Trait</code> cannot be used with the <code>::&lt;&gt;</code> turbo fish syntax.</li>
<li><code>impl Trait</code> allows you to work with types which you cannot name.</li>
</ul>
<details>
<p>The meaning of <code>impl Trait</code> is a bit different in the different positions.</p>
<ul>
<li>For a parameter, <code>impl Trait</code> is like an anonymous generic parameter with a trait bound.</li>
<li>For a return type, it means that the return type is some concrete type that implements the trait,
without naming the type. This can be useful when you don't want to expose the concrete type in a
public API.</li>
</ul>
<p>This example is great, because it uses <code>impl Display</code> twice. It helps to explain that
nothing here enforces that it is <em>the same</em> <code>impl Display</code> type. If we used a single
<code>T: Display</code>, it would enforce the constraint that input <code>T</code> and return <code>T</code> type are the same type.
It would not work for this particular function, as the type we expect as input is likely not
what <code>format!</code> returns. If we wanted to do the same via <code>: Display</code> syntax, we'd need two
independent generic parameters.</p>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="monomorphization"><a class="header" href="#monomorphization">Monomorphization</a></h1>
<p>Generic code is turned into non-generic code based on the call sites:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let integer = Some(5);
    let float = Some(5.0);
}
</code></pre></pre>
<p>behaves as if you wrote</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">enum Option_i32 {
    Some(i32),
    None,
}

enum Option_f64 {
    Some(f64),
    None,
}

fn main() {
    let integer = Option_i32::Some(5);
    let float = Option_f64::Some(5.0);
}
</code></pre></pre>
<p>This is a zero-cost abstraction: you get exactly the same result as if you had
hand-coded the data structures without the abstraction.</p>
<details>
<p><a href="https://rustc-dev-guide.rust-lang.org/backend/monomorph.html">Monomorphization</a></p>
<p>&quot;In Rust, the compiler stamps out a different copy of the code of a generic function for each concrete type needed. For example, if I use a <code>Vec&lt;u64&gt;</code> and a <code>Vec&lt;String&gt;</code> in my code, then the generated binary will have two copies of the generated code for Vec: one for <code>Vec&lt;u64&gt;</code> and another for <code>Vec&lt;String&gt;</code>. The result is fast programs, but it comes at the cost of compile time (creating all those copies can take a while) and binary size (all those copies might take a lot of space).&quot; This is different from Java, where the precise type is known at run-time and (almost) all variables are reference values (ie pointer to a heap allocated object). This has performance cost because of the dereference for each access.</p>
</details><div style="break-before: page; page-break-before: always;"></div><h1 id="closures"><a class="header" href="#closures">Closures</a></h1>
<p>Closures (also known as lambda expressions) are anonymous functions that can
capture values from their environment.</p>
<details>
<ul>
<li>Closures have a unique, anonymous type - you can't name it directly.</li>
<li>Use <code>impl Fn(...)</code> or <code>dyn Fn(...)</code> to accept closures as arguments.</li>
<li>Closures that don't capture anything can coerce to function pointers (<code>fn</code>).</li>
<li>The compiler infers whether a closure is <code>Fn</code>, <code>FnMut</code>, or <code>FnOnce</code> based on
how it uses captured variables.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="closure-syntax"><a class="header" href="#closure-syntax">Closure Syntax</a></h1>
<p>Closures are created with vertical bars: <code>|..| ..</code>.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    // Argument and return type can be inferred for lightweight syntax:
    let double_it = |n| n * 2;
    dbg!(double_it(50));

    // Or we can specify types and bracket the body to be fully explicit:
    let add_1f32 = |x: f32| -&gt; f32 { x + 1.0 };
    dbg!(add_1f32(50.));
}
</code></pre></pre>
<details>
<p><strong>Key points for speakers:</strong></p>
<ul>
<li><code>|args| body</code> is the basic closure syntax ‚Äî pipes instead of parentheses.</li>
<li>Type inference is powerful ‚Äî often no annotations needed.</li>
<li>Single-expression bodies don't need braces; multi-statement bodies do.</li>
<li>Without captures, closures are similar to nested functions.</li>
</ul>
<p><strong>Common student questions:</strong></p>
<ul>
<li><em>&quot;How is this different from a function?&quot;</em> - Closures can capture variables from their environment; functions cannot.</li>
<li><em>&quot;Why pipes instead of parentheses?&quot;</em> - Distinguishes closures from function calls syntactically.</li>
<li><em>&quot;When do I need type annotations?&quot;</em> - When inference fails (ambiguous) or for documentation clarity.</li>
<li><em>&quot;What's dbg!?&quot;</em> - A debug macro that prints the expression, its value, and returns the value.</li>
</ul>
<p><strong>Comparison with other languages:</strong></p>
<ul>
<li>JavaScript: <code>(n) =&gt; n * 2</code></li>
<li>Python: <code>lambda n: n * 2</code></li>
<li>Rust: <code>|n| n * 2</code></li>
</ul>
<p><strong>Demo suggestion:</strong>
Show that the closure type cannot be named:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let f = |x| x + 1;
// fn takes_closure(f: ???) { }  // Can't write the type!
fn takes_closure(f: impl Fn(i32) -&gt; i32) { }  // Use trait instead
<span class="boring">}
</span></code></pre></pre>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="capturing"><a class="header" href="#capturing">Capturing</a></h1>
<p>A closure can capture variables from the environment where it was defined.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let max_value = 5;
    let clamp = |v| {
        if v &gt; max_value { max_value } else { v }
    };

    dbg!(clamp(1));
    dbg!(clamp(3));
    dbg!(clamp(5));
    dbg!(clamp(7));
    dbg!(clamp(10));
}
</code></pre></pre>
<details>
<p><strong>Key points for speakers:</strong></p>
<ul>
<li>Closures capture variables from their environment ‚Äî this is what makes them &quot;closures.&quot;</li>
<li>Capture mode is inferred: shared reference ‚Üí exclusive reference ‚Üí move.</li>
<li><code>move</code> keyword forces capture by value (ownership transfer).</li>
<li>The borrow checker enforces capture rules at compile time.</li>
</ul>
<p><strong>Common student questions:</strong></p>
<ul>
<li><em>&quot;Why can main still use max_value?&quot;</em> - It's captured by reference, not moved. The closure borrows it.</li>
<li><em>&quot;What if I want to mutate a captured value?&quot;</em> - The closure needs <code>mut</code> and captures by <code>&amp;mut</code>. Try <code>let mut max_value</code> and adding mutation.</li>
<li><em>&quot;When do I need <code>move</code>?&quot;</em> - When the closure outlives the captured variables, e.g., spawning threads.</li>
<li><em>&quot;Can I capture some by move and others by reference?&quot;</em> - Yes, Rust 2021 introduced disjoint capture; older editions captured whole structs.</li>
</ul>
<p><strong>Interactive exercises:</strong></p>
<ol>
<li>Make <code>max_value</code> mutable and try to change it after defining <code>clamp</code>. Why doesn't this work?</li>
<li>Add <code>max_value += 1</code> inside <code>clamp</code>. What error do you get?</li>
<li>Add <code>move</code> before <code>|v|</code>. Can you still print <code>max_value</code> afterward?</li>
</ol>
<p><strong>Thread example:</strong></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let data = vec![1, 2, 3];
std::thread::spawn(move || {
    println!(&quot;{:?}&quot;, data);  // data is moved into the thread
});
// data is no longer accessible here
<span class="boring">}
</span></code></pre></pre>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="closure-traits"><a class="header" href="#closure-traits">Closure Traits</a></h1>
<p>Closures or lambda expressions have types that cannot be named. However, they
implement special <a href="https://doc.rust-lang.org/std/ops/trait.Fn.html"><code>Fn</code></a>,
<a href="https://doc.rust-lang.org/std/ops/trait.FnMut.html"><code>FnMut</code></a>, and
<a href="https://doc.rust-lang.org/std/ops/trait.FnOnce.html"><code>FnOnce</code></a> traits:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn apply_and_log(
    func: impl FnOnce(&amp;'static str) -&gt; String,
    func_name: &amp;'static str,
    input: &amp;'static str,
) {
    println!(&quot;Calling {func_name}({input}): {}&quot;, func(input))
}

fn main() {
    let suffix = &quot;-itis&quot;;
    let add_suffix = |x| format!(&quot;{x}{suffix}&quot;);
    apply_and_log(&amp;add_suffix, &quot;add_suffix&quot;, &quot;senior&quot;);
    apply_and_log(&amp;add_suffix, &quot;add_suffix&quot;, &quot;appendix&quot;);

    let mut v = Vec::new();
    let mut accumulate = |x| {
        v.push(x);
        v.join(&quot;/&quot;)
    };
    apply_and_log(&amp;mut accumulate, &quot;accumulate&quot;, &quot;red&quot;);
    apply_and_log(&amp;mut accumulate, &quot;accumulate&quot;, &quot;green&quot;);
    apply_and_log(&amp;mut accumulate, &quot;accumulate&quot;, &quot;blue&quot;);

    let take_and_reverse = |prefix| {
        let mut acc = String::from(prefix);
        acc.push_str(&amp;v.into_iter().rev().collect::&lt;Vec&lt;_&gt;&gt;().join(&quot;/&quot;));
        acc
    };
    apply_and_log(take_and_reverse, &quot;take_and_reverse&quot;, &quot;reversed: &quot;);
}
</code></pre></pre>
<details>
<p><strong>Key points for speakers:</strong></p>
<ul>
<li>Three traits form a hierarchy: <code>Fn</code> ‚äÇ <code>FnMut</code> ‚äÇ <code>FnOnce</code>.</li>
<li>Trait is determined by what the closure does with captured values.</li>
<li><code>Fn</code>: borrows immutably, can call multiple times, even concurrently.</li>
<li><code>FnMut</code>: borrows mutably, can call multiple times, not concurrently.</li>
<li><code>FnOnce</code>: consumes captures, can only call once.</li>
</ul>
<p><strong>Common student questions:</strong></p>
<ul>
<li><em>&quot;How do I know which trait my closure implements?&quot;</em> - The compiler infers it from usage. If it mutates ‚Üí <code>FnMut</code>. If it consumes ‚Üí <code>FnOnce</code>. Otherwise ‚Üí <code>Fn</code>.</li>
<li><em>&quot;Why the hierarchy?&quot;</em> - An <code>Fn</code> can do less, so it can substitute for <code>FnMut</code> or <code>FnOnce</code>. More restrictive = more flexible usage.</li>
<li><em>&quot;Which should I require in my function signature?&quot;</em> - Accept <code>FnOnce</code> if possible (most flexible for callers). Only require <code>Fn</code> if you need concurrent calls.</li>
<li><em>&quot;What about the &amp; and &amp;mut in the example?&quot;</em> - <code>&amp;add_suffix</code> passes by shared ref (Fn), <code>&amp;mut accumulate</code> by exclusive ref (FnMut), <code>take_and_reverse</code> by value (FnOnce).</li>
</ul>
<p><strong>Memory aid:</strong></p>
<ul>
<li><code>Fn</code>: Pure function (no side effects on captured state)</li>
<li><code>FnMut</code>: Mutates state (has side effects)</li>
<li><code>FnOnce</code>: Consumes state (one-shot)</li>
</ul>
<p><strong>Design tip:</strong>
When writing APIs that take closures, prefer <code>FnOnce</code> ‚Üí <code>FnMut</code> ‚Üí <code>Fn</code> (most to least restrictive for the implementation, most to least flexible for callers).</p>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="trait-objects"><a class="header" href="#trait-objects">Trait Objects</a></h1>
<p>We've seen how a function can take arguments which implement a trait:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::fmt::Display;

fn print&lt;T: Display&gt;(x: T) {
    println!(&quot;Your value: {}&quot;, x);
}

fn main() {
    print(123);
    print(&quot;Hello&quot;);
}
</code></pre></pre>
<p>However, how can we store a collection of mixed types which implement <code>Display</code>?</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail edition2021">fn main() {
    let xs = vec![123, &quot;Hello&quot;];
}
</code></pre></pre>
<p>For this, we need <em>trait objects</em>:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::fmt::Display;

fn main() {
    let xs: Vec&lt;Box&lt;dyn Display&gt;&gt; = vec![Box::new(123), Box::new(&quot;Hello&quot;)];
    for x in xs {
        println!(&quot;x: {x}&quot;);
    }
}
</code></pre></pre>
<p>Memory layout after allocating <code>xs</code>:</p>
<div style='width:100%; height:416px;'><style type="text/css">svg { width: 100% !important; }</style><svg xmlns="http://www.w3.org/2000/svg" width="672" height="416" class="svgbob"><style>.svgbob line, .svgbob path, .svgbob circle, .svgbob rect, .svgbob polygon {  stroke: var(--fg);  stroke-width: 2;  stroke-opacity: 1;  fill-opacity: 1;  stroke-linecap: round;  stroke-linejoin: miter;}.svgbob text {  white-space: pre;  fill: var(--fg);  font-family: Iosevka Fixed, monospace;  font-size: 14px;}.svgbob rect.backdrop {  stroke: none;  fill: transparent;}.svgbob .broken {  stroke-dasharray: 8;}.svgbob .filled {  fill: black;}.svgbob .bg_filled {  fill: transparent;  stroke-width: 1;}.svgbob .nofill {  fill: transparent;}.svgbob .end_marked_arrow {  marker-end: url(#arrow);}.svgbob .start_marked_arrow {  marker-start: url(#arrow);}.svgbob .end_marked_diamond {  marker-end: url(#diamond);}.svgbob .start_marked_diamond {  marker-start: url(#diamond);}.svgbob .end_marked_circle {  marker-end: url(#circle);}.svgbob .start_marked_circle {  marker-start: url(#circle);}.svgbob .end_marked_open_circle {  marker-end: url(#open_circle);}.svgbob .start_marked_open_circle {  marker-start: url(#open_circle);}.svgbob .end_marked_big_open_circle {  marker-end: url(#big_open_circle);}.svgbob .start_marked_big_open_circle {  marker-start: url(#big_open_circle);}</style><defs><marker id="arrow" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,0 0,4 4,2 0,0"></polygon></marker><marker id="diamond" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,2 2,0 4,2 2,4 0,2"></polygon></marker><marker id="circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2" class="filled"></circle></marker><marker id="open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2" class="bg_filled"></circle></marker><marker id="big_open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="3" class="bg_filled"></circle></marker></defs><rect class="backdrop" x="0" y="0" width="672" height="416"></rect><rect x="420" y="184" width="208" height="32" class="solid nofill" rx="0"></rect><text x="434" y="204" >&lt;str as Display&gt;::fmt</text><rect x="372" y="312" width="208" height="32" class="solid nofill" rx="0"></rect><text x="386" y="332" >&lt;i32 as Display&gt;::fmt</text><text x="10" y="12" >Stack</text><line x1="24" y1="24" x2="32" y2="24" class="solid"></line><line x1="40" y1="24" x2="48" y2="24" class="solid"></line><text x="282" y="12" >Heap</text><line x1="296" y1="24" x2="304" y2="24" class="solid"></line><line x1="312" y1="24" x2="320" y2="24" class="solid"></line><text x="42" y="60" >xs</text><text x="50" y="92" >ptr</text><line x1="176" y1="88" x2="164" y2="88" class="solid end_marked_open_circle"></line><line x1="176" y1="88" x2="296" y2="88" class="solid"></line><polygon points="296,84 304,88 296,92" class="filled"></polygon><line x1="324" y1="92" x2="324" y2="88" class="solid end_marked_open_circle"></line><line x1="340" y1="92" x2="340" y2="88" class="solid end_marked_open_circle"></line><line x1="372" y1="92" x2="372" y2="88" class="solid end_marked_open_circle"></line><line x1="388" y1="92" x2="388" y2="88" class="solid end_marked_open_circle"></line><text x="50" y="108" >len</text><text x="178" y="108" >2</text><text x="50" y="124" >capacity</text><text x="178" y="124" >2</text><polygon points="408,132 416,136 408,140" class="filled"></polygon><text x="434" y="140" >H</text><text x="474" y="140" >e</text><text x="514" y="140" >l</text><text x="554" y="140" >l</text><text x="594" y="140" >o</text><polygon points="408,196 416,200 408,204" class="filled"></polygon><polygon points="360,260 368,264 360,268" class="filled"></polygon><text x="386" y="268" >7b</text><text x="426" y="268" >00</text><text x="466" y="268" >00</text><text x="506" y="268" >00</text><polygon points="360,324 368,328 360,332" class="filled"></polygon><line x1="56" y1="24" x2="64" y2="24" class="solid"></line><line x1="72" y1="24" x2="80" y2="24" class="solid"></line><line x1="88" y1="24" x2="96" y2="24" class="solid"></line><line x1="104" y1="24" x2="112" y2="24" class="solid"></line><line x1="120" y1="24" x2="128" y2="24" class="solid"></line><line x1="136" y1="24" x2="144" y2="24" class="solid"></line><line x1="152" y1="24" x2="160" y2="24" class="solid"></line><line x1="168" y1="24" x2="176" y2="24" class="solid"></line><line x1="184" y1="24" x2="192" y2="24" class="solid"></line><line x1="200" y1="24" x2="208" y2="24" class="solid"></line><line x1="328" y1="24" x2="336" y2="24" class="solid"></line><line x1="344" y1="24" x2="352" y2="24" class="solid"></line><line x1="360" y1="24" x2="368" y2="24" class="solid"></line><line x1="376" y1="24" x2="384" y2="24" class="solid"></line><line x1="392" y1="24" x2="400" y2="24" class="solid"></line><line x1="408" y1="24" x2="416" y2="24" class="solid"></line><line x1="424" y1="24" x2="432" y2="24" class="solid"></line><line x1="440" y1="24" x2="448" y2="24" class="solid"></line><line x1="456" y1="24" x2="464" y2="24" class="solid"></line><line x1="472" y1="24" x2="480" y2="24" class="solid"></line><line x1="488" y1="24" x2="496" y2="24" class="solid"></line><line x1="504" y1="24" x2="512" y2="24" class="solid"></line><line x1="520" y1="24" x2="528" y2="24" class="solid"></line><line x1="536" y1="24" x2="544" y2="24" class="solid"></line><line x1="552" y1="24" x2="560" y2="24" class="solid"></line><line x1="568" y1="24" x2="576" y2="24" class="solid"></line><line x1="584" y1="24" x2="592" y2="24" class="solid"></line><line x1="600" y1="24" x2="608" y2="24" class="solid"></line><line x1="616" y1="24" x2="624" y2="24" class="solid"></line><line x1="632" y1="24" x2="640" y2="24" class="solid"></line><line x1="24" y1="168" x2="32" y2="168" class="solid"></line><line x1="40" y1="168" x2="48" y2="168" class="solid"></line><line x1="56" y1="168" x2="64" y2="168" class="solid"></line><line x1="72" y1="168" x2="80" y2="168" class="solid"></line><line x1="88" y1="168" x2="96" y2="168" class="solid"></line><line x1="104" y1="168" x2="112" y2="168" class="solid"></line><line x1="120" y1="168" x2="128" y2="168" class="solid"></line><line x1="136" y1="168" x2="144" y2="168" class="solid"></line><line x1="152" y1="168" x2="160" y2="168" class="solid"></line><line x1="168" y1="168" x2="176" y2="168" class="solid"></line><line x1="184" y1="168" x2="192" y2="168" class="solid"></line><line x1="200" y1="168" x2="208" y2="168" class="solid"></line><line x1="296" y1="392" x2="304" y2="392" class="solid"></line><line x1="312" y1="392" x2="320" y2="392" class="solid"></line><line x1="328" y1="392" x2="336" y2="392" class="solid"></line><line x1="344" y1="392" x2="352" y2="392" class="solid"></line><line x1="360" y1="392" x2="368" y2="392" class="solid"></line><line x1="376" y1="392" x2="384" y2="392" class="solid"></line><line x1="392" y1="392" x2="400" y2="392" class="solid"></line><line x1="408" y1="392" x2="416" y2="392" class="solid"></line><line x1="424" y1="392" x2="432" y2="392" class="solid"></line><line x1="440" y1="392" x2="448" y2="392" class="solid"></line><line x1="456" y1="392" x2="464" y2="392" class="solid"></line><line x1="472" y1="392" x2="480" y2="392" class="solid"></line><line x1="488" y1="392" x2="496" y2="392" class="solid"></line><line x1="504" y1="392" x2="512" y2="392" class="solid"></line><line x1="520" y1="392" x2="528" y2="392" class="solid"></line><line x1="536" y1="392" x2="544" y2="392" class="solid"></line><line x1="552" y1="392" x2="560" y2="392" class="solid"></line><line x1="568" y1="392" x2="576" y2="392" class="solid"></line><line x1="584" y1="392" x2="592" y2="392" class="solid"></line><line x1="600" y1="392" x2="608" y2="392" class="solid"></line><line x1="616" y1="392" x2="624" y2="392" class="solid"></line><line x1="632" y1="392" x2="640" y2="392" class="solid"></line><g><path d="M 8,24 A 4,4 0,0,0 4,28" class="nofill"></path><line x1="4" y1="28" x2="4" y2="164" class="broken"></line><line x1="8" y1="24" x2="16" y2="24" class="solid"></line><path d="M 4,164 A 4,4 0,0,0 8,168" class="nofill"></path><line x1="8" y1="168" x2="16" y2="168" class="solid"></line></g><g><line x1="216" y1="24" x2="224" y2="24" class="solid"></line><path d="M 224,24 A 4,4 0,0,1 228,28" class="nofill"></path><line x1="228" y1="28" x2="228" y2="164" class="broken"></line><line x1="216" y1="168" x2="224" y2="168" class="solid"></line><path d="M 228,164 A 4,4 0,0,1 224,168" class="nofill"></path></g><g><path d="M 280,24 A 4,4 0,0,0 276,28" class="nofill"></path><line x1="276" y1="28" x2="276" y2="388" class="broken"></line><line x1="280" y1="24" x2="288" y2="24" class="solid"></line><path d="M 276,388 A 4,4 0,0,0 280,392" class="nofill"></path><line x1="280" y1="392" x2="288" y2="392" class="solid"></line></g><g><line x1="36" y1="72" x2="196" y2="72" class="solid"></line><line x1="36" y1="72" x2="36" y2="136" class="solid"></line><line x1="132" y1="72" x2="132" y2="136" class="solid"></line><line x1="196" y1="72" x2="196" y2="136" class="solid"></line><line x1="36" y1="136" x2="196" y2="136" class="solid"></line></g><g><line x1="308" y1="72" x2="404" y2="72" class="solid"></line><line x1="308" y1="72" x2="308" y2="104" class="solid"></line><line x1="356" y1="72" x2="356" y2="104" class="solid"></line><line x1="404" y1="72" x2="404" y2="104" class="solid"></line><line x1="308" y1="104" x2="404" y2="104" class="solid"></line></g><g><line x1="324" y1="96" x2="324" y2="324" class="solid"></line><path d="M 324,324 A 4,4 0,0,0 328,328" class="nofill"></path><line x1="328" y1="328" x2="360" y2="328" class="solid"></line></g><g><line x1="340" y1="96" x2="340" y2="260" class="solid"></line><path d="M 340,260 A 4,4 0,0,0 344,264" class="nofill"></path><line x1="344" y1="264" x2="360" y2="264" class="solid"></line></g><g><line x1="372" y1="96" x2="372" y2="196" class="solid"></line><path d="M 372,196 A 4,4 0,0,0 376,200" class="nofill"></path><line x1="376" y1="200" x2="408" y2="200" class="solid"></line></g><g><line x1="388" y1="96" x2="388" y2="132" class="solid"></line><path d="M 388,132 A 4,4 0,0,0 392,136" class="nofill"></path><line x1="392" y1="136" x2="408" y2="136" class="solid"></line></g><g><line x1="420" y1="120" x2="620" y2="120" class="solid"></line><line x1="420" y1="120" x2="420" y2="152" class="solid"></line><line x1="460" y1="120" x2="460" y2="152" class="solid"></line><line x1="500" y1="120" x2="500" y2="152" class="solid"></line><line x1="540" y1="120" x2="540" y2="152" class="solid"></line><line x1="580" y1="120" x2="580" y2="152" class="solid"></line><line x1="620" y1="120" x2="620" y2="152" class="solid"></line><line x1="420" y1="152" x2="620" y2="152" class="solid"></line></g><g><line x1="372" y1="248" x2="532" y2="248" class="solid"></line><line x1="372" y1="248" x2="372" y2="280" class="solid"></line><line x1="412" y1="248" x2="412" y2="280" class="solid"></line><line x1="452" y1="248" x2="452" y2="280" class="solid"></line><line x1="492" y1="248" x2="492" y2="280" class="solid"></line><line x1="532" y1="248" x2="532" y2="280" class="solid"></line><line x1="372" y1="280" x2="532" y2="280" class="solid"></line></g><g><line x1="648" y1="24" x2="656" y2="24" class="solid"></line><path d="M 656,24 A 4,4 0,0,1 660,28" class="nofill"></path><line x1="660" y1="28" x2="660" y2="388" class="broken"></line><line x1="648" y1="392" x2="656" y2="392" class="solid"></line><path d="M 660,388 A 4,4 0,0,1 656,392" class="nofill"></path></g></svg></div>
<p>Similarly, you need a trait object if you want to return different values
implementing a trait:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn numbers(n: i32) -&gt; Box&lt;dyn Iterator&lt;Item=i32&gt;&gt; {
    if n &gt; 0 {
        Box::new(0..n)
    } else {
        Box::new((n..0).rev())
    }
}

fn main() {
    println!(&quot;{:?}&quot;, numbers(-5).collect::&lt;Vec&lt;_&gt;&gt;());
    println!(&quot;{:?}&quot;, numbers(5).collect::&lt;Vec&lt;_&gt;&gt;());
}
</code></pre></pre>
<details>
<ul>
<li>Generics use monomorphization to create specialized instances for each type.
This is called static dispatch.</li>
<li><code>dyn Trait</code> uses dynamic dispatch through a virtual method table (vtable).
There's only one version of the function regardless of the concrete type.</li>
<li>A <code>&amp;dyn Trait</code> is a &quot;fat pointer&quot;: one pointer to the data, one to the vtable.</li>
<li>Types in a <code>Vec&lt;Box&lt;dyn Trait&gt;&gt;</code> are &quot;type-erased&quot; - we don't know the
concrete type at compile time.</li>
<li>Not all traits can be made into trait objects. The trait must be &quot;object-safe&quot;
(no <code>Self</code> in return types, no generic methods).</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="course-5-exercises"><a class="header" href="#course-5-exercises">Course 5 Exercises</a></h1>
<p>We will design a classical GUI library traits and trait objects.</p>
<!-- <details>

After looking at the exercises, you can look at the [solutions] provided.

[solutions]: solutions-morning.md

</details> -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="a-simple-gui-library"><a class="header" href="#a-simple-gui-library">A Simple GUI Library</a></h1>
<p>Let us design a classical GUI library using our new knowledge of traits and
trait objects.</p>
<p>We will have a number of widgets in our library:</p>
<ul>
<li><code>Window</code>: has a <code>title</code> and contains other widgets.</li>
<li><code>Button</code>: has a <code>label</code> and a callback function which is invoked when the
button is pressed.</li>
<li><code>Label</code>: has a <code>label</code>.</li>
</ul>
<p>The widgets will implement a <code>Widget</code> trait, see below.</p>
<p>Copy the code below to <a href="https://play.rust-lang.org/">https://play.rust-lang.org/</a>, fill in the missing
<code>draw_into</code> methods so that you implement the <code>Widget</code> trait:</p>
<pre><pre class="playground"><code class="language-rust should_panic edition2021">// TODO: remove this when you're done with your implementation.
#![allow(unused_imports, unused_variables, dead_code)]

pub trait Widget {
    /// Natural width of `self`.
    fn width(&amp;self) -&gt; usize;

    /// Draw the widget into a buffer.
    fn draw_into(&amp;self, buffer: &amp;mut dyn std::fmt::Write);

    /// Draw the widget on standard output.
    fn draw(&amp;self) {
        let mut buffer = String::new();
        self.draw_into(&amp;mut buffer);
        println!(&quot;{}&quot;, &amp;buffer);
    }
}

pub struct Label {
    label: String,
}

impl Label {
    fn new(label: &amp;str) -&gt; Label {
        Label {
            label: label.to_owned(),
        }
    }
}

pub struct Button {
    label: Label,
    callback: Box&lt;dyn FnMut()&gt;,
}

impl Button {
    fn new(label: &amp;str, callback: Box&lt;dyn FnMut()&gt;) -&gt; Button {
        Button {
            label: Label::new(label),
            callback,
        }
    }
}

pub struct Window {
    title: String,
    widgets: Vec&lt;Box&lt;dyn Widget&gt;&gt;,
}

impl Window {
    fn new(title: &amp;str) -&gt; Window {
        Window {
            title: title.to_owned(),
            widgets: Vec::new(),
        }
    }

    fn add_widget(&amp;mut self, widget: Box&lt;dyn Widget&gt;) {
        self.widgets.push(widget);
    }
}


impl Widget for Label {
    fn width(&amp;self) -&gt; usize {
        unimplemented!()
    }

    fn draw_into(&amp;self, buffer: &amp;mut dyn std::fmt::Write) {
        unimplemented!()
    }
}

impl Widget for Button {
    fn width(&amp;self) -&gt; usize {
        unimplemented!()
    }

    fn draw_into(&amp;self, buffer: &amp;mut dyn std::fmt::Write) {
        unimplemented!()
    }
}

impl Widget for Window {
    fn width(&amp;self) -&gt; usize {
        unimplemented!()
    }

    fn draw_into(&amp;self, buffer: &amp;mut dyn std::fmt::Write) {
        unimplemented!()
    }
}

fn main() {
    let mut window = Window::new(&quot;Rust GUI Demo 1.23&quot;);
    window.add_widget(Box::new(Label::new(&quot;This is a small text GUI demo.&quot;)));
    window.add_widget(Box::new(Button::new(
        &quot;Click me!&quot;,
        Box::new(|| println!(&quot;You clicked the button!&quot;)),
    )));
    window.draw();
}
</code></pre></pre>
<p>The output of the above program can be something simple like this:</p>
<pre><code class="language-text">========
Rust GUI Demo 1.23
========

This is a small text GUI demo.

| Click me! |
</code></pre>
<p>If you want to draw aligned text, you can use the
<a href="https://doc.rust-lang.org/std/fmt/index.html#fillalignment">fill/alignment</a>
formatting operators. In particular, notice how you can pad with different
characters (here a <code>'/'</code>) and how you can control alignment:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let width = 10;
    println!(&quot;left aligned:  |{:/&lt;width$}|&quot;, &quot;foo&quot;);
    println!(&quot;centered:      |{:/^width$}|&quot;, &quot;foo&quot;);
    println!(&quot;right aligned: |{:/&gt;width$}|&quot;, &quot;foo&quot;);
}
</code></pre></pre>
<p>Using such alignment tricks, you can for example produce output like this:</p>
<pre><code class="language-text">+--------------------------------+
|       Rust GUI Demo 1.23       |
+================================+
| This is a small text GUI demo. |
| +-----------+                  |
| | Click me! |                  |
| +-----------+                  |
+--------------------------------+
</code></pre>
<details>
<p><strong>Exercise guidance for speakers:</strong></p>
<ul>
<li>This exercise demonstrates trait objects (<code>dyn Widget</code>) and polymorphism.</li>
<li><code>Box&lt;dyn Widget&gt;</code> allows storing different widget types in the same Vec.</li>
<li>The <code>draw_into</code> method writes to any <code>Write</code> impl (testable with String buffer).</li>
<li>Focus on composition: Window contains other Widgets.</li>
</ul>
<p><strong>Key concepts practiced:</strong></p>
<ol>
<li>Trait definitions with multiple methods.</li>
<li>Implementing traits for multiple types.</li>
<li>Using trait objects for heterogeneous collections.</li>
<li><code>Box&lt;dyn Trait&gt;</code> for owned trait objects.</li>
</ol>
<p><strong>Hints to give if stuck:</strong></p>
<ul>
<li><code>width()</code> calculates the widget's width for layout.</li>
<li><code>draw_into</code> writes the widget's representation to the buffer.</li>
<li>Use <code>write!</code> and <code>writeln!</code> macros for formatting.</li>
<li>Window's width is the max of its children's widths plus borders.</li>
</ul>
<p><strong>Discussion points:</strong></p>
<ul>
<li>Why <code>Box&lt;dyn Widget&gt;</code> instead of generics?</li>
<li>Trade-offs of dynamic dispatch vs static dispatch.</li>
<li>How would you add a callback to Button?</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="exercise-log-filter"><a class="header" href="#exercise-log-filter">Exercise: Log Filter</a></h1>
<p>Implement a <code>Filter</code> that uses a closure to filter log messages, sending those
that pass the filtering predicate to an inner logger.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">pub trait Logger {
    /// Log a message at the given verbosity level.
    fn log(&amp;self, verbosity: u8, message: &amp;str);
}

struct StderrLogger;

impl Logger for StderrLogger {
    fn log(&amp;self, verbosity: u8, message: &amp;str) {
        eprintln!(&quot;verbosity={verbosity}: {message}&quot;);
    }
}

// TODO: Define and implement `Filter`.
// It should:
// - Store an inner logger
// - Store a predicate closure that takes (verbosity, message) and returns bool
// - Implement Logger, only forwarding messages where the predicate returns true

fn main() {
    let logger = Filter::new(StderrLogger, |_verbosity, msg| msg.contains(&quot;yikes&quot;));
    logger.log(5, &quot;FYI&quot;);
    logger.log(1, &quot;yikes, something went wrong&quot;);
    logger.log(2, &quot;uhoh&quot;);
}
</code></pre></pre>
<details>
<summary>Hints</summary>
<ul>
<li><code>Filter</code> needs two generic parameters: one for the inner logger type, and one
for the predicate closure type.</li>
<li>The predicate should be <code>Fn(u8, &amp;str) -&gt; bool</code>.</li>
<li>Remember to add trait bounds in both the <code>impl</code> block and the trait implementation.</li>
<li>Call the predicate with <code>(self.predicate)(verbosity, message)</code>.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><p>In this 6th course, we will discover</p>
<ul>
<li>
<p>Error handling: panics, <code>Result</code>, and the try operator <code>?</code>.</p>
</li>
<li>
<p>Testing: unit tests, documentation tests, and integration tests.</p>
</li>
<li>
<p>Unsafe Rust: raw pointers, static variables, unsafe functions, and extern
functions.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-handling"><a class="header" href="#error-handling">Error Handling</a></h1>
<p>Error handling in Rust is done using explicit control flow:</p>
<ul>
<li>Functions that can have errors list this in their return type,</li>
<li>There are no exceptions.</li>
</ul>
<p><a href="https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html">Doc on handling errors</a></p>
<details>
<p><strong>Key points for speakers:</strong></p>
<ul>
<li>Rust has NO exceptions. This is a deliberate design choice.</li>
<li>Errors are values that must be explicitly handled or propagated.</li>
<li>Two categories: recoverable (<code>Result</code>) and unrecoverable (<code>panic!</code>).</li>
</ul>
<p><strong>Common student questions:</strong></p>
<ul>
<li><em>&quot;Why no exceptions?&quot;</em> - Exceptions have hidden control flow. You can't tell from a function signature if it might throw. In Rust, errors are visible in the type signature.</li>
<li><em>&quot;Isn't this more verbose?&quot;</em> - The <code>?</code> operator makes it concise. And the explicitness prevents bugs from unhandled errors.</li>
<li><em>&quot;When should I panic vs return Result?&quot;</em> - Panic for bugs (should never happen), Result for expected failures (file not found, network error, invalid input).</li>
</ul>
<p><strong>Comparison with other languages:</strong></p>
<ul>
<li>Java: checked exceptions (verbose) or unchecked (invisible)</li>
<li>Python/JS: all exceptions are unchecked (easy to miss)</li>
<li>Go: similar to Rust with explicit error returns, but no <code>?</code> operator</li>
<li>Rust: explicit with ergonomic <code>?</code> operator</li>
</ul>
</details><div style="break-before: page; page-break-before: always;"></div><h1 id="panics"><a class="header" href="#panics">Panics</a></h1>
<p>Rust will trigger a panic if a fatal error happens at runtime:</p>
<pre><pre class="playground"><code class="language-rust editable should_panic edition2021">fn main() {
    let v = vec![10, 20, 30];
    println!(&quot;v[100]: {}&quot;, v[100]);
}
</code></pre></pre>
<ul>
<li>Panics are for unrecoverable and unexpected errors.
<ul>
<li>Panics are symptoms of bugs in the program.</li>
</ul>
</li>
<li>Use non-panicking APIs (such as <code>Vec::get</code>) if crashing is not acceptable.</li>
</ul>
<details>
<ul>
<li>By default, a panic will unwind the stack and clean up resources.</li>
<li>You can use <code>panic = 'abort'</code> in <code>Cargo.toml</code> to abort immediately instead.</li>
<li><code>unwrap()</code> and <code>expect()</code> panic if called on <code>None</code> or <code>Err</code>.</li>
<li>Use <code>Result</code> for recoverable errors, panics for unrecoverable ones.</li>
<li>The <code>RUST_BACKTRACE=1</code> environment variable shows a stack trace on panic.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="catching-the-stack-unwinding"><a class="header" href="#catching-the-stack-unwinding">Catching the Stack Unwinding</a></h1>
<p>By default, a panic will cause the stack to unwind. The unwinding can be caught:</p>
<pre><pre class="playground"><code class="language-rust edition2021">#![allow(unused)]
fn main() {
use std::panic;

let result = panic::catch_unwind(|| {
    println!(&quot;hello!&quot;);
});
assert!(result.is_ok());

let result = panic::catch_unwind(|| {
    panic!(&quot;oh no!&quot;);
});
assert!(result.is_err());
}
</code></pre></pre>
<ul>
<li>This can be useful in servers which should keep running even if a single
request crashes.</li>
<li>This does not work if <code>panic = 'abort'</code> is set in your <code>Cargo.toml</code>.</li>
</ul>
<details>
<p>The <code>panic!</code> macro can be used to generate a panic and start unwinding its stack. While unwinding, the runtime will take care of freeing all the resources owned by the thread by calling the destructor of all its objects.</p>
<p><code>assert!</code> asserts that a boolean expression is <code>true</code> at runtime. This will invoke the <code>panic!</code> macro if the provided expression cannot be evaluated to true at runtime.</p>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="structured-error-handling-with-result"><a class="header" href="#structured-error-handling-with-result">Structured Error Handling with <code>Result</code></a></h1>
<p>We have already seen the <code>Result</code> enum. This is used pervasively when errors are
expected as part of normal operation:</p>
<pre><pre class="playground"><code class="language-rust edition2021">use std::fs::File;
use std::io::Read;

fn main() {
    let file = File::open(&quot;diary.txt&quot;);
    match file {
        Ok(mut file) =&gt; {
            let mut contents = String::new();
            file.read_to_string(&amp;mut contents);
            println!(&quot;Dear diary: {contents}&quot;);
        },
        Err(err) =&gt; {
            println!(&quot;The diary could not be opened: {err}&quot;);
        }
    }
}
</code></pre></pre>
<details>
<ul>
<li>As with <code>Option</code>, the successful value sits inside of <code>Result</code>, forcing the developer to
explicitly extract it. This encourages error checking. In the case where an error should never happen,
<code>unwrap()</code> or <code>expect()</code> can be called, and this is a signal of the developer intent too.</li>
<li><code>Result</code> documentation is a recommended read. Not during the course, but it is worth mentioning.
It contains a lot of convenience methods and functions that help functional-style programming.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="propagating-errors-with-"><a class="header" href="#propagating-errors-with-">Propagating Errors with <code>?</code></a></h1>
<p>The try-operator <code>?</code> is used to return errors to the caller. It lets you turn
the common</p>
<pre><code class="language-rust ignore">match some_expression {
    Ok(value) =&gt; value,
    Err(err) =&gt; return Err(err),
}
</code></pre>
<p>into the much simpler</p>
<pre><code class="language-rust ignore">some_expression?
</code></pre>
<p>We can use this to simplify our error handing code:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::fs;
use std::io::{self, Read};

fn read_username(path: &amp;str) -&gt; Result&lt;String, io::Error&gt; {
    let username_file_result = fs::File::open(path);

    let mut username_file = match username_file_result {
        Ok(file) =&gt; file,
        Err(e) =&gt; return Err(e),
    };

    let mut username = String::new();

    match username_file.read_to_string(&amp;mut username) {
        Ok(_) =&gt; Ok(username),
        Err(e) =&gt; Err(e),
    }
}

fn main() {
    //fs::write(&quot;config.dat&quot;, &quot;alice&quot;).unwrap();
    let username = read_username(&quot;config.dat&quot;);
    println!(&quot;username or error: {username:?}&quot;);
}
</code></pre></pre>
<details>
<p>Key points:</p>
<ul>
<li>The <code>username</code> variable can be either <code>Ok(string)</code> or <code>Err(error)</code>.</li>
<li>Use the <code>fs::write</code> call to test out the different scenarios: no file, empty file, file with username.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="converting-error-types"><a class="header" href="#converting-error-types">Converting Error Types</a></h1>
<p>The effective expansion of <code>?</code> is a little more complicated than previously indicated:</p>
<pre><code class="language-rust ignore">expression?
</code></pre>
<p>works the same as</p>
<pre><code class="language-rust ignore">match expression {
    Ok(value) =&gt; value,
    Err(err)  =&gt; return Err(From::from(err)),
}
</code></pre>
<p>The <code>From::from</code> call here means we attempt to convert the error type to the
type returned by the function:</p>
<details>
<p><strong>Key points for speakers:</strong></p>
<ul>
<li>The <code>?</code> operator does automatic error conversion via <code>From::from</code>.</li>
<li>This is why <code>?</code> works across different error types ‚Äî if <code>From</code> is implemented.</li>
<li>You can implement <code>From&lt;SourceError&gt; for TargetError</code> to enable <code>?</code> conversion.</li>
<li>This pattern enables composable error handling across library boundaries.</li>
</ul>
<p><strong>Common student questions:</strong></p>
<ul>
<li><em>&quot;Why From::from and not just From?&quot;</em> - <code>From::from</code> is the method. The trait is <code>From</code>, the method is <code>from</code>. Type inference figures out which <code>From</code> implementation to use.</li>
<li><em>&quot;What if there's no From impl?&quot;</em> - Compile error! You need to either implement <code>From</code> or manually convert with <code>.map_err()</code>.</li>
<li><em>&quot;Can I chain multiple ? with different error types?&quot;</em> - Yes, as long as each error type can convert to the function's return error type.</li>
<li><em>&quot;What about Box<dyn Error>?&quot;</em> - Any error type that implements <code>Error</code> can convert to <code>Box&lt;dyn Error&gt;</code>, making it useful for prototyping.</li>
</ul>
<p><strong>Demo suggestion:</strong>
Show what happens when you use <code>?</code> without a matching <code>From</code> implementation ‚Äî the error message tells you exactly what's needed.</p>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="converting-error-types-1"><a class="header" href="#converting-error-types-1">Converting Error Types</a></h1>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::error::Error;
use std::fmt::{self, Display, Formatter};
use std::fs::{self, File};
use std::io::{self, Read};

#[derive(Debug)]
enum ReadUsernameError {
    IoError(io::Error),
    EmptyUsername(String),
}

impl Error for ReadUsernameError {}

impl Display for ReadUsernameError {
    fn fmt(&amp;self, f: &amp;mut Formatter) -&gt; fmt::Result {
        match self {
            Self::IoError(e) =&gt; write!(f, &quot;IO error: {}&quot;, e),
            Self::EmptyUsername(filename) =&gt; write!(f, &quot;Found no username in {}&quot;, filename),
        }
    }
}

impl From&lt;io::Error&gt; for ReadUsernameError {
    fn from(err: io::Error) -&gt; ReadUsernameError {
        ReadUsernameError::IoError(err)
    }
}

fn read_username(path: &amp;str) -&gt; Result&lt;String, ReadUsernameError&gt; {
    let mut username = String::with_capacity(100);
    File::open(path)?.read_to_string(&amp;mut username)?;
    if username.is_empty() {
        return Err(ReadUsernameError::EmptyUsername(String::from(path)));
    }
    Ok(username)
}

fn main() {
    //fs::write(&quot;config.dat&quot;, &quot;&quot;).unwrap();
    let username = read_username(&quot;config.dat&quot;);
    println!(&quot;username or error: {username:?}&quot;);
}
</code></pre></pre>
<details>
<p>Key points:</p>
<ul>
<li>The <code>username</code> variable can be either <code>Ok(string)</code> or <code>Err(error)</code>.</li>
<li>Use the <code>fs::write</code> call to test out the different scenarios: no file, empty file, file with username.</li>
</ul>
<p>It is good practice for all error types to implement <code>std::error::Error</code>, which requires <code>Debug</code> and
<code>Display</code>. It's generally helpful for them to implement <code>Clone</code> and <code>Eq</code> too where possible, to make
life easier for tests and consumers of your library. In this case we can't easily do so, because
<code>io::Error</code> doesn't implement them.</p>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="deriving-error-enums"><a class="header" href="#deriving-error-enums">Deriving Error Enums</a></h1>
<p>The <a href="https://docs.rs/thiserror/">thiserror</a> crate is a popular way to create an
error enum like we did on the previous page:</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail edition2021">use std::{fs, io};
use std::io::Read;
use thiserror::Error;

#[derive(Debug, Error)]
enum ReadUsernameError {
    #[error(&quot;Could not read: {0}&quot;)]
    IoError(#[from] io::Error),
    #[error(&quot;Found no username in {0}&quot;)]
    EmptyUsername(String),
}

fn read_username(path: &amp;str) -&gt; Result&lt;String, ReadUsernameError&gt; {
    let mut username = String::with_capacity(100);
    fs::File::open(path)?.read_to_string(&amp;mut username)?;
    if username.is_empty() {
        return Err(ReadUsernameError::EmptyUsername(String::from(path)));
    }
    Ok(username)
}

fn main() {
    //fs::write(&quot;config.dat&quot;, &quot;&quot;).unwrap();
    match read_username(&quot;config.dat&quot;) {
        Ok(username) =&gt; println!(&quot;Username: {username}&quot;),
        Err(err)     =&gt; println!(&quot;Error: {err}&quot;),
    }
}
</code></pre></pre>
<details>
<p><strong>Key points for speakers:</strong></p>
<ul>
<li><code>thiserror</code> is the go-to crate for library error types.</li>
<li><code>#[error(&quot;...&quot;)]</code> generates the <code>Display</code> implementation.</li>
<li><code>#[from]</code> generates <code>From</code> implementation for automatic <code>?</code> conversion.</li>
<li>It's a proc macro ‚Äî generates code at compile time, no runtime cost.</li>
</ul>
<p><strong>Common student questions:</strong></p>
<ul>
<li><em>&quot;thiserror vs anyhow ‚Äî when to use which?&quot;</em> - <code>thiserror</code> for libraries (structured errors), <code>anyhow</code> for applications (convenient catch-all).</li>
<li><em>&quot;What does #[from] do?&quot;</em> - Generates <code>impl From&lt;io::Error&gt; for ReadUsernameError</code>, enabling automatic conversion with <code>?</code>.</li>
<li><em>&quot;Can I have multiple #[from]?&quot;</em> - Yes, for different source error types. Each generates a separate <code>From</code> impl.</li>
<li><em>&quot;What about error chains?&quot;</em> - <code>thiserror</code> supports <code>#[source]</code> attribute to wrap underlying errors while preserving the chain.</li>
</ul>
<p><strong>Additional notes:</strong></p>
<ul>
<li><code>thiserror</code> doesn't affect your public API ‚Äî users don't need to depend on it.</li>
<li>Works for both enums and structs.</li>
<li>The <code>{0}</code> in error messages refers to tuple fields; use <code>{field_name}</code> for named fields.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dynamic-error-types"><a class="header" href="#dynamic-error-types">Dynamic Error Types</a></h1>
<p>Sometimes we want to allow any type of error to be returned without writing our own enum covering
all the different possibilities. <code>std::error::Error</code> makes this easy.</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail edition2021">use std::fs::{self, File};
use std::io::Read;
use thiserror::Error;
use std::error::Error;

#[derive(Clone, Debug, Eq, Error, PartialEq)]
#[error(&quot;Found no username in {0}&quot;)]
struct EmptyUsernameError(String);

fn read_username(path: &amp;str) -&gt; Result&lt;String, Box&lt;dyn Error&gt;&gt; {
    let mut username = String::with_capacity(100);
    File::open(path)?.read_to_string(&amp;mut username)?;
    if username.is_empty() {
        return Err(EmptyUsernameError(String::from(path)).into());
    }
    Ok(username)
}

fn main() {
    //fs::write(&quot;config.dat&quot;, &quot;&quot;).unwrap();
    match read_username(&quot;config.dat&quot;) {
        Ok(username) =&gt; println!(&quot;Username: {username}&quot;),
        Err(err)     =&gt; println!(&quot;Error: {err}&quot;),
    }
}
</code></pre></pre>
<details>
<p>This saves on code, but gives up the ability to cleanly handle different error cases differently in
the program. As such it's generally not a good idea to use <code>Box&lt;dyn Error&gt;</code> in the public API of a
library, but it can be a good option in a program where you just want to display the error message
somewhere.</p>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="adding-context-to-errors"><a class="header" href="#adding-context-to-errors">Adding Context to Errors</a></h1>
<p>The widely used <a href="https://docs.rs/anyhow/">anyhow</a> crate can help you add
contextual information to your errors and allows you to have fewer
custom error types:</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail edition2021">use std::{fs, io};
use std::io::Read;
use anyhow::{Context, Result, bail};

fn read_username(path: &amp;str) -&gt; Result&lt;String&gt; {
    let mut username = String::with_capacity(100);
    fs::File::open(path)
        .context(format!(&quot;Failed to open {path}&quot;))?
        .read_to_string(&amp;mut username)
        .context(&quot;Failed to read&quot;)?;
    if username.is_empty() {
        bail!(&quot;Found no username in {path}&quot;);
    }
    Ok(username)
}

fn main() {
    //fs::write(&quot;config.dat&quot;, &quot;&quot;).unwrap();
    match read_username(&quot;config.dat&quot;) {
        Ok(username) =&gt; println!(&quot;Username: {username}&quot;),
        Err(err)     =&gt; println!(&quot;Error: {err:?}&quot;),
    }
}
</code></pre></pre>
<details>
<p><strong>Key points for speakers:</strong></p>
<ul>
<li><code>anyhow</code> is the go-to crate for application error handling.</li>
<li><code>.context()</code> wraps errors with additional information.</li>
<li><code>bail!</code> is a macro for early returns with an error message.</li>
<li><code>anyhow::Result&lt;T&gt;</code> = <code>Result&lt;T, anyhow::Error&gt;</code>.</li>
</ul>
<p><strong>Common student questions:</strong></p>
<ul>
<li><em>&quot;anyhow vs thiserror?&quot;</em> - <code>anyhow</code> for applications (easy, flexible), <code>thiserror</code> for libraries (structured, typed).</li>
<li><em>&quot;What's the ? operator doing here?&quot;</em> - Same as before, but <code>context()</code> returns a Result with enriched error info.</li>
<li><em>&quot;Can I still pattern match on errors?&quot;</em> - Yes, use <code>.downcast_ref::&lt;MyError&gt;()</code> to get the original error type.</li>
<li><em>&quot;What about performance?&quot;</em> - <code>anyhow::Error</code> allocates. For hot paths, consider typed errors.</li>
</ul>
<p><strong>Additional notes:</strong></p>
<ul>
<li><code>anyhow::Error</code> wraps <code>Box&lt;dyn Error&gt;</code> ‚Äî type-erased, but flexible.</li>
<li>Great for prototyping and applications where error types don't need to be part of API.</li>
<li>Similar ergonomics to Go's <code>(T, error)</code> pattern.</li>
<li>Use <code>{err:?}</code> (Debug) to see full error chain, <code>{err}</code> (Display) for user-facing message.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="testing"><a class="header" href="#testing">Testing</a></h1>
<p>Rust and Cargo come with a simple unit test framework:</p>
<ul>
<li>
<p>Unit tests are supported throughout your code.</p>
</li>
<li>
<p>Integration tests are supported via the <code>tests/</code> directory.</p>
</li>
</ul>
<details>
<ul>
<li>Run tests with <code>cargo test</code>.</li>
<li>Tests run in parallel by default; use <code>cargo test -- --test-threads=1</code> for
sequential execution.</li>
<li>Use <code>cargo test &lt;name&gt;</code> to filter tests by name.</li>
<li>Tests that panic are considered failures unless marked with <code>#[should_panic]</code>.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="unit-tests"><a class="header" href="#unit-tests">Unit Tests</a></h1>
<p>Mark unit tests with <code>#[test]</code>:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn first_word(text: &amp;str) -&gt; &amp;str {
    match text.find(' ') {
        Some(idx) =&gt; &amp;text[..idx],
        None =&gt; &amp;text,
    }
}

#[test]
fn test_empty() {
    assert_eq!(first_word(&quot;&quot;), &quot;&quot;);
}

#[test]
fn test_single_word() {
    assert_eq!(first_word(&quot;Hello&quot;), &quot;Hello&quot;);
}

#[test]
fn test_multiple_words() {
    assert_eq!(first_word(&quot;Hello World&quot;), &quot;Hello&quot;);
}
</code></pre></pre>
<p>Use <code>cargo test</code> to find and run the unit tests.</p>
<details>
<ul>
<li>Unit tests are typically placed in the same file as the code being tested.</li>
<li>Use <code>#[cfg(test)]</code> on a <code>mod tests</code> block to only compile tests when running
<code>cargo test</code>.</li>
<li>This lets you unit test private helpers.</li>
<li>Common assertions: <code>assert!</code>, <code>assert_eq!</code>, <code>assert_ne!</code>.</li>
<li>Use <code>#[should_panic]</code> for tests that should panic.</li>
<li>Use <code>#[ignore]</code> to skip slow tests by default (run with <code>cargo test -- --ignored</code>).</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="test-modules"><a class="header" href="#test-modules">Test Modules</a></h1>
<p>Unit tests are often put in a nested module (run tests on the
<a href="https://play.rust-lang.org/">Playground</a>):</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn helper(a: &amp;str, b: &amp;str) -&gt; String {
    format!(&quot;{a} {b}&quot;)
}

pub fn main() {
    println!(&quot;{}&quot;, helper(&quot;Hello&quot;, &quot;World&quot;));
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_helper() {
        assert_eq!(helper(&quot;foo&quot;, &quot;bar&quot;), &quot;foo bar&quot;);
    }
}
</code></pre></pre>
<ul>
<li>This lets you unit test private helpers.</li>
<li>The <code>#[cfg(test)]</code> attribute is only active when you run <code>cargo test</code>.</li>
</ul>
<details>
<ul>
<li><code>#[cfg(test)]</code> means the module is only compiled during testing.</li>
<li><code>use super::*;</code> imports everything from the parent module.</li>
<li>Test modules can access private functions in the same file.</li>
<li>This pattern keeps tests close to the code they test.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="documentation-tests"><a class="header" href="#documentation-tests">Documentation Tests</a></h1>
<p>Rust has built-in support for documentation tests:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Shortens a string to the given length.
///
/// ```
/// use playground::shorten_string;
/// assert_eq!(shorten_string(&quot;Hello World&quot;, 5), &quot;Hello&quot;);
/// assert_eq!(shorten_string(&quot;Hello World&quot;, 20), &quot;Hello World&quot;);
/// ```
pub fn shorten_string(s: &amp;str, length: usize) -&gt; &amp;str {
    &amp;s[..std::cmp::min(length, s.len())]
}
<span class="boring">}
</span></code></pre></pre>
<ul>
<li>Code blocks in <code>///</code> comments are automatically seen as Rust code.</li>
<li>The code will be compiled and executed as part of <code>cargo test</code>.</li>
<li>Test the above code on the <a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=3ce2ad13ea1302f6572cb15cd96becf0">Rust Playground</a>.</li>
</ul>
<details>
<pre><code>pub fn shorten_string(s: &amp;str, length: usize) -&gt; &amp;str {
    &amp;s[..std::cmp::min(length, s.len())]
}

#[test]
fn test_single_word() {
    assert_eq!(shorten_string(&quot;Hello World&quot;,5), &quot;Hello&quot;);
}

#[test]
fn test_multiple_words() {
    assert_eq!(shorten_string(&quot;Hello World&quot;,20), &quot;Hello World&quot;);
}
</code></pre>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="integration-tests"><a class="header" href="#integration-tests">Integration Tests</a></h1>
<p>If you want to test your library as a client, use an integration test.</p>
<p>Create a <code>.rs</code> file under <code>tests/</code>:</p>
<pre><code class="language-rust ignore">use my_library::init;

#[test]
fn test_init() {
    assert!(init().is_ok());
}
</code></pre>
<p>These tests only have access to the public API of your crate.</p>
<details>
<ul>
<li>Integration tests live in the <code>tests/</code> directory at the crate root.</li>
<li>Each file in <code>tests/</code> is compiled as a separate crate.</li>
<li>Use <code>tests/common/mod.rs</code> for shared test utilities.</li>
<li>Integration tests are only for library crates (they can't access binary internals).</li>
<li>Run specific integration tests with <code>cargo test --test &lt;name&gt;</code>.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="unsafe-rust"><a class="header" href="#unsafe-rust">Unsafe Rust</a></h1>
<p>The Rust language has two parts:</p>
<ul>
<li><strong>Safe Rust:</strong> memory safe, no undefined behavior possible.</li>
<li><strong>Unsafe Rust:</strong> can trigger undefined behavior if preconditions are violated.</li>
</ul>
<p>We will be seeing mostly safe Rust in this course, but it's important to know
what Unsafe Rust is.</p>
<p>Unsafe code is usually small and isolated, and its correctness should be carefully
documented. It is usually wrapped in a safe abstraction layer.</p>
<p>Unsafe Rust gives you access to five new capabilities:</p>
<ul>
<li>Dereference raw pointers.</li>
<li>Access or modify mutable static variables.</li>
<li>Access <code>union</code> fields.</li>
<li>Call <code>unsafe</code> functions, including <code>extern</code> functions.</li>
<li>Implement <code>unsafe</code> traits.</li>
</ul>
<p>We will briefly cover unsafe capabilities next. For full details, please see
<a href="https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html">Chapter 19.1 in the Rust Book</a>
and the <a href="https://doc.rust-lang.org/nomicon/">Rustonomicon</a>.</p>
<details>
<p>Unsafe Rust does not mean the code is incorrect. It means that developers have
turned off the compiler safety features and have to write correct code by
themselves. It means the compiler no longer enforces Rust's memory-safety rules.</p>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dereferencing-raw-pointers"><a class="header" href="#dereferencing-raw-pointers">Dereferencing Raw Pointers</a></h1>
<p>Creating pointers is safe, but dereferencing them requires <code>unsafe</code>:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let mut num = 5;

    let r1 = &amp;mut num as *mut i32;
    let r2 = &amp;num as *const i32;

    // Safe because r1 and r2 were obtained from references and so are guaranteed to be non-null and
    // properly aligned, the objects underlying the references from which they were obtained are
    // live throughout the whole unsafe block, and they are not accessed either through the
    // references or concurrently through any other pointers.
    unsafe {
        println!(&quot;r1 is: {}&quot;, *r1);
        *r1 = 10;
        println!(&quot;r2 is: {}&quot;, *r2);
    }
}
</code></pre></pre>
<details>
<p>It is good practice (and required by the Android Rust style guide) to write a comment for each
<code>unsafe</code> block explaining how the code inside it satisfies the safety requirements of the unsafe
operations it is doing.</p>
<p>In the case of pointer dereferences, this means that the pointers must be
<a href="https://doc.rust-lang.org/std/ptr/index.html#safety"><em>valid</em></a>, i.e.:</p>
<ul>
<li>The pointer must be non-null.</li>
<li>The pointer must be <em>dereferenceable</em> (within the bounds of a single allocated object).</li>
<li>The object must not have been deallocated.</li>
<li>There must not be concurrent accesses to the same location.</li>
<li>If the pointer was obtained by casting a reference, the underlying object must be live and no
reference may be used to access the memory.</li>
</ul>
<p>In most cases the pointer must also be properly aligned.</p>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mutable-static-variables"><a class="header" href="#mutable-static-variables">Mutable Static Variables</a></h1>
<p>It is safe to read an immutable static variable:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">static HELLO_WORLD: &amp;str = &quot;Hello, world!&quot;;

fn main() {
    println!(&quot;HELLO_WORLD: {}&quot;, HELLO_WORLD);
}
</code></pre></pre>
<p>However, since data races can occur, it is unsafe to read and write mutable
static variables:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">static mut COUNTER: u32 = 0;

fn add_to_counter(inc: u32) {
    unsafe { COUNTER += inc; }  // Potential data race!
}

fn main() {
    add_to_counter(42);

    unsafe { println!(&quot;COUNTER: {}&quot;, COUNTER); }  // Potential data race!
}
</code></pre></pre>
<details>
<p><strong>Key points for speakers:</strong></p>
<ul>
<li>Immutable statics are safe and common ‚Äî they're truly global constants.</li>
<li>Mutable statics are <code>unsafe</code> because they can cause data races.</li>
<li>Every access to a <code>mut static</code> requires an <code>unsafe</code> block.</li>
<li>Prefer <code>Mutex</code>, <code>RwLock</code>, or atomics for shared mutable state.</li>
</ul>
<p><strong>Common student questions:</strong></p>
<ul>
<li><em>&quot;Why is reading also unsafe?&quot;</em> - Another thread might be writing simultaneously. Even reading during a write can observe torn values.</li>
<li><em>&quot;What should I use instead?&quot;</em> - <code>lazy_static!</code> or <code>once_cell</code> for lazy initialization, <code>Mutex&lt;T&gt;</code> for thread-safe mutation, atomics for simple counters.</li>
<li><em>&quot;When is static mut acceptable?&quot;</em> - Rare: embedded/no_std where you control all access, FFI globals, single-threaded programs.</li>
<li><em>&quot;What's a data race?&quot;</em> - Two threads accessing the same memory, at least one writing, with no synchronization. Undefined behavior in Rust.</li>
</ul>
<p><strong>Additional notes:</strong></p>
<ul>
<li><code>no_std</code> environments (embedded, kernel code) may need <code>static mut</code> because standard synchronization primitives aren't available.</li>
<li>Consider <code>AtomicU32</code> for this counter example ‚Äî it's safe and efficient.</li>
</ul>
<p><strong>Better alternative:</strong></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::sync::atomic::{AtomicU32, Ordering};
static COUNTER: AtomicU32 = AtomicU32::new(0);
fn add_to_counter(inc: u32) {
    COUNTER.fetch_add(inc, Ordering::Relaxed);
}
<span class="boring">}
</span></code></pre></pre>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="unions"><a class="header" href="#unions">Unions</a></h1>
<p>Unions are like enums, but you need to track the active field yourself:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">#[repr(C)]
union MyUnion {
    i: u8,
    b: bool,
}

fn main() {
    let u = MyUnion { i: 42 };
    println!(&quot;int: {}&quot;, unsafe { u.i });
    println!(&quot;bool: {}&quot;, unsafe { u.b });  // Undefined behavior!
}
</code></pre></pre>
<details>
<p><strong>Key points for speakers:</strong></p>
<ul>
<li>Unions share memory between all fields ‚Äî only one is valid at a time.</li>
<li>Reading a union field is always unsafe ‚Äî Rust can't track which field is active.</li>
<li><code>#[repr(C)]</code> ensures C-compatible memory layout.</li>
<li>Mostly used for C FFI; Rust enums are usually preferable.</li>
</ul>
<p><strong>Common student questions:</strong></p>
<ul>
<li><em>&quot;Why is reading unsafe?&quot;</em> - Reading the wrong field reinterprets bits as the wrong type, potentially causing undefined behavior.</li>
<li><em>&quot;How is this different from an enum?&quot;</em> - Enums have a discriminant (tag) that tracks the active variant. Unions don't ‚Äî you must track it yourself.</li>
<li><em>&quot;When would I use a union?&quot;</em> - C FFI (C unions), memory-mapped hardware registers, or rare performance optimizations.</li>
<li><em>&quot;What about the bool read?&quot;</em> - It's UB because <code>42</code> isn't a valid bool representation (only <code>0</code> and <code>1</code> are).</li>
</ul>
<p><strong>Safer alternatives:</strong></p>
<ul>
<li>For FFI: Consider generating bindings with <code>bindgen</code></li>
<li>For type punning: Use <code>zerocopy</code> crate or <code>std::mem::transmute</code></li>
<li>For tagged unions: Use Rust enums</li>
</ul>
<p><strong>Warning:</strong>
The example shows UB intentionally. In production, never read a union field unless you're certain it's the active one.</p>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="calling-unsafe-functions"><a class="header" href="#calling-unsafe-functions">Calling Unsafe Functions</a></h1>
<p>A function or method can be marked <code>unsafe</code> if it has extra preconditions you
must uphold to avoid undefined behaviour:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let emojis = &quot;üóª‚ààüåè&quot;;

    // Safe because the indices are in the correct order, within the bounds of
    // the string slice, and lie on UTF-8 sequence boundaries.
    unsafe {
        println!(&quot;{}&quot;, emojis.get_unchecked(0..4));
        println!(&quot;{}&quot;, emojis.get_unchecked(4..7));
        println!(&quot;{}&quot;, emojis.get_unchecked(7..11));
    }
}
</code></pre></pre>
<details>
<ul>
<li>Unsafe functions have preconditions that the compiler cannot verify.</li>
<li>You must wrap calls to unsafe functions in an <code>unsafe {}</code> block.</li>
<li>This signals to readers that extra care is needed to verify correctness.</li>
<li>The <code>_unchecked</code> suffix is a convention for functions that skip safety checks.</li>
<li>Violating the preconditions causes undefined behavior (UB).</li>
</ul>
</details>
```
<div style="break-before: page; page-break-before: always;"></div><h1 id="writing-unsafe-functions"><a class="header" href="#writing-unsafe-functions">Writing Unsafe Functions</a></h1>
<p>You can mark your own functions as <code>unsafe</code> if they require particular conditions to avoid undefined
behaviour.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">/// Swaps the values pointed to by the given pointers.
///
/// # Safety
///
/// The pointers must be valid and properly aligned.
unsafe fn swap(a: *mut u8, b: *mut u8) {
    let temp = *a;
    *a = *b;
    *b = temp;
}

fn main() {
    let mut a = 42;
    let mut b = 66;

    // Safe because ...
    unsafe {
        swap(&amp;mut a, &amp;mut b);
    }

    println!(&quot;a = {}, b = {}&quot;, a, b);
}
</code></pre></pre>
<details>
<p><strong>Key points for speakers:</strong></p>
<ul>
<li><code># Safety</code> doc comment is critical ‚Äî documents what callers must guarantee.</li>
<li>The <code>// Safe because ...</code> comment documents why the preconditions are met.</li>
<li>Unsafe functions can contain unsafe operations without nested <code>unsafe</code> blocks.</li>
<li><code>#[deny(unsafe_op_in_unsafe_fn)]</code> is recommended ‚Äî makes unsafe operations explicit.</li>
</ul>
<p><strong>Common student questions:</strong></p>
<ul>
<li><em>&quot;Why document safety requirements?&quot;</em> - It's the contract between function writer and caller. Without it, callers can't know what to guarantee.</li>
<li><em>&quot;Is my unsafe function always called unsafely?&quot;</em> - Yes, callers must wrap calls in <code>unsafe {}</code> and verify preconditions.</li>
<li><em>&quot;What if I forget to document safety?&quot;</em> - Clippy can warn you. It's a best practice, not enforced by the compiler.</li>
<li><em>&quot;When should a function be unsafe?&quot;</em> - When it has preconditions that, if violated, cause undefined behavior.</li>
</ul>
<p><strong>Demo suggestion:</strong>
Add <code>#[deny(unsafe_op_in_unsafe_fn)]</code> and show how the code needs to be restructured with explicit <code>unsafe</code> blocks inside.</p>
<p><strong>Best practice:</strong></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[deny(unsafe_op_in_unsafe_fn)]
unsafe fn swap(a: *mut u8, b: *mut u8) {
    // SAFETY: Caller guarantees pointers are valid and aligned
    unsafe {
        let temp = *a;
        *a = *b;
        *b = temp;
    }
}
<span class="boring">}
</span></code></pre></pre>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="calling-external-code"><a class="header" href="#calling-external-code">Calling External Code</a></h1>
<p>Functions from other languages might violate the guarantees of Rust. Calling
them is thus unsafe:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">extern &quot;C&quot; {
    fn abs(input: i32) -&gt; i32;
}

fn main() {
    unsafe {
        // Undefined behavior if abs misbehaves.
        println!(&quot;Absolute value of -3 according to C: {}&quot;, abs(-3));
    }
}
</code></pre></pre>
<details>
<p><strong>Key points for speakers:</strong></p>
<ul>
<li><code>extern &quot;C&quot;</code> declares a function using C calling conventions.</li>
<li>All calls to extern functions are unsafe ‚Äî Rust can't verify the foreign code.</li>
<li>The ABI (<code>&quot;C&quot;</code>) determines how arguments are passed and values returned.</li>
<li>This is the foundation for FFI (Foreign Function Interface).</li>
</ul>
<p><strong>Common student questions:</strong></p>
<ul>
<li><em>&quot;Why is calling abs unsafe?&quot;</em> - Rust can't verify what the C function does. It might access invalid memory, cause data races, etc.</li>
<li><em>&quot;Isn't abs from the C standard library safe?&quot;</em> - Probably, but Rust can't know that. The function signature alone doesn't prove safety.</li>
<li><em>&quot;What ABIs are available?&quot;</em> - <code>&quot;C&quot;</code> (most common), <code>&quot;system&quot;</code> (Windows API), <code>&quot;Rust&quot;</code> (default), and others. Most code uses <code>&quot;C&quot;</code>.</li>
<li><em>&quot;How do I link to a C library?&quot;</em> - Use <code>#[link(name = &quot;library&quot;)]</code> or configure in Cargo.toml with build scripts.</li>
</ul>
<p><strong>Teaching tip:</strong>
Point out that this is how Rust interoperates with existing C/C++ codebases ‚Äî essential for systems programming.</p>
<p><strong>Example extension:</strong></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[link(name = &quot;m&quot;)]  // Link to libm on Unix
extern &quot;C&quot; {
    fn sqrt(x: f64) -&gt; f64;
}
<span class="boring">}
</span></code></pre></pre>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="implementing-unsafe-traits"><a class="header" href="#implementing-unsafe-traits">Implementing Unsafe Traits</a></h1>
<p>Like with functions, you can mark a trait as <code>unsafe</code> if the implementation must guarantee
particular conditions to avoid undefined behaviour.</p>
<p>For example, the <code>zerocopy</code> crate has an unsafe trait that looks
<a href="https://docs.rs/zerocopy/latest/zerocopy/trait.AsBytes.html">something like this</a>:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::mem::size_of_val;
use std::slice;

/// ...
/// # Safety
/// The type must have a defined representation and no padding.
pub unsafe trait AsBytes {
    fn as_bytes(&amp;self) -&gt; &amp;[u8] {
        unsafe {
            slice::from_raw_parts(self as *const Self as *const u8, size_of_val(self))
        }
    }
}

// Safe because u32 has a defined representation and no padding.
unsafe impl AsBytes for u32 {}
</code></pre></pre>
<details>
<p><strong>Key points for speakers:</strong></p>
<ul>
<li>Unsafe traits have invariants that the compiler can't verify.</li>
<li><code>unsafe impl</code> means &quot;I promise this type satisfies the trait's requirements.&quot;</li>
<li>The <code># Safety</code> doc comment documents what implementers must guarantee.</li>
<li>Common unsafe traits: <code>Send</code>, <code>Sync</code>, <code>GlobalAlloc</code>.</li>
</ul>
<p><strong>Common student questions:</strong></p>
<ul>
<li><em>&quot;Why is implementing a trait unsafe?&quot;</em> - The trait's methods rely on invariants. If the impl violates them, the methods become unsound.</li>
<li><em>&quot;What about Send and Sync?&quot;</em> - They're unsafe because the compiler can't verify thread safety for all cases. Most types auto-implement them, but raw pointers opt out by default.</li>
<li><em>&quot;When would I implement an unsafe trait?&quot;</em> - Rarely. Usually for FFI types, custom allocators, or when wrapping unsafe primitives.</li>
<li><em>&quot;What does 'defined representation' mean?&quot;</em> - The memory layout is specified (e.g., <code>#[repr(C)]</code>). Rust's default representation can change between compiler versions.</li>
</ul>
<p><strong>Additional notes:</strong></p>
<ul>
<li>The <code># Safety</code> section is a documentation convention, not enforced by the compiler.</li>
<li><code>zerocopy</code> is useful for serialization without copies ‚Äî great for network protocols.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="course-6-exercises"><a class="header" href="#course-6-exercises">Course 6 Exercises</a></h1>
<p>Let us build a safe wrapper for reading directory content!</p>
<!-- <details>

After looking at the exercise, you can look at the [solution] provided.

[solution]: solutions-afternoon.md

</details> -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="safe-ffi-wrapper"><a class="header" href="#safe-ffi-wrapper">Safe FFI Wrapper</a></h1>
<p>Rust has great support for calling functions through a <em>foreign function
interface</em> (FFI). We will use this to build a safe wrapper for the <code>libc</code>
functions you would use from C to read the filenames of a directory.</p>
<p>You will want to consult the manual pages:</p>
<ul>
<li><a href="https://man7.org/linux/man-pages/man3/opendir.3.html"><code>opendir(3)</code></a></li>
<li><a href="https://man7.org/linux/man-pages/man3/readdir.3.html"><code>readdir(3)</code></a></li>
<li><a href="https://man7.org/linux/man-pages/man3/closedir.3.html"><code>closedir(3)</code></a></li>
</ul>
<p>You will also want to browse the <a href="https://doc.rust-lang.org/std/ffi/"><code>std::ffi</code></a> module, particular for <a href="https://doc.rust-lang.org/std/ffi/struct.CStr.html"><code>CStr</code></a>
and <a href="https://doc.rust-lang.org/std/ffi/struct.CString.html"><code>CString</code></a> types which are used to hold NUL-terminated strings coming from
C. The <a href="https://doc.rust-lang.org/nomicon/ffi.html">Nomicon</a> also has a very useful chapter about FFI.</p>
<p>Copy the code below to <a href="https://play.rust-lang.org/">https://play.rust-lang.org/</a> and fill in the missing
functions and methods:</p>
<pre><pre class="playground"><code class="language-rust should_panic edition2021">// TODO: remove this when you're done with your implementation.
#![allow(unused_imports, unused_variables, dead_code)]

mod ffi {
    use std::os::raw::{c_char, c_int, c_long, c_ulong, c_ushort};

    // Opaque type. See https://doc.rust-lang.org/nomicon/ffi.html.
    #[repr(C)]
    pub struct DIR {
        _data: [u8; 0],
        _marker: core::marker::PhantomData&lt;(*mut u8, core::marker::PhantomPinned)&gt;,
    }

    // Layout as per readdir(3) and definitions in /usr/include/x86_64-linux-gnu.
    #[repr(C)]
    pub struct dirent {
        pub d_ino: c_long,
        pub d_off: c_ulong,
        pub d_reclen: c_ushort,
        pub d_type: c_char,
        pub d_name: [c_char; 256],
    }

    extern &quot;C&quot; {
        pub fn opendir(s: *const c_char) -&gt; *mut DIR;
        pub fn readdir(s: *mut DIR) -&gt; *const dirent;
        pub fn closedir(s: *mut DIR) -&gt; c_int;
    }
}

use std::ffi::{CStr, CString, OsStr, OsString};
use std::os::unix::ffi::OsStrExt;

#[derive(Debug)]
struct DirectoryIterator {
    path: CString,
    dir: *mut ffi::DIR,
}

impl DirectoryIterator {
    fn new(path: &amp;str) -&gt; Result&lt;DirectoryIterator, String&gt; {
        // Call opendir and return a Ok value if that worked,
        // otherwise return Err with a message.
        unimplemented!()
    }
}

impl Iterator for DirectoryIterator {
    type Item = OsString;
    fn next(&amp;mut self) -&gt; Option&lt;OsString&gt; {
        // Keep calling readdir until we get a NULL pointer back.
        unimplemented!()
    }
}

impl Drop for DirectoryIterator {
    fn drop(&amp;mut self) {
        // Call closedir as needed.
        unimplemented!()
    }
}

fn main() -&gt; Result&lt;(), String&gt; {
    let iter = DirectoryIterator::new(&quot;.&quot;)?;
    println!(&quot;files: {:#?}&quot;, iter.collect::&lt;Vec&lt;_&gt;&gt;());
    Ok(())
}
</code></pre></pre>
<details>
<p><strong>Exercise guidance for speakers:</strong></p>
<ul>
<li>This is an advanced exercise combining FFI, unsafe, and RAII.</li>
<li>The wrapper provides a safe Rust interface to unsafe C functions.</li>
<li>Implements <code>Iterator</code> for ergonomic directory traversal.</li>
<li><code>Drop</code> ensures <code>closedir</code> is always called (RAII pattern).</li>
</ul>
<p><strong>Key concepts practiced:</strong></p>
<ol>
<li>FFI declarations with <code>extern &quot;C&quot;</code>.</li>
<li>Working with raw pointers and null checks.</li>
<li>Converting between Rust strings and C strings (<code>CStr</code>, <code>CString</code>).</li>
<li>Implementing standard traits (<code>Iterator</code>, <code>Drop</code>).</li>
<li>Encapsulating unsafe code in safe abstractions.</li>
</ol>
<p><strong>Hints to give if stuck:</strong></p>
<ul>
<li><code>CString::new(path)?.as_ptr()</code> converts Rust string to C string.</li>
<li>Check for null pointer from <code>opendir</code> (indicates error).</li>
<li><code>readdir</code> returns null when no more entries.</li>
<li><code>CStr::from_ptr(dirent.d_name.as_ptr())</code> converts C string back.</li>
<li>Implement <code>Drop</code> to call <code>closedir</code>.</li>
</ul>
<p><strong>Safety discussion:</strong></p>
<ul>
<li>Why is the FFI call unsafe?</li>
<li>How does the wrapper make it safe?</li>
<li>What invariants does the wrapper maintain?</li>
</ul>
<p><strong>Extension ideas:</strong></p>
<ul>
<li>Add error handling with <code>std::io::Error</code>.</li>
<li>Filter out <code>.</code> and <code>..</code> entries.</li>
<li>Return <code>PathBuf</code> instead of <code>String</code>.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="welcome-to-course-7"><a class="header" href="#welcome-to-course-7">Welcome to course 7</a></h1>
<p>Today we will look at:</p>
<ul>
<li>Concurrency: threads, channels, shared state, <code>Send</code> and <code>Sync</code>.</li>
</ul>
<!-- * Android: building binaries and libraries, using AIDL, logging, and
  interoperability with C, C++, and Java.

> We will attempt to call Rust from one of your own projects today. So try to
> find a little corner of your code base where we can move some lines of code to
> Rust. The fewer dependencies and "exotic" types the better. Something that
> parses some raw bytes would be ideal. -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="fearless-concurrency"><a class="header" href="#fearless-concurrency">Fearless Concurrency</a></h1>
<p>Rust has full support for concurrency using OS threads with mutexes and
channels.</p>
<p>The Rust type system plays an important role in making many concurrency bugs
compile time bugs. This is often referred to as <em>fearless concurrency</em> since you
can rely on the compiler to ensure correctness at runtime.</p>
<details>
<p><strong>Key points for speakers:</strong></p>
<ul>
<li>&quot;Fearless concurrency&quot; means the compiler catches data races at compile time.</li>
<li>Rust doesn't prevent all concurrency bugs (deadlocks are still possible), but it prevents data races.</li>
<li>The ownership system naturally extends to threads: data is either moved to one thread or shared safely.</li>
</ul>
<p><strong>Common student questions:</strong></p>
<ul>
<li><em>&quot;What's the difference between concurrency and parallelism?&quot;</em> - Concurrency is about structure (dealing with multiple things), parallelism is about execution (doing multiple things simultaneously).</li>
<li><em>&quot;How is this different from Go/Java?&quot;</em> - Those languages detect data races at runtime (or don't detect them at all). Rust catches them at compile time.</li>
<li><em>&quot;What about async/await?&quot;</em> - Rust has async too, but this course focuses on OS threads. Async is for I/O-bound tasks with many concurrent operations.</li>
</ul>
<p><strong>Common bugs Rust prevents:</strong></p>
<ul>
<li>Data races (two threads accessing same data, at least one writing)</li>
<li>Use-after-free across threads</li>
<li>Sending non-thread-safe data to another thread</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="threads"><a class="header" href="#threads">Threads</a></h1>
<p>Rust threads work similarly to threads in other languages:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::thread;
use std::time::Duration;

fn main() {
    thread::spawn(|| {
        for i in 1..10 {
            println!(&quot;Count in thread: {i}!&quot;);
            thread::sleep(Duration::from_millis(5));
        }
    });

    for i in 1..5 {
        println!(&quot;Main thread: {i}&quot;);
        thread::sleep(Duration::from_millis(5));
    }
}
</code></pre></pre>
<ul>
<li>Threads are all daemon threads, the main thread does not wait for them.</li>
<li>Thread panics are independent of each other.
<ul>
<li>Panics can carry a payload, which can be unpacked with <code>downcast_ref</code>.</li>
</ul>
</li>
</ul>
<details>
<p>Key points:</p>
<ul>
<li>
<p>Notice that the thread is stopped before it reaches 10 ‚Äî the main thread is
not waiting.</p>
</li>
<li>
<p>Use <code>let handle = thread::spawn(...)</code> and later <code>handle.join()</code> to wait for
the thread to finish.</p>
</li>
<li>
<p>Trigger a panic in the thread, notice how this doesn't affect <code>main</code>.</p>
</li>
<li>
<p>Use the <code>Result</code> return value from <code>handle.join()</code> to get access to the panic
payload. This is a good time to talk about <a href="https://doc.rust-lang.org/std/any/index.html"><code>Any</code></a>.</p>
</li>
</ul>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::thread;
use std::time::Duration;

fn main() {
    let handler = thread::spawn(|| {
        for i in 1..10 {
            println!(&quot;Count in thread: {i}!&quot;);
            thread::sleep(Duration::from_millis(5));
        }
    });

    for i in 1..5 {
        println!(&quot;Main thread: {i}&quot;);
        thread::sleep(Duration::from_millis(5));
    }
    handler.join().unwrap();
}
</code></pre></pre>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="scoped-threads"><a class="header" href="#scoped-threads">Scoped Threads</a></h1>
<p>Normal threads cannot borrow from their environment:</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail edition2021">use std::thread;

fn main() {
    let s = String::from(&quot;Hello&quot;);

    thread::spawn(|| {
        println!(&quot;Length: {}&quot;, s.len());
    });
}
</code></pre></pre>
<p>However, you can use a <a href="https://doc.rust-lang.org/std/thread/fn.scope.html">scoped thread</a> for this:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::thread;

fn main() {
    let s = String::from(&quot;Hello&quot;);

    thread::scope(|scope| {
        scope.spawn(|| {
            println!(&quot;Length: {}&quot;, s.len());
        });
    });
}
</code></pre></pre>
<details>
<ul>
<li>The reason for that is that when the <code>thread::scope</code> function completes, all the threads are guaranteed to be joined, so they can return borrowed data.</li>
<li>Normal Rust borrowing rules apply: you can either borrow mutably by one thread, or immutably by any number of threads.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="channels"><a class="header" href="#channels">Channels</a></h1>
<p>Rust channels have two parts: a <code>Sender&lt;T&gt;</code> and a <code>Receiver&lt;T&gt;</code>. The two parts
are connected via the channel, but you only see the end-points.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::sync::mpsc;
use std::thread;

fn main() {
    let (tx, rx) = mpsc::channel();

    tx.send(10).unwrap();
    tx.send(20).unwrap();

    println!(&quot;Received: {:?}&quot;, rx.recv());
    println!(&quot;Received: {:?}&quot;, rx.recv());

    let tx2 = tx.clone();
    tx2.send(30).unwrap();
    println!(&quot;Received: {:?}&quot;, rx.recv());
}
</code></pre></pre>
<details>
<ul>
<li><code>mpsc</code> stands for Multi-Producer, Single-Consumer. <code>Sender</code> and <code>SyncSender</code> implement <code>Clone</code> (so
you can make multiple producers) but <code>Receiver</code> does not.</li>
<li><code>send()</code> and <code>recv()</code> return <code>Result</code>. If they return <code>Err</code>, it means the counterpart <code>Sender</code> or
<code>Receiver</code> is dropped and the channel is closed.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="unbounded-channels"><a class="header" href="#unbounded-channels">Unbounded Channels</a></h1>
<p>You get an unbounded and asynchronous channel with <code>mpsc::channel()</code>:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::sync::mpsc;
use std::thread;
use std::time::Duration;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let thread_id = thread::current().id();
        for i in 1..10 {
            tx.send(format!(&quot;Message {i}&quot;)).unwrap();
            println!(&quot;{thread_id:?}: sent Message {i}&quot;);
        }
        println!(&quot;{thread_id:?}: done&quot;);
    });
    thread::sleep(Duration::from_millis(100));

    for msg in rx.iter() {
        println!(&quot;Main: got {}&quot;, msg);
    }
}
</code></pre></pre>
<details>
<ul>
<li><code>mpsc</code> stands for &quot;multiple producer, single consumer&quot;.</li>
<li><code>send()</code> returns a <code>Result</code> - it fails if the receiver has been dropped.</li>
<li>The receiver blocks on <code>recv()</code> until a message arrives or all senders drop.</li>
<li><code>rx.iter()</code> iterates until the channel is closed (all senders dropped).</li>
<li>Unbounded channels can grow without limit, which may cause memory issues.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bounded-channels"><a class="header" href="#bounded-channels">Bounded Channels</a></h1>
<p>Bounded and synchronous channels make <code>send</code> block the current thread:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::sync::mpsc;
use std::thread;
use std::time::Duration;

fn main() {
    let (tx, rx) = mpsc::sync_channel(3);

    thread::spawn(move || {
        let thread_id = thread::current().id();
        for i in 1..10 {
            tx.send(format!(&quot;Message {i}&quot;)).unwrap();
            println!(&quot;{thread_id:?}: sent Message {i}&quot;);
        }
        println!(&quot;{thread_id:?}: done&quot;);
    });
    thread::sleep(Duration::from_millis(100));

    for msg in rx.iter() {
        println!(&quot;Main: got {}&quot;, msg);
    }
}
</code></pre></pre>
<details>
<ul>
<li><code>sync_channel(n)</code> creates a channel with capacity <code>n</code>.</li>
<li><code>send()</code> blocks if the channel is full until space becomes available.</li>
<li>Bounded channels provide backpressure, preventing producers from overwhelming
consumers.</li>
<li>A capacity of 0 means the sender and receiver must rendezvous (synchronize).</li>
<li>Compare the output with the unbounded version to see the blocking behavior.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="shared-state"><a class="header" href="#shared-state">Shared State</a></h1>
<p>Rust uses the type system to enforce synchronization of shared data. This is
primarily done via two types:</p>
<ul>
<li><a href="https://doc.rust-lang.org/std/sync/struct.Arc.html"><code>Arc&lt;T&gt;</code></a>, atomic reference counted <code>T</code>: handles sharing between threads and
takes care to deallocate <code>T</code> when the last reference is dropped,</li>
<li><a href="https://doc.rust-lang.org/std/sync/struct.Mutex.html"><code>Mutex&lt;T&gt;</code></a>: ensures mutually exclusive access to the <code>T</code> value.</li>
</ul>
<details>
<ul>
<li><code>Arc</code> is like <code>Rc</code> but thread-safe (uses atomic operations).</li>
<li><code>Mutex</code> provides interior mutability that's safe across threads.</li>
<li>Combine them as <code>Arc&lt;Mutex&lt;T&gt;&gt;</code> to share mutable state between threads.</li>
<li><code>RwLock&lt;T&gt;</code> is an alternative that allows multiple readers or one writer.</li>
<li>Rust's type system prevents data races at compile time.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="arc"><a class="header" href="#arc"><code>Arc</code></a></h1>
<p><a href="https://doc.rust-lang.org/std/sync/struct.Arc.html"><code>Arc&lt;T&gt;</code></a> allows shared read-only access via its <code>clone</code> method:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::thread;
use std::sync::Arc;

fn main() {
    let v = Arc::new(vec![10, 20, 30]);
    let mut handles = Vec::new();
    for _ in 1..5 {
        let v = v.clone();
        handles.push(thread::spawn(move || {
            let thread_id = thread::current().id();
            println!(&quot;{thread_id:?}: {v:?}&quot;);
        }));
    }

    handles.into_iter().for_each(|h| h.join().unwrap());
    println!(&quot;v: {v:?}&quot;);
}
</code></pre></pre>
<details>
<ul>
<li>
<p><code>Arc</code> stands for &quot;Atomic Reference Counted&quot;, a thread safe version of <code>Rc</code> that uses atomic
operations.</p>
<p>&quot;The type Arc<T> provides shared ownership of a value of type T, allocated in the heap. Invoking clone on Arc produces a new Arc instance, which points to the same allocation on the heap as the source Arc, while increasing a reference count. When the last Arc pointer to a given allocation is destroyed, the value stored in that allocation (often referred to as ‚Äúinner value‚Äù) is also dropped.&quot; from <a href="https://doc.rust-lang.org/std/sync/struct.Arc.html">1</a>.</p>
<p>Also see <a href="https://medium.com/@DylanKerler1/how-arc-works-in-rust-b06192acd0a6">How arc works in rust</a></p>
</li>
<li>
<p><code>Arc&lt;T&gt;</code> implements <code>Clone</code> whether or not <code>T</code> does. It implements <code>Send</code> and <code>Sync</code> iff <code>T</code>
implements them both.</p>
</li>
<li>
<p><code>Arc::clone()</code> has the cost of atomic operations that get executed, but after that the use of the
<code>T</code> is free.</p>
</li>
<li>
<p>Beware of reference cycles, <code>Arc</code> does not use a garbage collector to detect them.</p>
<ul>
<li><code>std::sync::Weak</code> can help.</li>
</ul>
</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mutex"><a class="header" href="#mutex"><code>Mutex</code></a></h1>
<p><a href="https://doc.rust-lang.org/std/sync/struct.Mutex.html"><code>Mutex&lt;T&gt;</code></a> ensures mutual exclusion <em>and</em> allows mutable access to <code>T</code>
behind a read-only interface:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::sync::Mutex;

fn main() {
    let v: Mutex&lt;Vec&lt;i32&gt;&gt; = Mutex::new(vec![10, 20, 30]);
    println!(&quot;v: {:?}&quot;, v.lock().unwrap());

    {
        let v: &amp;Mutex&lt;Vec&lt;i32&gt;&gt; = &amp;v;
        let mut guard = v.lock().unwrap();
        guard.push(40);
    }

    println!(&quot;v: {:?}&quot;, v.lock().unwrap());
}
</code></pre></pre>
<p>Notice how we have a <a href="https://doc.rust-lang.org/std/sync/struct.Mutex.html#impl-Sync-for-Mutex%3CT%3E"><code>impl&lt;T: Send&gt; Sync for Mutex&lt;T&gt;</code></a> blanket
implementation.</p>
<details>
<ul>
<li><code>Mutex</code> in Rust looks like a collection with just one element - the protected data.
<ul>
<li>It is not possible to forget to acquire the mutex before accessing the protected data.</li>
</ul>
</li>
<li>You can get an <code>&amp;mut T</code> from an <code>&amp;Mutex&lt;T&gt;</code> by taking the lock. The <code>MutexGuard</code> ensures that the
<code>&amp;mut T</code> doesn't outlive the lock being held.</li>
<li><code>Mutex&lt;T&gt;</code> implements both <code>Send</code> and <code>Sync</code> iff <code>T</code> implements <code>Send</code>.</li>
<li>A read-write lock counterpart - <code>RwLock</code>.</li>
<li>Why does <code>lock()</code> return a <code>Result</code>?
<ul>
<li>If the thread that held the <code>Mutex</code> panicked, the <code>Mutex</code> becomes &quot;poisoned&quot;. The error signals that
the data it protected might be in an inconsistent state. Calling <code>lock()</code> on a poisoned mutex
fails with a <a href="https://doc.rust-lang.org/std/sync/struct.PoisonError.html"><code>PoisonError</code></a>. You can call <code>into_inner()</code> on the error to recover the data
regardless.</li>
</ul>
</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="example-1"><a class="header" href="#example-1">Example</a></h1>
<p>Let us see <code>Arc</code> and <code>Mutex</code> in action:</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail edition2021">use std::thread;
// use std::sync::{Arc, Mutex};

fn main() {
    let mut v = vec![10, 20, 30];
    let handle = thread::spawn(|| {
        v.push(10);
    });
    v.push(1000);

    handle.join().unwrap();
    println!(&quot;v: {v:?}&quot;);
}
</code></pre></pre>
<details>
<p>Possible solution:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::sync::{Arc, Mutex};
use std::thread;

fn main() {
    let v = Arc::new(Mutex::new(vec![10, 20, 30]));

    let v2 = v.clone();
    let handle = thread::spawn(move || {
        let mut v2 = v2.lock().unwrap();
        v2.push(10);
    });

    {
        let mut v = v.lock().unwrap();
        v.push(1000);
    }

    handle.join().unwrap();

    {
        let v = v.lock().unwrap();
        println!(&quot;v: {v:?}&quot;);
    }
}
</code></pre></pre>
<p>Notable parts:</p>
<ul>
<li><code>v</code> is wrapped in both <code>Arc</code> and <code>Mutex</code>, because their concerns are orthogonal.
<ul>
<li>Wrapping a <code>Mutex</code> in an <code>Arc</code> is a common pattern to share mutable state between threads.</li>
</ul>
</li>
<li><code>v: Arc&lt;_&gt;</code> needs to be cloned as <code>v2</code> before it can be moved into another thread. Note <code>move</code> was added to the lambda signature.</li>
<li>Blocks are introduced to narrow the scope of the <code>LockGuard</code> as much as possible.</li>
<li>We still need to acquire the <code>Mutex</code> to print our <code>Vec</code>.</li>
</ul>
<p>Below is code to slowdown the main thread to invert the pushes into the vector.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::sync::{Arc, Mutex};
use std::thread;
use std::time::Duration;

fn main() {
    let v = Arc::new(Mutex::new(vec![10, 20, 30]));

    let v2 = v.clone();
    let handle = thread::spawn(move || {
        let mut v2 = v2.lock().unwrap();
        v2.push(10);
    });

    thread::sleep(Duration::from_millis(10));

    {
        let mut v = v.lock().unwrap();
        v.push(1000);
    }

    handle.join().unwrap();

    {
        let v = v.lock().unwrap();
        println!(&quot;v: {v:?}&quot;);
    }
}
</code></pre></pre>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="send-and-sync"><a class="header" href="#send-and-sync"><code>Send</code> and <code>Sync</code></a></h1>
<p>How does Rust know to forbid shared access across thread? The answer is in two traits:</p>
<ul>
<li><a href="https://doc.rust-lang.org/std/marker/trait.Send.html"><code>Send</code></a>: a type <code>T</code> is <code>Send</code> if it is safe to move a <code>T</code> across a thread
boundary.</li>
<li><a href="https://doc.rust-lang.org/std/marker/trait.Sync.html"><code>Sync</code></a>: a type <code>T</code> is <code>Sync</code> if it is safe to move a <code>&amp;T</code> across a thread
boundary.</li>
</ul>
<p><code>Send</code> and <code>Sync</code> are <a href="concurrency/../unsafe/unsafe-traits.html">unsafe traits</a>. The compiler will automatically derive them for your types
as long as they only contain <code>Send</code> and <code>Sync</code> types. You can also implement them manually when you
know it is valid.</p>
<details>
<ul>
<li>One can think of these traits as markers that the type has certain thread-safety properties.</li>
<li>They can be used in the generic constraints as normal traits.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="send"><a class="header" href="#send"><code>Send</code></a></h1>
<blockquote>
<p>A type <code>T</code> is <a href="https://doc.rust-lang.org/std/marker/trait.Send.html"><code>Send</code></a> if it is safe to move a <code>T</code> value to another thread.</p>
</blockquote>
<p>The effect of moving ownership to another thread is that <em>destructors</em> will run
in that thread. So the question is when you can allocate a value in one thread
and deallocate it in another.</p>
<details>
<p><strong>Key points for speakers:</strong></p>
<ul>
<li><code>Send</code> is a marker trait with no methods ‚Äî it's purely a compile-time guarantee.</li>
<li>A type is <code>Send</code> if ownership can safely transfer to another thread.</li>
<li>Most types are automatically <code>Send</code> if all their fields are <code>Send</code>.</li>
<li>The key insight: if destructors run on a different thread, is that safe?</li>
</ul>
<p><strong>Common student questions:</strong></p>
<ul>
<li><em>&quot;Why does it matter where destructors run?&quot;</em> - Some resources (like OS handles, thread-local storage) must be released on the same thread that created them.</li>
<li><em>&quot;Do I need to implement Send manually?&quot;</em> - Almost never. The compiler derives it automatically. You only implement it manually for unsafe abstractions.</li>
<li><em>&quot;What happens if I try to send a non-Send type?&quot;</em> - The compiler will reject it with a clear error message.</li>
</ul>
<p><strong>Demo suggestion:</strong></p>
<pre><pre class="playground"><code class="language-rust edition2021">use std::rc::Rc;
use std::thread;

fn main() {
    let rc = Rc::new(5);
    // This won't compile:
    // thread::spawn(move || println!(&quot;{}&quot;, rc));
}
</code></pre></pre>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sync"><a class="header" href="#sync"><code>Sync</code></a></h1>
<blockquote>
<p>A type <code>T</code> is <a href="https://doc.rust-lang.org/std/marker/trait.Sync.html"><code>Sync</code></a> if it is safe to access a <code>T</code> value from multiple
threads at the same time.</p>
</blockquote>
<p>More precisely, the definition is:</p>
<blockquote>
<p><code>T</code> is <code>Sync</code> if and only if <code>&amp;T</code> is <code>Send</code></p>
</blockquote>
<details>
<p>This statement is essentially a shorthand way of saying that if a type is thread-safe for shared use, it is also thread-safe to pass references of it across threads.</p>
<p>This is because if a type is Sync it means that it can be shared across multiple threads without the risk of data races or other synchronization issues, so it is safe to move it to another thread. A reference to the type is also safe to move to another thread, because the data it references can be accessed from any thread safely.</p>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="examples"><a class="header" href="#examples">Examples</a></h1>
<h2 id="send--sync"><a class="header" href="#send--sync"><code>Send + Sync</code></a></h2>
<p>Most types you come across are <code>Send + Sync</code>:</p>
<ul>
<li><code>i8</code>, <code>f32</code>, <code>bool</code>, <code>char</code>, <code>&amp;str</code>, ...</li>
<li><code>(T1, T2)</code>, <code>[T; N]</code>, <code>&amp;[T]</code>, <code>struct { x: T }</code>, ...</li>
<li><code>String</code>, <code>Option&lt;T&gt;</code>, <code>Vec&lt;T&gt;</code>, <code>Box&lt;T&gt;</code>, ...</li>
<li><code>Arc&lt;T&gt;</code>: Explicitly thread-safe via atomic reference count.</li>
<li><code>Mutex&lt;T&gt;</code>: Explicitly thread-safe via internal locking.</li>
<li><code>AtomicBool</code>, <code>AtomicU8</code>, ...: Uses special atomic instructions.</li>
</ul>
<p>The generic types are typically <code>Send + Sync</code> when the type parameters are
<code>Send + Sync</code>.</p>
<h2 id="send--sync-1"><a class="header" href="#send--sync-1"><code>Send + !Sync</code></a></h2>
<p>These types can be moved to other threads, but they're not thread-safe.
Typically because of interior mutability:</p>
<ul>
<li><code>mpsc::Sender&lt;T&gt;</code></li>
<li><code>mpsc::Receiver&lt;T&gt;</code></li>
<li><code>Cell&lt;T&gt;</code></li>
<li><code>RefCell&lt;T&gt;</code></li>
</ul>
<h2 id="send--sync-2"><a class="header" href="#send--sync-2"><code>!Send + Sync</code></a></h2>
<p>These types are thread-safe, but they cannot be moved to another thread:</p>
<ul>
<li><code>MutexGuard&lt;T&gt;</code>: Uses OS level primitives which must be deallocated on the
thread which created them.</li>
</ul>
<h2 id="send--sync-3"><a class="header" href="#send--sync-3"><code>!Send + !Sync</code></a></h2>
<p>These types are not thread-safe and cannot be moved to other threads:</p>
<ul>
<li><code>Rc&lt;T&gt;</code>: each <code>Rc&lt;T&gt;</code> has a reference to an <code>RcBox&lt;T&gt;</code>, which contains a
non-atomic reference count.</li>
<li><code>*const T</code>, <code>*mut T</code>: Rust assumes raw pointers may have special
concurrency considerations.</li>
</ul>
<details>
<p><strong>Key points for speakers:</strong></p>
<ul>
<li>This is a reference table ‚Äî students don't need to memorize it, but should understand the categories.</li>
<li><code>Send + Sync</code> is the &quot;happy path&quot; ‚Äî most types you write will be both.</li>
<li>Interior mutability (<code>Cell</code>, <code>RefCell</code>) breaks <code>Sync</code> because concurrent mutation without synchronization is unsafe.</li>
<li><code>Rc</code> is the classic example of <code>!Send + !Sync</code> ‚Äî its reference count isn't atomic.</li>
</ul>
<p><strong>Common student questions:</strong></p>
<ul>
<li><em>&quot;Why is <code>MutexGuard</code> not <code>Send</code>?&quot;</em> - Many OS mutex implementations require unlock to happen on the same thread as lock. It IS <code>Sync</code> though, because multiple threads can safely have references to it.</li>
<li><em>&quot;Why is <code>Arc</code> both Send and Sync but <code>Rc</code> is neither?&quot;</em> - <code>Arc</code> uses atomic operations for its reference count, making concurrent access safe. <code>Rc</code> uses non-atomic operations for performance.</li>
<li><em>&quot;What about <code>Cell</code> vs <code>RefCell</code>?&quot;</em> - Both are <code>Send</code> (can move to another thread) but neither is <code>Sync</code> (can't share references across threads) because they allow mutation through shared references.</li>
</ul>
<p><strong>Teaching tip:</strong>
Draw a 2x2 grid on the board with Send/!Send on one axis and Sync/!Sync on the other. Place common types in each quadrant as you discuss them.</p>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="exercises"><a class="header" href="#exercises">Exercises</a></h1>
<p>Let us practice our new concurrency skills with</p>
<ul>
<li>
<p>Dining philosophers: a classic problem in concurrency.</p>
</li>
<li>
<p>Multi-threaded link checker: a larger project where you'll use Cargo to
download dependencies and then check links in parallel.</p>
</li>
</ul>
<!-- <details>

After looking at the exercises, you can look at the [solutions] provided.

[solutions]: solutions-morning.md

</details> -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="dining-philosophers"><a class="header" href="#dining-philosophers">Dining Philosophers</a></h1>
<p>The dining philosophers problem is a classic problem in concurrency:</p>
<blockquote>
<p>Five philosophers dine together at the same table. Each philosopher has their
own place at the table. There is a fork between each plate. The dish served is
a kind of spaghetti which has to be eaten with two forks. Each philosopher can
only alternately think and eat. Moreover, a philosopher can only eat their
spaghetti when they have both a left and right fork. Thus two forks will only
be available when their two nearest neighbors are thinking, not eating. After
an individual philosopher finishes eating, they will put down both forks.</p>
</blockquote>
<p>You will need a local <a href="exercises/course-7/../../cargo/running-locally.html">Cargo installation</a> for
this exercise. Copy the code below to <code>src/main.rs</code> file, fill out the blanks,
and test that <code>cargo run</code> does not deadlock:</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2021">use std::sync::mpsc;
use std::sync::{Arc, Mutex};
use std::thread;
use std::time::Duration;

struct Chopstick;

struct Philosopher {
    name: String,
    // left_chopstick: ...
    // right_chopstick: ...
    // thoughts: ...
}

impl Philosopher {
    fn think(&amp;self) {
        self.thoughts
            .send(format!(&quot;Eureka! {} has a new idea!&quot;, &amp;self.name))
            .unwrap();
    }

    fn eat(&amp;self) {
        // Pick up chopsticks...
        println!(&quot;{} is eating...&quot;, &amp;self.name);
        thread::sleep(Duration::from_millis(10));
    }
}

static PHILOSOPHERS: &amp;[&amp;str] =
    &amp;[&quot;Socrates&quot;, &quot;Hypatia&quot;, &quot;Plato&quot;, &quot;Aristotle&quot;, &quot;Pythagoras&quot;];

fn main() {
    // Create chopsticks

    // Create philosophers

    // Make them think and eat

    // Output their thoughts
}
</code></pre></pre>
<details>
<p><strong>Exercise guidance for speakers:</strong></p>
<ul>
<li>Classic concurrency exercise demonstrating deadlock and how to avoid it.</li>
<li>Uses <code>Arc&lt;Mutex&lt;T&gt;&gt;</code> for shared state across threads.</li>
<li>The naive solution (each philosopher picks up left fork, then right) deadlocks!</li>
<li>Solution: break symmetry (e.g., one philosopher picks up forks in opposite order).</li>
</ul>
<p><strong>Key concepts practiced:</strong></p>
<ol>
<li>Thread spawning with <code>std::thread::spawn</code>.</li>
<li>Shared state with <code>Arc&lt;Mutex&lt;T&gt;&gt;</code>.</li>
<li>Deadlock causes and prevention strategies.</li>
<li>Channel communication with <code>mpsc</code>.</li>
</ol>
<p><strong>Deadlock explanation:</strong>
If all philosophers pick up their left fork simultaneously, no one can pick up their right fork. They all wait forever.</p>
<p><strong>Common solutions:</strong></p>
<ol>
<li><strong>Asymmetric</strong>: One philosopher picks up right fork first.</li>
<li><strong>Resource hierarchy</strong>: Number forks, always pick up lower-numbered first.</li>
<li><strong>Arbitrator</strong>: Central authority grants permission to eat.</li>
<li><strong>Try-lock</strong>: If can't get second fork, release first and retry.</li>
</ol>
<p><strong>Hints to give if stuck:</strong></p>
<ul>
<li>Chopsticks are <code>Arc&lt;Mutex&lt;()&gt;&gt;</code> or <code>Arc&lt;Mutex&lt;Chopstick&gt;&gt;</code>.</li>
<li>Each philosopher is a separate thread.</li>
<li>Use channels to collect thoughts.</li>
<li>To avoid deadlock: make one philosopher &quot;left-handed.&quot;</li>
</ul>
<p><strong>Testing:</strong>
Run multiple times ‚Äî deadlocks are non-deterministic. If it hangs, there's a deadlock.</p>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="multi-threaded-link-checker"><a class="header" href="#multi-threaded-link-checker">Multi-threaded Link Checker</a></h1>
<p>Let us use our new knowledge to create a multi-threaded link checker. It should
start at a webpage and check that links on the page are valid. It should
recursively check other pages on the same domain and keep doing this until all
pages have been validated.</p>
<p>For this, you will need an HTTP client such as <a href="https://docs.rs/reqwest/"><code>reqwest</code></a>. Create a new
Cargo project and <code>reqwest</code> it as a dependency with:</p>
<pre><code class="language-shell">$ cargo new link-checker
$ cd link-checker
$ cargo add --features blocking,rustls-tls reqwest
</code></pre>
<blockquote>
<p>If <code>cargo add</code> fails with <code>error: no such subcommand</code>, then please edit the
<code>Cargo.toml</code> file by hand. Add the dependencies listed below.</p>
</blockquote>
<p>You will also need a way to find links. We can use <a href="https://docs.rs/scraper/"><code>scraper</code></a> for that:</p>
<pre><code class="language-shell">$ cargo add scraper
</code></pre>
<p>Finally, we'll need some way of handling errors. We use <a href="https://docs.rs/thiserror/"><code>thiserror</code></a> for
that:</p>
<pre><code class="language-shell">$ cargo add thiserror
</code></pre>
<p>The <code>cargo add</code> calls will update the <code>Cargo.toml</code> file to look like this:</p>
<pre><code class="language-toml">[dependencies]
reqwest = { version = &quot;0.11.12&quot;, features = [&quot;blocking&quot;, &quot;rustls-tls&quot;] }
scraper = &quot;0.13.0&quot;
thiserror = &quot;1.0.37&quot;
</code></pre>
<p>You can now download the start page. Try with a small site such as
<code>https://www.google.org/</code>.</p>
<p>Your <code>src/main.rs</code> file should look something like this:</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2021">use reqwest::blocking::{get, Response};
use reqwest::Url;
use scraper::{Html, Selector};
use thiserror::Error;

#[derive(Error, Debug)]
enum Error {
    #[error(&quot;request error: {0}&quot;)]
    ReqwestError(#[from] reqwest::Error),
}

fn extract_links(response: Response) -&gt; Result&lt;Vec&lt;Url&gt;, Error&gt; {
    let base_url = response.url().to_owned();
    let document = response.text()?;
    let html = Html::parse_document(&amp;document);
    let selector = Selector::parse(&quot;a&quot;).unwrap();

    let mut valid_urls = Vec::new();
    for element in html.select(&amp;selector) {
        if let Some(href) = element.value().attr(&quot;href&quot;) {
            match base_url.join(href) {
                Ok(url) =&gt; valid_urls.push(url),
                Err(err) =&gt; {
                    println!(&quot;On {base_url}: could not parse {href:?}: {err} (ignored)&quot;,);
                }
            }
        }
    }

    Ok(valid_urls)
}

fn main() {
    let start_url = Url::parse(&quot;https://www.google.org&quot;).unwrap();
    let response = get(start_url).unwrap();
    match extract_links(response) {
        Ok(links) =&gt; println!(&quot;Links: {links:#?}&quot;),
        Err(err) =&gt; println!(&quot;Could not extract links: {err:#}&quot;),
    }
}
</code></pre></pre>
<p>Run the code in <code>src/main.rs</code> with</p>
<pre><code class="language-shell">$ cargo run
</code></pre>
<h2 id="tasks"><a class="header" href="#tasks">Tasks</a></h2>
<ul>
<li>Use threads to check the links in parallel: send the URLs to be checked to a
channel and let a few threads check the URLs in parallel.</li>
<li>Extend this to recursively extract links from all pages on the
<code>www.google.org</code> domain. Put an upper limit of 100 pages or so so that you
don't end up being blocked by the site.</li>
</ul>
<details>
<p><strong>Exercise guidance for speakers:</strong></p>
<ul>
<li>This is a capstone exercise combining threads, channels, and real networking.</li>
<li>Start simple: single-threaded, then add parallelism.</li>
<li>Careful with URL handling: relative vs absolute, same-domain filtering.</li>
<li>Use a HashSet to track visited URLs and avoid cycles.</li>
</ul>
<p><strong>Key concepts practiced:</strong></p>
<ol>
<li>HTTP requests with <code>reqwest</code>.</li>
<li>HTML parsing with <code>scraper</code>.</li>
<li>Thread pools and work distribution via channels.</li>
<li>Error handling with <code>thiserror</code>.</li>
</ol>
<p><strong>Architecture suggestions:</strong></p>
<pre><code>Main Thread              Worker Threads
    |                         |
    v                         v
[URL Queue] --channel--&gt; [Fetch &amp; Parse]
    ^                         |
    |                         v
    +-------- results --------+
</code></pre>
<p><strong>Hints to give if stuck:</strong></p>
<ul>
<li>Use <code>mpsc::channel</code> for URL distribution.</li>
<li><code>HashSet&lt;Url&gt;</code> tracks visited pages.</li>
<li>Filter to same domain: <code>url.host() == start_url.host()</code>.</li>
<li>Handle relative URLs with <code>base_url.join(relative)</code>.</li>
</ul>
<p><strong>Common challenges:</strong></p>
<ul>
<li>Rate limiting (add delays between requests).</li>
<li>Error handling for failed requests.</li>
<li>Graceful shutdown when queue is empty.</li>
<li>Memory management for large crawls.</li>
</ul>
<p><strong>Extension ideas:</strong></p>
<ul>
<li>Add retry logic for failed requests.</li>
<li>Report broken links (404s).</li>
<li>Respect robots.txt.</li>
</ul>
</details>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script>
            window.playground_copyable = true;
        </script>
        <script src="ace.js"></script>
        <script src="editor.js"></script>
        <script src="mode-rust.js"></script>
        <script src="theme-dawn.js"></script>
        <script src="theme-tomorrow_night.js"></script>
        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>
        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ga4.js"></script>
        <script src="speaker-notes.js"></script>
        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
